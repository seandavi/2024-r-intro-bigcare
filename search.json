[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduction to R for BigCare 2024",
    "section": "",
    "text": "Preface",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#who-is-this-book-for",
    "href": "index.html#who-is-this-book-for",
    "title": "Introduction to R for BigCare 2024",
    "section": "Who is this book for?",
    "text": "Who is this book for?\n\nPeople who want to learn data science\nPeople who want to teach data science\nPeople who want to learn how to teach data science\nPeople who want to learn how to learn data science",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#why-this-book",
    "href": "index.html#why-this-book",
    "title": "Introduction to R for BigCare 2024",
    "section": "Why this book?",
    "text": "Why this book?\nThis book is a collection of resources for learning R and Bioconductor. It is meant to be largely self-directed, but for those looking to teach data science, it can also be used as a guide for structuring a course. Material is a bit variable in terms of difficulty, prerequisites, and format which is a reflection of the organic creation of the material.\nStudents are encouraged to work with others to learn the material. Instructors are encouraged to use the material to create a course that is tailored to the needs of their students and to spend lots of time in 1:1 and small groups to support students in their learning. See below for additional thoughts on adult learning and how it relates to this material.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#adult-learners",
    "href": "index.html#adult-learners",
    "title": "Introduction to R for BigCare 2024",
    "section": "Adult learners",
    "text": "Adult learners\nAdult Learning Theory, also known as Andragogy, is the concept and practice of designing, developing, and delivering instructional experiences for adult learners. It is based on the belief that adults learn differently than children, and thus, require distinct approaches to engage, motivate, and retain information (Center 2016). The term was first introduced by Malcolm Knowles, an American educator who is known for his work in adult education (Knowles, Holton, and Swanson 2005).\nOne of the fundamental principles of Adult Learning Theory is that adults are self-directed learners. This means that we prefer to take control of our own learning process and set personal goals for themselves. We are motivated by our desire to solve problems or gain knowledge to improve our lives (see Figure 1). As a result, educational content for adults should be relevant and applicable to real-life situations. Furthermore, adult learners should be given opportunities to actively engage in the learning process by making choices, setting goals, and evaluating their progress.\n\n\n\n\n\nFigure 1: Why do adults choose to learn something?\n\n\nAnother key aspect of Adult Learning Theory is the role of experience. We bring a wealth of experience to the learning process, which serves as a resource for new learning. We often have well-established beliefs, values, and mental models that can influence our willingness to accept new ideas and concepts. Therefore, it is essential to acknowledge and respect our shared and unique past experiences and create an environment where we all feel comfortable sharing our perspectives.\nTo effectively learn as a group of adult learners, it is crucial to establish a collaborative learning environment that promotes open communication and fosters trust among participants. We all appreciate and strive for a respectful and supportive atmosphere where we can express our opinions without fear of judgment. Instructors should help facilitate discussions, encourage peer-to-peer interactions, and incorporate group activities and collaboration to capitalize on the collective knowledge of participants.\nAdditionally, adult learners often have multiple responsibilities outside of the learning environment, such as work and family commitments. As a result, we require flexible learning opportunities that accommodate busy schedules. Offering a variety of instructional formats, such as online modules, self-paced learning, or evening classes, can help ensure that adult learners have access to education despite any time constraints.\nAdult learners benefit from a learner-centered approach that focuses on the individual needs, preferences, and interests of each participant can greatly enhance the overall learning experience. In addition, we tend to be more intrinsically motivated to learn when we have a sense of autonomy and can practice and experiment (see Figure 2) with new concepts in a safe environment.\n\n\n\n\n\n\n\nFigure 2: How to stay stuck in data science (or anything). The “Read-Do” loop tends to deliver the best results. Too much reading between doing can be somewhat effective. Reading and simply copy-paste is probably the least effective. When working through material, experiment. Try to break things. Incorporate your own experience or applications whenever possible.\n\n\n\n\nUnderstanding Adult Learning Theory and its principles can significantly enhance the effectiveness of teaching and learning as adults. By respecting our autonomy, acknowledging our experiences, creating a supportive learning environment, offering flexible learning opportunities, and utilizing diverse teaching methods, we can better cater to the unique needs and preferences of adult learners.\nIn practice, that means that we will will not be prescriptive in our approach to teaching data science. We will not tell you what to do, but rather we will provide you with a variety of options and you can choose what works best for you. We will also provide you with a variety of resources and you can choose where to focus your time. Given that we cannot possibly cover everything, we will provide you with a framework for learning and you can fill in the gaps as you see fit. A key component of our success as adult learners is to gain the confidence to ask questions and problem-solve on our own.\n\n\n\n\n\n\nCenter, Pew Research. 2016. “Lifelong Learning and Technology.” Pew Research Center: Internet, Science & Tech. https://www.pewresearch.org/internet/2016/03/22/lifelong-learning-and-technology/.\n\n\nKnowles, Malcolm S., Elwood F. Holton, and Richard A. Swanson. 2005. The Adult Learner: The Definitive Classic in Adult Education and Human Resource Development. 6th ed. Amsterdam ; Boston: Elsevier.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "010_rstudio_and_r.html",
    "href": "010_rstudio_and_r.html",
    "title": "1  Introduction",
    "section": "",
    "text": "1.1 What is R?\nR is a programming language and software environment designed for statistical computing and graphics. It is widely used by statisticians, data scientists, and researchers for data analysis and visualization. R is an open-source language, which means it is free to use, modify, and distribute. Over the years, R has become particularly popular (see Figure 1.1) in the fields of genomics and bioinformatics, owing to its extensive libraries and powerful data manipulation capabilities.\nThe R language is a dialect of the S language, which was developed in the 1970s at Bell Laboratories. The first version of R was written by Robert Gentleman and Ross Ihaka and released in 1995 (see this slide deck for Ross Ihaka’s take on R’s history). Since then, R has been continuously developed by the R Core Team, a group of statisticians and computer scientists. The R Core Team releases a new version of R every year.",
    "crumbs": [
      "Getting started",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "010_rstudio_and_r.html#what-is-r",
    "href": "010_rstudio_and_r.html#what-is-r",
    "title": "1  Introduction",
    "section": "",
    "text": "Figure 1.1: Google trends showing the popularity of R over time based on Google searches.",
    "crumbs": [
      "Getting started",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "010_rstudio_and_r.html#why-use-r",
    "href": "010_rstudio_and_r.html#why-use-r",
    "title": "1  Introduction",
    "section": "1.2 Why use R?",
    "text": "1.2 Why use R?\nThere are several reasons why R is a popular choice for data analysis, particularly in genomics and bioinformatics. These include:\n\nOpen-source1: R is free to use and has a large community of developers who contribute to its growth and development. Open source software is software with source code that anyone can inspect, modify, and enhance.\nExtensive libraries: There are thousands of R packages available for a wide range of tasks, including specialized packages for genomics and bioinformatics. These libraries have been extensively tested and ara available for free.\nData manipulation: R has powerful data manipulation capabilities, making it easy (or at least possible) to clean, process, and analyze large datasets.\nGraphics and visualization: R has excellent tools for creating high-quality graphics and visualizations that can be customized to meet the specific needs of your analysis. In most cases, graphics produced by R are publication-quality.\nReproducible research: R enables you to create reproducible research by recording your analysis in a script, which can be easily shared and executed by others. In addition, R does not have a meaningful graphical user interface (GUI), which renders analysis in R much more reproducible than tools that rely on GUI interactions.\nCross-platform: R runs on Windows, Mac, and Linux (as well as more obscure systems).\nInteroperability with other languages: R can interfact with FORTRAN, C, and many other languages.\nScalability: R is useful for small and large projects. I can develop code for analysis on my Mac laptop. I can then install the same code on our 20k core cluster and run it in parallel on 100 samples, monitor the process, and then update a database (for example) with R when complete.\n\n1 Source code is the code computer programmers can manipulate to change how a piece of software—a “program” or “application”—works. Programmers who have access to a computer program’s source code can improve that program by adding features to it or fixing parts that don’t always work correctly. For more details, see what is “open-source”?",
    "crumbs": [
      "Getting started",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "010_rstudio_and_r.html#why-not-use-r",
    "href": "010_rstudio_and_r.html#why-not-use-r",
    "title": "1  Introduction",
    "section": "1.3 Why not use R?",
    "text": "1.3 Why not use R?\n\nR cannot do everything. There are some tasks that are better suited to other languages or tools. However, R can often be used to interface with these other tools.\nR is not always the “best” tool for the job. (However, it is often a “good” tool for the job.)\nR will not hold your hand. Often, it will slap your hand instead. In other words, R is not always user-friendly and can be difficult to learn. (We’ll try to make it easier for you in this book and by providing you with a good foundation for learning R and getting help when you need it.)\nThe documentation can be opaque (but there is documentation).\nR can drive you crazy (on a good day) or age you prematurely (on a bad one).\nFinding the right package to do the job you want to do can be challenging; worse, some contributed packages are unreliable or poorly documented.\nR does not have a meaningfully useful graphical user interface (GUI). If you are used to working with a GUI, you may find R difficult to use at first.\n\nAdditional reasons to consider other tools include access to expertise and support from colleagues and coworkers. If you are working in a group that uses python, for example, you may want to use python for your analysis to take advantage of the expertise of your colleagues.",
    "crumbs": [
      "Getting started",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "010_rstudio_and_r.html#r-license-and-the-open-source-ideal",
    "href": "010_rstudio_and_r.html#r-license-and-the-open-source-ideal",
    "title": "1  Introduction",
    "section": "1.4 R License and the Open Source Ideal",
    "text": "1.4 R License and the Open Source Ideal\nR is free (yes, totally free!) and distributed under GNU license. In particular, this license allows one to:\n\nDownload the source code\nModify the source code to your heart’s content\nDistribute the modified source code and even charge money for it, but you must distribute the modified source code under the original GNU license.\n\nThis license means that R will always be available, will always be open source, and can grow organically without constraint.",
    "crumbs": [
      "Getting started",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "010_rstudio_and_r.html#rstudio",
    "href": "010_rstudio_and_r.html#rstudio",
    "title": "1  Introduction",
    "section": "1.5 RStudio",
    "text": "1.5 RStudio\nRStudio is an integrated development environment (IDE) for R. RStudio also provides several other useful features, including a built-in console, syntax-highlighting editor, and tools for plotting, history, debugging, workspace management, and workspace viewing. RStudio is available in both free and commercial editions; the commercial edition provides some additional features, including support for multiple sessions and enhanced debugging. For the vast majority of users, the free version is more than sufficient.\n\n1.5.1 Getting started with RStudio\nTo get started with RStudio, you first need to install both R and RStudio on your computer. Follow these steps:\n\nDownload and install R from the official R website.\nDownload and install RStudio from the official RStudio website.\nLaunch RStudio. You should see the RStudio interface with four panels as shown in Figure 1.2.\n\n\n\n1.5.2 The RStudio Interface\nRStudio’s interface consists of four panels (see Figure 1.2) that provide different functionalities:\n\n\nConsole\n\nThis panel displays the R console, where you can enter and execute R commands directly. The console also shows the output of your code, error messages, and other information.\n\n\n\nSource\n\nThis panel is where you write and edit your R scripts. You can create new scripts, open existing ones, and run your code from this panel.\n\n\n\nEnvironment\n\nThis panel displays your current workspace, including all variables, data objects, and functions that you have created or loaded in your R session.\n\n\n\nPlots, Packages, Help, and Viewer\n\nThese panels display plots, installed packages, help files, and web content, respectively.\n\n\n\n\n\n\n\n\n\nFigure 1.2: The RStudio interface. In this layout, the source pane is in the upper left, the console is in the lower left, the environment panel is in the top right and the viewer/help/files panel is in the bottom right.\n\n\n\n\n\n\n\n\n\nDo I need to use RStudio?\n\n\n\nNo. You can use R without RStudio. Other interfaces, such as jupyter notebooks or VScode are great alternatives. However, RStudio makes it easy to write and execute R code, and it provides several useful features that are not available in the basic R console. Note that the only part of RStudio that is actually interacting with R directly is the console. The other panels are simply providing a GUI that enhances the user experience.\n\n\n\n\n\n\n\n\nCustomizing the RStudio Interface\n\n\n\nYou can customize the layout of RStudio to suit your preferences. To do so, go to Tools &gt; Global Options &gt; Appearance. Here, you can change the theme, font size, and panel layout. You can also resize the panels as needed to gain screen real estate (see Figure 1.3).\n\n\n\n\n\n\n\n\nFigure 1.3: Dealing with limited screen real estate can be a challenge, particularly when you want to open another window to, for example, view a web page. You can resize the panes by sliding the center divider (red arrows) or by clicking on the minimize/maximize buttons (see blue arrow).",
    "crumbs": [
      "Getting started",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "010_rstudio_and_r.html#summary",
    "href": "010_rstudio_and_r.html#summary",
    "title": "1  Introduction",
    "section": "1.6 Summary",
    "text": "1.6 Summary\nAt this point, you should have a working Rstudio installation on your computer. In the next chapter, we will discuss the basics of R programming, including how to perform simple calculations, create variables, and use functions.",
    "crumbs": [
      "Getting started",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "010_rstudio_and_r.html#setup-for-the-materials",
    "href": "010_rstudio_and_r.html#setup-for-the-materials",
    "title": "1  Introduction",
    "section": "1.7 Setup for the materials",
    "text": "1.7 Setup for the materials\nIn this book, we will use R and RStudio for all of our examples. I use additional packages besides those that come with R itself. To install these packages, you can use the following code. Paste this into the R console in RStudio:\n# Install the necessary packages\ninstall.packages('BiocManager')\nBiocManager::install('remotes')\nBiocManager::install('seandavi/2024-r-intro-bigcare')\nThis code will install the BiocManager package, which is used to install packages from the Bioconductor repository, and the remotes package, which is used to install packages from GitHub. We will use the seandavi/2024-r-intro-bigcare package, which contains all of the data and functions we will use in this book.",
    "crumbs": [
      "Getting started",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "020_r_basics.html",
    "href": "020_r_basics.html",
    "title": "\n2  The R language\n",
    "section": "",
    "text": "2.1 The R User Interface\nThe RStudio interface is simple. You type R code into the bottom line of the RStudio console pane and then click Enter to run it. The code you type is called a command, because it will command your computer to do something for you. The line you type it into is called the command line.\nWhen you type a command at the prompt and hit Enter, your computer executes the command and shows you the results. Then RStudio displays a fresh prompt for your next command. For example, if you type 1 + 1 and hit Enter, RStudio will display:\nYou’ll notice that a [1] appears next to your result. R is just letting you know that this line begins with the first value in your result. Some commands return more than one value, and their results may fill up multiple lines. For example, the command 100:130 returns 31 values; it creates a sequence of integers from 100 to 130. Notice that new bracketed numbers appear at the start of the second and third lines of output. These numbers just mean that the second line begins with the 14th value in the result, and the third line begins with the 25th value. You can mostly ignore the numbers that appear in brackets:\nIf you type an incomplete command and press Enter, R will display a + prompt, which means R is waiting for you to type the rest of your command. Either finish the command or hit Escape to start over:\nIf you type a command that R doesn’t recognize, R will return an error message. If you ever see an error message, don’t panic. R is just telling you that your computer couldn’t understand or do what you asked it to do. You can then try a different command at the next prompt:\nOnce you get the hang of the command line, you can easily do anything in R that you would do with a calculator. For example, you could do some basic arithmetic:\n2 * 3   \n\n[1] 6\n\n4 - 1   \n\n[1] 3\n\n# this obeys order-of-operations\n6 / (4 - 1)   \n\n[1] 2\nMost of the arithmetic operators in R are the same as those on a calculator, but R uses different symbols for some of them:\nThe ^ operator raises the number to its left to the power of the number to its right: for example 3^2 is 9. The modulo returns the remainder of the division of the number to the left by the number on its right, for example 5 modulo 3 or 5 %% 3 is 2.",
    "crumbs": [
      "Getting started",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>The R language</span>"
    ]
  },
  {
    "objectID": "020_r_basics.html#the-r-user-interface",
    "href": "020_r_basics.html#the-r-user-interface",
    "title": "\n2  The R language\n",
    "section": "",
    "text": "Figure 2.1: Your computer does your bidding when you type R commands at the prompt in the bottom line of the console pane. Don’t forget to hit the Enter key. When you first open RStudio, the console appears in the pane on your left, but you can change this with File &gt; Tools &gt; Global Options in the menu bar.\n\n\n\n&gt; 1 + 1\n[1] 2\n&gt;\n\n&gt; 100:130\n [1] 100 101 102 103 104 105 106 107 108 109 110 111 112\n[14] 113 114 115 116 117 118 119 120 121 122 123 124 125\n[25] 126 127 128 129 130\n\n\n\n\n\n\nTip\n\n\n\nThe colon operator (:) returns every integer between two integers. It is an easy way to create a sequence of numbers.\n\n\n\n\n\n\n\n\nWhen do we compile?\n\n\n\nIn some languages, like C, Java, and FORTRAN, you have to compile your human-readable code into machine-readable code (often 1s and 0s) before you can run it. If you’ve programmed in such a language before, you may wonder whether you have to compile your R code before you can use it. The answer is no. R is a dynamic programming language, which means R automatically interprets your code as you run it.\n\n\n\n&gt; 5 -\n+\n+ 1\n[1] 4\n\n&gt; 3 % 5\nError: unexpected input in \"3 % 5\"\n&gt;\n\n\n\n\n\n\nTip\n\n\n\nWhenever you get an error message in R, consider googling the error message. You’ll often find that someone else has had the same problem and has posted a solution online. Simply cutting-and-pasting the error message into a search engine will often work\n\n\n\n\n\n\nAddition: +\n\nSubtraction: -\n\nMultiplication: *\n\nDivision: /\n\nExponentiation: ^\n\nModulo: %%\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nR treats the hashtag character, #, in a special way; R will not run anything that follows a hashtag on a line. This makes hashtags very useful for adding comments and annotations to your code. Humans will be able to read the comments, but your computer will pass over them. The hashtag is known as the commenting symbol in R.\n\n\n\n\n\n\n\n\nCancelling commands\n\n\n\nSome R commands may take a long time to run. You can cancel a command once it has begun by pressing ctrl + c or by clicking the “stop sign” if it is available in Rstudio. Note that it may also take R a long time to cancel the command.\n\n\n\n2.1.1 An exercise\nThat’s the basic interface for executing R code in RStudio. Think you have it? If so, try doing these simple tasks. If you execute everything correctly, you should end up with the same number that you started with:\n\nChoose any number and add 2 to it.\nMultiply the result by 3.\nSubtract 6 from the answer.\nDivide what you get by 3.\n\n\n10 + 2\n\n[1] 12\n\n12 * 3\n\n[1] 36\n\n36 - 6\n\n[1] 30\n\n30 / 3\n\n[1] 10",
    "crumbs": [
      "Getting started",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>The R language</span>"
    ]
  },
  {
    "objectID": "020_r_basics.html#objects",
    "href": "020_r_basics.html#objects",
    "title": "\n2  The R language\n",
    "section": "\n2.2 Objects",
    "text": "2.2 Objects\nNow that you know how to use R, let’s use it to make a virtual die. The : operator from a couple of pages ago gives you a nice way to create a group of numbers from one to six. The : operator returns its results as a vector (we are going to work with vectors in more detail), a one-dimensional set of numbers:\n1:6\n## 1 2 3 4 5 6\nThat’s all there is to how a virtual die looks! But you are not done yet. Running 1:6 generated a vector of numbers for you to see, but it didn’t save that vector anywhere for later use. If we want to use those numbers again, we’ll have to ask your computer to save them somewhere. You can do that by creating an R object.\nR lets you save data by storing it inside an R object. What is an object? Just a name that you can use to call up stored data. For example, you can save data into an object like a or b. Wherever R encounters the object, it will replace it with the data saved inside, like so:\n\na &lt;- 1\na\n\n[1] 1\n\n\n\na + 2\n\n[1] 3\n\n\n\n\n\n\n\n\nWhat just happened?\n\n\n\n\nTo create an R object, choose a name and then use the less-than symbol, &lt;, followed by a minus sign, -, to save data into it. This combination looks like an arrow, &lt;-. R will make an object, give it your name, and store in it whatever follows the arrow. So a &lt;- 1 stores 1 in an object named a.\nWhen you ask R what’s in a, R tells you on the next line.\nYou can use your object in new R commands, too. Since a previously stored the value of 1, you’re now adding 1 to 2.\n\n\n\n\n\n\n\n\n\nAssignment vs expressions\n\n\n\nEverything that you type into the R console can be assigned to one of two categories:\n\nAssignments\nExpressions\n\nAn expression is a command that tells R to do something. For example, 1 + 2 is an expression that tells R to add 1 and 2. When you type an expression into the R console, R will evaluate the expression and return the result. For example, if you type 1 + 2 into the R console, R will return 3. Expressions can have “side effects” but they don’t explicitly result in anything being added to R memory.\n\n5 + 2\n\n[1] 7\n\n28 %% 3\n\n[1] 1\n\n3^2\n\n[1] 9\n\n5 + 4 * 4 + 4 ^ 4 / 10\n\n[1] 46.6\n\n\nWhile using R as a calculator is interesting, to do useful and interesting things, we need to assign values to objects. To create objects, we need to give it a name followed by the assignment operator &lt;- (or, entirely equivalently, =) and the value we want to give it:\n\nweight_kg &lt;- 55\n\n\n\nSo, for another example, the following code would create an object named die that contains the numbers one through six. To see what is stored in an object, just type the object’s name by itself:\n\ndie &lt;- 1:6\ndie\n\n[1] 1 2 3 4 5 6\n\n\nWhen you create an object, the object will appear in the environment pane of RStudio, as shown in Figure 2.2. This pane will show you all of the objects you’ve created since opening RStudio.\n\n\n\n\n\nFigure 2.2: Assignment creates an object in the environment pane.\n\n\nYou can name an object in R almost anything you want, but there are a few rules. First, a name cannot start with a number. Second, a name cannot use some special symbols, like ^, !, $, @, +, -, /, or *:\n\n\nGood names\nNames that cause errors\n\n\n\na\n1trial\n\n\nb\n$\n\n\nFOO\n^mean\n\n\nmy_var\n2nd\n\n\n.day\n!bad\n\n\n\n\n\n\n\n\n\nCapitalization matters\n\n\n\nR is case-sensitive, so name and Name will refer to different objects:\n&gt; Name = 0\n&gt; Name + 1\n[1] 1\n&gt; name + 1\nError: object 'name' not found\nThe error above is a common one!\n\n\nFinally, R will overwrite any previous information stored in an object without asking you for permission. So, it is a good idea to not use names that are already taken:\n\nmy_number &lt;- 1\nmy_number \n\n[1] 1\n\n\n\nmy_number &lt;- 999\nmy_number\n\n[1] 999\n\n\nYou can see which object names you have already used with the function ls:\nls()\nYour environment will contain different names than mine, because you have probably created different objects.\nYou can also see which names you have used by examining RStudio’s environment pane.\nWe can remove an object from the environment using the rm function. For example, to create and then remove an object named to_disappear, you could run the following code:\nto_disappear &lt;- 1\nrm(to_disappear)\nto_disappear # this will return an error\nWe now have a virtual die that is stored in the computer’s memory and which has a name that we can use to refer to it. You can access it whenever you like by typing the word die.\nSo what can you do with this die? Quite a lot. R will replace an object with its contents whenever the object’s name appears in a command. So, for example, you can do all sorts of math with the die. Math isn’t so helpful for rolling dice, but manipulating sets of numbers will be your stock and trade as a data scientist. So let’s take a look at how to do that:\n\ndie - 1\n\n[1] 0 1 2 3 4 5\n\ndie / 2\n\n[1] 0.5 1.0 1.5 2.0 2.5 3.0\n\ndie * die\n\n[1]  1  4  9 16 25 36\n\n\nR uses element-wise execution when working with a vector like die. When you manipulate a set of numbers, R will apply the same operation to each element in the set. So for example, when you run die - 1, R subtracts one from each element of die.\nWhen you use two or more vectors in an operation, R will line up the vectors and perform a sequence of individual operations. For example, when you run die * die, R lines up the two die vectors and then multiplies the first element of vector 1 by the first element of vector 2. R then multiplies the second element of vector 1 by the second element of vector 2, and so on, until every element has been multiplied. The result will be a new vector the same length as the first two {Figure 2.3}.\n\n\n\n\n\nFigure 2.3: “When R performs element-wise execution, it matches up vectors and then manipulates each pair of elements independently.”\n\n\nIf you give R two vectors of unequal lengths, R will repeat the shorter vector until it is as long as the longer vector, and then do the math, as shown in Figure 2.4. This isn’t a permanent change–the shorter vector will be its original size after R does the math. If the length of the short vector does not divide evenly into the length of the long vector, R will return a warning message. This behavior is known as vector recycling, and it helps R do element-wise operations:\n\n1:2\n\n[1] 1 2\n\n1:4\n\n[1] 1 2 3 4\n\ndie\n\n[1] 1 2 3 4 5 6\n\ndie + 1:2\n\n[1] 2 4 4 6 6 8\n\ndie + 1:4\n\nWarning in die + 1:4: longer object length is not a multiple of shorter object\nlength\n\n\n[1] 2 4 6 8 6 8\n\n\n\n\n\n\n\nFigure 2.4: “R will repeat a short vector to do element-wise operations with two vectors of uneven lengths.”\n\n\nElement-wise operations are a very useful feature in R because they manipulate groups of values in an orderly way. When you start working with data sets, element-wise operations will ensure that values from one observation or case are only paired with values from the same observation or case. Element-wise operations also make it easier to write your own programs and functions in R.\n\n\n\n\n\n\nElement-wise operations are not matrix operations\n\n\n\nIt is important to know that operations with vectors are not the same that you might expect if you are expecting R to perform “matrix” operations. R can do inner multiplication with the %*% operator and outer multiplication with the %o% operator:\n# Inner product (1*1 + 2*2 + 3*3 + 4*4 + 5*5 + 6*6)\ndie %*% die\n# Outer product (will be a 6 x 6 matrix with \n#  all possible products of the two vectors)\ndie %o% die\n\n\nNow that you can do math with your die object, let’s look at how you could “roll” it. Rolling your die will require something more sophisticated than basic arithmetic; you’ll need to randomly select one of the die’s values. And for that, you will need a function.\nWhile we’ve seen functions already, the next section will discuss R functions more formally.",
    "crumbs": [
      "Getting started",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>The R language</span>"
    ]
  },
  {
    "objectID": "030_r_functions.html",
    "href": "030_r_functions.html",
    "title": "\n3  Using functions in R\n",
    "section": "",
    "text": "3.1 Function example: sample with replacement\nIf you set size = 2, you can almost simulate a pair of dice. Before we run that code, think for a minute why that might be the case. sample will return two numbers, one for each die:\nsample(die, size = 2)\n\n[1] 3 1\nI said this “almost” works because this method does something funny. If you use it many times, you’ll notice that the second die never has the same value as the first die, which means you’ll never roll something like a pair of threes or snake eyes. What is going on?\nBy default, sample builds a sample without replacement. To see what this means, imagine that sample places all of the values of die in a jar or urn. Then imagine that sample reaches into the jar and pulls out values one by one to build its sample. Once a value has been drawn from the jar, sample sets it aside. The value doesn’t go back into the jar, so it cannot be drawn again. So if sample selects a six on its first draw, it will not be able to select a six on the second draw; six is no longer in the jar to be selected. Although sample creates its sample electronically, it follows this seemingly physical behavior.\nOne side effect of this behavior is that each draw depends on the draws that come before it. In the real world, however, when you roll a pair of dice, each die is independent of the other. If the first die comes up six, it does not prevent the second die from coming up six. In fact, it doesn’t influence the second die in any way whatsoever. You can recreate this behavior in sample by adding the argument replace = TRUE:\nsample(die, size = 2, replace = TRUE)\n\n[1] 5 4\nThe argument replace = TRUE causes sample to sample with replacement. Our jar example provides a good way to understand the difference between sampling with replacement and without. When sample uses replacement, it draws a value from the jar and records the value. Then it puts the value back into the jar. In other words, sample replaces each value after each draw. As a result, sample may select the same value on the second draw. Each value has a chance of being selected each time. It is as if every draw were the first draw.\nSampling with replacement is an easy way to create independent random samples. Each value in your sample will be a sample of size one that is independent of the other values. This is the correct way to simulate a pair of dice:\nsample(die, size = 2, replace = TRUE)\n\n[1] 4 2\nCongratulate yourself; you’ve just run your first simulation in R! You now have a method for simulating the result of rolling a pair of dice. If you want to add up the dice, you can feed your result straight into the sum function:\ndice &lt;- sample(die, size = 2, replace = TRUE)\ndice\n\n[1] 1 3\n\nsum(dice)\n\n[1] 4\nWhat would happen if you call dice multiple times? Would R generate a new pair of dice values each time? Let’s give it a try:\ndice\n\n[1] 1 3\n\ndice\n\n[1] 1 3\n\ndice\n\n[1] 1 3\nThe name dice refers to a vector of two numbers. Calling more than once does not change the favlue. Each time you call dice, R will show you the result of that one time you called sample and saved the output to dice. R won’t rerun sample(die, 2, replace = TRUE) to create a new roll of the dice. Once you save a set of results to an R object, those results do not change.\nHowever, it would be convenient to have an object that can re-roll the dice whenever you call it. You can make such an object by writing your own R function.",
    "crumbs": [
      "Getting started",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Using functions in R</span>"
    ]
  },
  {
    "objectID": "030_r_functions.html#write-functions",
    "href": "030_r_functions.html#write-functions",
    "title": "\n3  Using functions in R\n",
    "section": "\n3.2 Writing Your Own Functions",
    "text": "3.2 Writing Your Own Functions\nTo recap, you already have working R code that simulates rolling a pair of dice:\n\ndie &lt;- 1:6\ndice &lt;- sample(die, size = 2, replace = TRUE)\nsum(dice)\n\n[1] 7\n\n\nYou can retype this code into the console anytime you want to re-roll your dice. However, this is an awkward way to work with the code. It would be easier to use your code if you wrapped it into its own function, which is exactly what we’ll do now. We’re going to write a function named roll that you can use to roll your virtual dice. When you’re finished, the function will work like this: each time you call roll(), R will return the sum of rolling two dice:\nroll()\n## 8 \n\nroll()\n## 3\n\nroll()\n## 7\nFunctions may seem mysterious or fancy, but they are just another type of R object. Instead of containing data, they contain code. This code is stored in a special format that makes it easy to reuse the code in new situations. You can write your own functions by recreating this format.\n\n3.2.1 The Function Constructor\nEvery function in R has three basic parts: a name, a body of code, and a set of arguments. To make your own function, you need to replicate these parts and store them in an R object, which you can do with the function function. To do this, call function() and follow it with a pair of braces, {}:\n\nmy_function &lt;- function() {}\n\nThis function, as written, doesn’t do anything (yet). However, it is a valid function. You can call it by typing its name followed by an open and closed parenthesis:\n\nmy_function()\n\nNULL\n\n\nfunction will build a function out of whatever R code you place between the braces. For example, you can turn your dice code into a function by calling:\n\nroll &lt;- function() {\n    die &lt;- 1:6\n    dice &lt;- sample(die, size = 2, replace = TRUE)\n    sum(dice)\n}\n\n\n\n\n\n\n\nIndentation and readability\n\n\n\nNotice each line of code between the braces is indented. This makes the code easier to read but has no impact on how the code runs. R ignores spaces and line breaks and executes one complete expression at a time. Note that in other languages like python, spacing is extremely important and part of the language.\n\n\nJust hit the Enter key between each line after the first brace, {. R will wait for you to type the last brace, }, before it responds.\nDon’t forget to save the output of function to an R object. This object will become your new function. To use it, write the object’s name followed by an open and closed parenthesis:\n\nroll()\n\n[1] 6\n\n\nYou can think of the parentheses as the “trigger” that causes R to run the function. If you type in a function’s name without the parentheses, R will show you the code that is stored inside the function. If you type in the name with the parentheses, R will run that code:\n\nroll\n\nfunction() {\n    die &lt;- 1:6\n    dice &lt;- sample(die, size = 2, replace = TRUE)\n    sum(dice)\n}\n\nroll()\n\n[1] 8\n\n\nThe code that you place inside your function is known as the body of the function. When you run a function in R, R will execute all of the code in the body and then return the result of the last line of code. If the last line of code doesn’t return a value, neither will your function, so you want to ensure that your final line of code returns a value. One way to check this is to think about what would happen if you ran the body of code line by line in the command line. Would R display a result after the last line, or would it not?\nHere’s some code that would display a result:\ndice\n1 + 1\nsqrt(2)\nAnd here’s some code that would not:\ndice &lt;- sample(die, size = 2, replace = TRUE)\ntwo &lt;- 1 + 1\na &lt;- sqrt(2)\nAgain, this is just showing the distinction between expressions and assignments.",
    "crumbs": [
      "Getting started",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Using functions in R</span>"
    ]
  },
  {
    "objectID": "030_r_functions.html#arguments",
    "href": "030_r_functions.html#arguments",
    "title": "\n3  Using functions in R\n",
    "section": "\n3.3 Arguments",
    "text": "3.3 Arguments\nWhat if we removed one line of code from our function and changed the name die to bones (just a name–don’t think of it as important), like this?\n\nroll2 &lt;- function() {\n    dice &lt;- sample(bones, size = 2, replace = TRUE)\n    sum(dice)\n}\n\nNow I’ll get an error when I run the function. The function needs the object bones to do its job, but there is no object named bones to be found (you can check by typing ls() which will show you the names in the environment, or memory).\nroll2()\n## Error in sample(bones, size = 2, replace = TRUE) : \n##   object 'bones' not found\nYou can supply bones when you call roll2 if you make bones an argument of the function. To do this, put the name bones in the parentheses that follow function when you define roll2:\n\nroll2 &lt;- function(bones) {\n    dice &lt;- sample(bones, size = 2, replace = TRUE)\n    sum(dice)\n}\n\nNow roll2 will work as long as you supply bones when you call the function. You can take advantage of this to roll different types of dice each time you call roll2.\nRemember, we’re rolling pairs of dice:\n\nroll2(bones = 1:4)\n\n[1] 6\n\nroll2(bones = 1:6)\n\n[1] 8\n\nroll2(1:20)\n\n[1] 29\n\n\nNotice that roll2 will still give an error if you do not supply a value for the bones argument when you call roll2:\nroll2()\n## Error in sample(bones, size = 2, replace = TRUE) : \n##   argument \"bones\" is missing, with no default\nYou can prevent this error by giving the bones argument a default value. To do this, set bones equal to a value when you define roll2:\n\nroll2 &lt;- function(bones = 1:6) {\n    dice &lt;- sample(bones, size = 2, replace = TRUE)\n    sum(dice)\n}\n\nNow you can supply a new value for bones if you like, and roll2 will use the default if you do not:\n\nroll2()\n\n[1] 4\n\n\nYou can give your functions as many arguments as you like. Just list their names, separated by commas, in the parentheses that follow function. When the function is run, R will replace each argument name in the function body with the value that the user supplies for the argument. If the user does not supply a value, R will replace the argument name with the argument’s default value (if you defined one).\nTo summarize, function helps you construct your own R functions. You create a body of code for your function to run by writing code between the braces that follow function. You create arguments for your function to use by supplying their names in the parentheses that follow function. Finally, you give your function a name by saving its output to an R object, as shown in Figure 3.2.\nOnce you’ve created your function, R will treat it like every other function in R. Think about how useful this is. Have you ever tried to create a new Excel option and add it to Microsoft’s menu bar? Or a new slide animation and add it to Powerpoint’s options? When you work with a programming language, you can do these types of things. As you learn to program in R, you will be able to create new, customized, reproducible tools for yourself whenever you like.\n\n\n\n\n\nFigure 3.2: “Every function in R has the same parts, and you can use function to create these parts. Assign the result to a name, so you can call the function later.”",
    "crumbs": [
      "Getting started",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Using functions in R</span>"
    ]
  },
  {
    "objectID": "045_loading_data.html",
    "href": "045_loading_data.html",
    "title": "\n4  Loading data\n",
    "section": "",
    "text": "4.1 What are CSV and TSV files?\nCSV (Comma-Separated Values) and TSV (Tab-Separated Values) are both simple file formats used to store tabular data, such as spreadsheets or databases. The main difference is the delimiter used to separate values:\nIn both formats:\nBoth formats are popular because they’re simple, readable, and can be opened by many programs, including text editors and spreadsheet software. TSV files can be particularly useful when your data contains commas within fields.",
    "crumbs": [
      "Getting started",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Loading data</span>"
    ]
  },
  {
    "objectID": "045_loading_data.html#what-are-csv-and-tsv-files",
    "href": "045_loading_data.html#what-are-csv-and-tsv-files",
    "title": "\n4  Loading data\n",
    "section": "",
    "text": "CSV files use commas (,) to separate values\nTSV files use tabs ( to separate values\n\n\n\nEach line represents a row of data\nThe first row often contains column names (headers)",
    "crumbs": [
      "Getting started",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Loading data</span>"
    ]
  },
  {
    "objectID": "045_loading_data.html#downloading-a-tsv-file-using-r",
    "href": "045_loading_data.html#downloading-a-tsv-file-using-r",
    "title": "\n4  Loading data\n",
    "section": "\n4.2 Downloading a TSV file using R",
    "text": "4.2 Downloading a TSV file using R\nThis section is just to get us a TSV file to work with. If you have a CSV or TSV file on your local machine, you can skip this step and read your own.\nLet’s see how to download a TSV file from the internet using R’s download.file() function.\n\n# URL of the TSV file (this is a fake URL for demonstration)\ntsv_url &lt;- \"https://ftp.ncbi.nlm.nih.gov/pub/clinvar/disease_names\"\n\n# Local file name to save the TSV\nlocal_file &lt;- \"disease_names.tsv\"\n\n# Download the file\ndownload.file(url = tsv_url, destfile = local_file)\n\nIf you look in your file system, you should see a file named disease_names.tsv containing the data from the URL.\n\n\n\n\n\n\nTip\n\n\n\nYou can use the terminal to examine a file’s contents. For example, you can use head disease_names.tsv to view the first few lines of the file. This can be helpful to understand the structure of the data without loading it into R first. In Rstudio, you can also use the Rstudio terminal to run shell commands.\n\n\n\n\n\n\nActivating the terminal in RstudioThis code does the following:\n\nWe specify the URL of the TSV file we want to download.\nWe choose a name for the local file where we’ll save the downloaded data.\nWe use download.file() to fetch the file from the URL and save it locally.",
    "crumbs": [
      "Getting started",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Loading data</span>"
    ]
  },
  {
    "objectID": "045_loading_data.html#loading-the-tsv-file-into-r",
    "href": "045_loading_data.html#loading-the-tsv-file-into-r",
    "title": "\n4  Loading data\n",
    "section": "\n4.3 Loading the TSV file into R",
    "text": "4.3 Loading the TSV file into R\nNow that we have a TSV file, let’s load it into R using the read.delim() function, which is designed for tab-separated files.\n\n# Load the TSV file into a variable called 'df_sample'\ndf_sample &lt;- read.delim(\"disease_names.tsv\")\n\n# View the first few rows of the data\nhead(df_sample)\n\n                             X.DiseaseName SourceName ConceptID SourceID\n1                                See Cases                              \n2             (3r,5r)-fluvastatin response                              \n3             (3r,5s)-fluvastatin response                              \n4                  (r)-citalopram response                              \n5                   (s)-methadone response                              \n6 + FETAL MICROARRAY COPY IN REGION 9p13.2                              \n  DiseaseMIM LastModified                 Category\n1         NA  27 Oct 2022                  Disease\n2         NA  08 Jul 2022 Pharmacological response\n3         NA  08 Jul 2022 Pharmacological response\n4         NA  08 Jul 2022 Pharmacological response\n5         NA  08 Jul 2022 Pharmacological response\n6         NA  23 Sep 2022                  Finding\n\n# Get a summary of the data\nsummary(df_sample)\n\n X.DiseaseName       SourceName         ConceptID           SourceID        \n Length:63673       Length:63673       Length:63673       Length:63673      \n Class :character   Class :character   Class :character   Class :character  \n Mode  :character   Mode  :character   Mode  :character   Mode  :character  \n                                                                            \n                                                                            \n                                                                            \n                                                                            \n   DiseaseMIM     LastModified         Category        \n Min.   :100050   Length:63673       Length:63673      \n 1st Qu.:239842   Class :character   Class :character  \n Median :607422   Mode  :character   Mode  :character  \n Mean   :454478                                        \n 3rd Qu.:615551                                        \n Max.   :620877                                        \n NA's   :53491                                         \n\n\nLet’s break down what’s happening here:\n\n\nread.delim() reads the TSV file and creates a data frame in R. By default, it assumes tab-separated values and headers in the first row.\nWe store this data frame in a variable called df_sample. The prefix ‘df_’ is a common convention to indicate that the variable is a data frame.\n\nhead(df_sample) shows the first six rows of the data, which is useful for a quick peek at your dataset.\n\nsummary(df_sample) provides a statistical summary of each column in your dataset.",
    "crumbs": [
      "Getting started",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Loading data</span>"
    ]
  },
  {
    "objectID": "045_loading_data.html#additional-tips",
    "href": "045_loading_data.html#additional-tips",
    "title": "\n4  Loading data\n",
    "section": "\n4.4 Additional tips",
    "text": "4.4 Additional tips\n\nFor CSV files, you would use read.csv() instead: df_sample &lt;- read.csv(\"sample_data.csv\")\n\nIf your TSV file doesn’t have headers, use: read.delim(\"file.tsv\", header = FALSE)\n\nFor large files, consider using read.delim() or read.csv() with the parameter nrows to read only a portion of the file for initial inspection.\nIf you’re unsure about the delimiter, you can specify it explicitly:\n\nFor TSV: read.delim(\"file.tsv\", sep = \"\\t\")\n\nFor CSV: read.csv(\"file.csv\", sep = \",\")\n\n\n\n\nRemember to always check your data after loading it to ensure it was read correctly!",
    "crumbs": [
      "Getting started",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Loading data</span>"
    ]
  },
  {
    "objectID": "045_loading_data.html#write-data-to-a-csv-file",
    "href": "045_loading_data.html#write-data-to-a-csv-file",
    "title": "\n4  Loading data\n",
    "section": "\n4.5 Write data to a CSV file",
    "text": "4.5 Write data to a CSV file\nRemember that we read the data from a TSV file. If you want to write this data to a CSV file, you can use the write.csv() function:\n\nwrite.csv(df_sample, \"disease_names.csv\", row.names = FALSE)\n\nThis will write the data frame df_sample to a CSV file named disease_names.csv without including row names. You can then use this CSV file for further analysis or sharing with others.",
    "crumbs": [
      "Getting started",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Loading data</span>"
    ]
  },
  {
    "objectID": "045_loading_data.html#working-with-data-from-excel",
    "href": "045_loading_data.html#working-with-data-from-excel",
    "title": "\n4  Loading data\n",
    "section": "\n4.6 Working with data from Excel",
    "text": "4.6 Working with data from Excel\nWhen working with data that originates in Excel, the easiest way to get the data into R is often to save the data as a CSV file from Excel and then read it into R using read.csv().\nThere is also the readxl package in R that allows you to read Excel files directly. This package provides functions like read_excel() to read data from Excel files into R data frames. If you have Excel files, you can explore this package for reading Excel data into R.",
    "crumbs": [
      "Getting started",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Loading data</span>"
    ]
  },
  {
    "objectID": "050_r_scripts.html",
    "href": "050_r_scripts.html",
    "title": "5  R Scripts",
    "section": "",
    "text": "5.1 What are R Scripts?\nR scripts are text files containing a series of R commands and code that can be executed sequentially. They serve as a way to store, organize, and run R code in a reproducible manner. R scripts typically have a .R file extension and can be created and edited using any text editor or integrated development environment (IDE) like RStudio.",
    "crumbs": [
      "Getting started",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>R Scripts</span>"
    ]
  },
  {
    "objectID": "050_r_scripts.html#why-are-r-scripts-useful",
    "href": "050_r_scripts.html#why-are-r-scripts-useful",
    "title": "5  R Scripts",
    "section": "5.2 Why are R Scripts Useful?",
    "text": "5.2 Why are R Scripts Useful?\nR scripts offer several advantages for data analysis and programming:\n\nReproducibility: Scripts allow you to save and rerun your analysis, ensuring consistent results.\nOrganization: They help structure your work logically, making it easier to understand and maintain.\nEfficiency: You can execute multiple commands at once, saving time on repetitive tasks.\nCollaboration: Scripts can be easily shared with colleagues, promoting teamwork and knowledge transfer.\nVersion Control: They integrate well with version control systems like Git, allowing you to track changes over time.\nDocumentation: You can include comments in your scripts, explaining your thought process and methodology.",
    "crumbs": [
      "Getting started",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>R Scripts</span>"
    ]
  },
  {
    "objectID": "050_r_scripts.html#creating-an-r-script-using-rstudio",
    "href": "050_r_scripts.html#creating-an-r-script-using-rstudio",
    "title": "5  R Scripts",
    "section": "5.3 Creating an R Script Using RStudio",
    "text": "5.3 Creating an R Script Using RStudio\nTo create an R script in RStudio, follow these steps:\n\nOpen RStudio.\nClick on File &gt; New File &gt; R Script (or use the keyboard shortcut Ctrl+Shift+N on Windows/Linux, Cmd+Shift+N on Mac).\nA new untitled script will open in the editor pane.\nStart writing your R code in the script.\nTo save the script, click on File &gt; Save (or use Ctrl+S / Cmd+S) and choose a name and location for your file.\n\nHere’s a simple example of what your R script might look like:\n# This is a comment in R\n# Let's create a script that rolls a die.\ndie_roll &lt;- sample(1:6, 1, replace = TRUE)\nprint(paste(\"You rolled a\", die_roll))\n\n# Let's add our roll2() function to our script\nroll2 &lt;- function(bones = 1:6) {\n    dice &lt;- sample(bones, size = 2, replace = TRUE)\n    sum(dice)\n}\nPaste this code into your R script and save it with a meaningful name, such as roll_die.R. This script defines a die-rolling function roll2() and prints the result of a single die roll.\n\nTip: Use comments (lines starting with #) to explain your code and provide context for others (and your future self).",
    "crumbs": [
      "Getting started",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>R Scripts</span>"
    ]
  },
  {
    "objectID": "050_r_scripts.html#interacting-with",
    "href": "050_r_scripts.html#interacting-with",
    "title": "5  R Scripts",
    "section": "5.4 Interacting with",
    "text": "5.4 Interacting with",
    "crumbs": [
      "Getting started",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>R Scripts</span>"
    ]
  },
  {
    "objectID": "050_r_scripts.html#loading-an-r-script-after-saving",
    "href": "050_r_scripts.html#loading-an-r-script-after-saving",
    "title": "5  R Scripts",
    "section": "5.5 Loading an R Script After Saving",
    "text": "5.5 Loading an R Script After Saving\nOnce you’ve saved an R script, you can load and run it in several ways:\n\nUsing the source() function: This is the most common method to load and execute an R script.\nsource(\"path/to/your/script.R\")\nReplace “path/to/your/script.R” with the actual path to your saved script.\nIn RStudio:\n\nOpen the script file in RStudio.\nClick the “Source” button in the editor pane, or use the keyboard shortcut Ctrl+Shift+S (Windows/Linux) or Cmd+Shift+S (Mac).\n\nFrom the R console: You can also load a script directly from the R console:\nfile.edit(\"path/to/your/script.R\")\nThis will open the script in the editor, allowing you to review and modify it before running.\n\nRemember, when you load a script using source(), all the code in the script will be executed. If you only want to load the functions or objects defined in the script without running all the code, you can use the source() function with the local = TRUE argument:\nenv &lt;- new.env()\nsource(\"path/to/your/script.R\", local = env)\nThis loads the script’s contents into a new environment, allowing you to access its functions and objects without executing the entire script.\nBy mastering R scripts, you’ll be able to create more organized, reproducible, and efficient data analysis workflows in R.",
    "crumbs": [
      "Getting started",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>R Scripts</span>"
    ]
  },
  {
    "objectID": "eda.html",
    "href": "eda.html",
    "title": "\n6  Exploratory data analysis\n",
    "section": "",
    "text": "6.1 What is exploratory data analysis?\nExploratory data analysis (EDA) is an approach to analyzing data sets to summarize their main characteristics, often with visual methods. A statistical model can be used or not, but primarily EDA is for seeing what the data can tell us beyond the formal modeling or hypothesis testing task.\nEDA is a crucial step in the data analysis process. It allows us to understand the data, identify patterns, and develop hypotheses. EDA is also useful for identifying outliers, missing values, and other data quality issues.\nIt is worth noting that EDA is not a formal process. There are no strict rules or guidelines for conducting EDA. Instead, it is an iterative process that involves exploring the data from multiple angles to gain a comprehensive understanding of the data.",
    "crumbs": [
      "Exploring data",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Exploratory data analysis</span>"
    ]
  },
  {
    "objectID": "eda.html#the-insurance-dataset",
    "href": "eda.html#the-insurance-dataset",
    "title": "\n6  Exploratory data analysis\n",
    "section": "\n6.2 The insurance dataset",
    "text": "6.2 The insurance dataset\nWe are going to load up our insurance.csv dataset again and explore it in detail.\n\ninsurance_url &lt;- \"https://raw.githubusercontent.com/stedy/Machine-Learning-with-R-datasets/master/insurance.csv\"\ninsurance &lt;- readr::read_csv(insurance_url)\n\nRows: 1338 Columns: 7\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (3): sex, smoker, region\ndbl (4): age, bmi, children, charges\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\nAt this point, you might want to refresh your memory of the contents of the insurance dataset.\n\nHow many rows does thd dataset have?\nHow many columns?\nWhat are the column names for the dataset?\nWhat are the data types in each column?\n\n\nPossible solutions to the questionsnrow(insurance)\nncol(insurance)\n# You could also use dim(insurance)\ncolnames(insurance)\n# the `tibble` object gives column types\nhead(insurance)\n# OR\nsummary(insurance)\n# OR\nlapply(insurance, class)\n\n\nBefore going further, let’s add the obese column again.\n\ninsurance$obese &lt;- ifelse(insurance$bmi &gt; 30, \"obese\", \"not obese\")\n\nCheck the structure of the insurance dataset again to ensure that you got what you wanted, a new column with either ‘obese’ or ‘not obese’ in each row.",
    "crumbs": [
      "Exploring data",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Exploratory data analysis</span>"
    ]
  },
  {
    "objectID": "eda.html#explore-each-variable-column",
    "href": "eda.html#explore-each-variable-column",
    "title": "\n6  Exploratory data analysis\n",
    "section": "\n6.3 Explore each variable (column)",
    "text": "6.3 Explore each variable (column)\nWhen presented with a dataframe like the insurance data, we may want to interrogate the various columns to figure out what is in them. In this dataset, the columns are of two flavors. We can use the terms column and variable interchangably here since each column represents the measurements of that variable on a person.\nThe sex, smoker, and region variables are all categorical variables, in that they represent categories of “sex”, “smoker”, and “region”. The age, bmi, children, and charge variables represent numbers.\n\n6.3.1 Categorical variables\nFor categorial variables, there are some useful functions to help summarize the data. But to do so, we need to be able to pull out the individual columns. Let’s take the “region” column as an example. All of the following will get us the region column.\n\ninsurance$region\ninsurance[[\"region\"]]\ninsurance[, \"region\"]\n\nThe unique() function returns all unique values of a variable. The table() function counts the number of each value. While min() and max() are perhaps not that meaningful, they can sometimes be useful, even for categorical variables.\nLet’s apply these to the region variable/column.\n\nunique(insurance$region)\n\n[1] \"southwest\" \"southeast\" \"northwest\" \"northeast\"\n\ntable(insurance[[\"region\"]])\n\n\nnortheast northwest southeast southwest \n      324       325       364       325 \n\nmin(insurance$region)\n\n[1] \"northeast\"\n\nmax(insurance$region)\n\n[1] \"southwest\"\n\n\nCan you explain what the min() and max() are doing here?\nDo the same exercise with sex, smoker, and obese variables.\n\n6.3.2 Numeric variables\nThe other variables in our insurance dataset are numeric. Note that they are not all continuous numbers, though, with some of them being quite discrete (there are no fractional numbers of children).\nFor numerical variables, we can start to use statistics to summarize the data.\n\n\n\n\n\n\nWhat is a statistic?\n\n\n\nA statistic is a single value that summarizes a dataset. We use them all the time in data analysis. The mean, median, standard deviation, mode, etc. are all univariate statistics. Correlation is an example of a bivariate statistic that summarizes the relationship between two variables. Statistics like the t-statistic summarize the differences in centrality between two samples.\n\n\nThe summary() function gets us a bunch of statistics quickly.\n\nsummary(insurance)\n\n      age            sex                 bmi           children    \n Min.   :18.00   Length:1338        Min.   :15.96   Min.   :0.000  \n 1st Qu.:27.00   Class :character   1st Qu.:26.30   1st Qu.:0.000  \n Median :39.00   Mode  :character   Median :30.40   Median :1.000  \n Mean   :39.21                      Mean   :30.66   Mean   :1.095  \n 3rd Qu.:51.00                      3rd Qu.:34.69   3rd Qu.:2.000  \n Max.   :64.00                      Max.   :53.13   Max.   :5.000  \n    smoker             region             charges         obese          \n Length:1338        Length:1338        Min.   : 1122   Length:1338       \n Class :character   Class :character   1st Qu.: 4740   Class :character  \n Mode  :character   Mode  :character   Median : 9382   Mode  :character  \n                                       Mean   :13270                     \n                                       3rd Qu.:16640                     \n                                       Max.   :63770                     \n\n\nWe can also apply individual statistical measures to a single column.\n\nmean(insurance$age)\n\n[1] 39.20703\n\n\nAnd even though the children variable/column is a numeric column, we may still be interested in the unique values or a table showing the distribution of the number of children per patient.\n\nunique(insurance$children)\n\n[1] 0 1 3 2 5 4\n\ntable(insurance$children)\n\n\n  0   1   2   3   4   5 \n574 324 240 157  25  18 \n\n\nWe may also be interested in seeing the distribution of a numeric variable graphically. The histogram hist() is probably the most common way of examining the distribution of a numeric variable.\n\nhist(insurance$charges)\n\n\n\n\n\n\n\nPlot the historgram of the other numeric variables.\nAnother approach is to use a boxplot.\n\nboxplot(insurance$age)",
    "crumbs": [
      "Exploring data",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Exploratory data analysis</span>"
    ]
  },
  {
    "objectID": "eda.html#relationships-between-variables",
    "href": "eda.html#relationships-between-variables",
    "title": "\n6  Exploratory data analysis\n",
    "section": "\n6.4 Relationships between variables",
    "text": "6.4 Relationships between variables\nWe can also start to look at the relationships between variables. Let’s start with the relationship between age and charges.\n\nplot(insurance$age, insurance$charges)\n\n\n\n\n\n\n\nWhat do you see in the plot?\nHow about the relathionship between bmi and charges?\n\nplot(insurance$bmi, insurance$charges)\n\n\n\n\n\n\n\nWhat do you see in this plot?\n\n6.4.1 Categorical vs. categorical\nWe can also look at the relationships between categorical variables. One way to do this is to use a contingency table.\n\ntable(insurance$sex, insurance$smoker)\n\n        \n          no yes\n  female 547 115\n  male   517 159\n\n\nWhat do you see in this table? Is this a useful way to look at the data?\nAnother way to look at the relationship between two categorical variables is to use a mosaic plot. What is a mosaic plot? A mosaic plot is a special type of stacked bar chart that shows percentages of data in groups. The plot is a graphical representation of a contingency table. How are mosaic plots used? Mosaic plots are used to show relationships and to provide a visual comparison of groups.\n\nmosaicplot(~ sex + smoker, data = insurance)\n\n\n\n\n\n\n\nWhat do you see in this plot?\n\n\n\n\n\n\nThe formula interface\n\n\n\nThe ~ symbol is used to specify the formula interface in R. The formula interface is used in many R functions to specify the relationship between variables. In this case, we are specifying that we want to look at the relationship between sex and smoker in the insurance dataset.\nIn other uses, the formula interface is used to specify the relationship between the dependent and independent variables in a regression model. For example, y ~ x specifies that y is the dependent variable and x is the independent variable.\n\n\n\n6.4.2 Categorical vs. numeric\nWe can also look at the relationship between a categorical and a numeric variable. One way to do this is to use a boxplot.\n\nboxplot(charges ~ smoker, data = insurance)\n\n\n\n\n\n\n\nWhat do you see in this plot?\nAnother way to look at the relationship between a categorical and a numeric variable is to use a violin plot. What is a violin plot? A violin plot is a method of plotting numeric data and can be considered a combination of the box plot and the kernel density plot.\nThis is our first introduction to the ggplot2 package. The ggplot2 package is a plotting system for R, based on the grammar of graphics. It is a powerful and flexible package that allows you to create complex plots with relatively little code.\n\nlibrary(ggplot2)\nggplot(insurance, aes(x = smoker, y = charges)) +\n    geom_violin()\n\n\n\n\n\n\n\nWe’ll be using ggplot2 a lot in the future, so this is just a “hello world” example.",
    "crumbs": [
      "Exploring data",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Exploratory data analysis</span>"
    ]
  },
  {
    "objectID": "ggplot.html",
    "href": "ggplot.html",
    "title": "\n7  Plotting with ggplot2\n",
    "section": "",
    "text": "7.1 Data\nThe first step in creating a ggplot2 plot is to specify the data to be visualized. The data should be in a tidy format (Wickham (2014)), with each row representing an observation and each column representing a variable. The insurance dataset is described in the book Machine Learning with R by Brett Lantz. The dataset describes medical information and costs billed by health insurance companies for 1338 individuals in 2013, as compiled by the United States Census Bureau.\nVariables include:\nWe will load the data directly from the web, but you can also download the data from the link at github1.\ninsurance_url &lt;- \"https://raw.githubusercontent.com/stedy/Machine-Learning-with-R-datasets/master/insurance.csv\"\ninsurance &lt;- read.csv(insurance_url)\nExplore the dataset a bit to understand its structure and contents. For example, you can use the head() function to view the first few rows of the dataset.\nhead(insurance)\n\n  age    sex    bmi children smoker    region   charges\n1  19 female 27.900        0    yes southwest 16884.924\n2  18   male 33.770        1     no southeast  1725.552\n3  28   male 33.000        3     no southeast  4449.462\n4  33   male 22.705        0     no northwest 21984.471\n5  32   male 28.880        0     no northwest  3866.855\n6  31 female 25.740        0     no southeast  3756.622\nAnd you can examine the dimensions of the dataset using the dim(), which returns the number of rows and columns in the dataset, the ncol() function, which returns the number of columns, and the nrow() function, which returns the number of rows.\ndim(insurance)\n\n[1] 1338    7\n\nncol(insurance)\n\n[1] 7\n\nnrow(insurance)\n\n[1] 1338\nNote that with the dim() function, the number of rows is given first, followed by the number of columns.\nNotice that, while the BMI variable represents a measure of a person’s weight relative to their height, there is no discrete variable for whether a person is obese or not. The World Health Organization (WHO) defines obesity as a BMI greater than or equal to 30. We can create a new variable, obese, that indicates whether a person is obese based on their BMI.\ninsurance$obese &lt;- ifelse(insurance$bmi &gt;= 30, \"obese\", \"not obese\")\nIf we examine the dataset again, we can see that the new variable obese has been added to the dataset.\nhead(insurance)\n\n  age    sex    bmi children smoker    region   charges     obese\n1  19 female 27.900        0    yes southwest 16884.924 not obese\n2  18   male 33.770        1     no southeast  1725.552     obese\n3  28   male 33.000        3     no southeast  4449.462     obese\n4  33   male 22.705        0     no northwest 21984.471 not obese\n5  32   male 28.880        0     no northwest  3866.855 not obese\n6  31 female 25.740        0     no southeast  3756.622 not obese",
    "crumbs": [
      "Exploring data",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Plotting with ggplot2</span>"
    ]
  },
  {
    "objectID": "ggplot.html#data",
    "href": "ggplot.html#data",
    "title": "\n7  Plotting with ggplot2\n",
    "section": "",
    "text": "age\n\nage of primary beneficiary\n\n\n\nsex\n\ninsurance contractor gender, female, male\n\n\n\nbmi\n\nBody mass index, providing an understanding of body, weights that are relatively high or low relative to height, objective index of body weight (kg / m ^ 2) using the ratio of height to weight, ideally 18.5 to 24.9\n\n\n\nchildren\n\nNumber of children covered by health insurance / Number of dependents\n\n\n\nsmoker\n\nSmoking status\n\n\n\nregion\n\nthe beneficiary’s residential area in the US, northeast, southeast, southwest, northwest.\n\n\n\ncharges\n\nIndividual medical costs billed by health insurance\n\n\n\n\n1 Insurance data csv file, https://raw.githubusercontent.com/stedy/Machine-Learning-with-R-datasets/master/insurance.csv",
    "crumbs": [
      "Exploring data",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Plotting with ggplot2</span>"
    ]
  },
  {
    "objectID": "ggplot.html#aesthetics",
    "href": "ggplot.html#aesthetics",
    "title": "\n7  Plotting with ggplot2\n",
    "section": "\n7.2 Aesthetics",
    "text": "7.2 Aesthetics\nThe next step in creating a ggplot2 plot is to specify the aesthetics of the plot. Aesthetics are visual properties of the plot that map data to visual elements.\n\n# specify dataset and mapping\nlibrary(ggplot2)\nggplot(\n    data = insurance,\n    mapping = aes(x = age, y = charges)\n)\n\n\n\n\n\n\nFigure 7.2: A plot with age on the x-axis and charges on the y-axis.\n\n\n\n\nIn the code above, the data are the data to be visualized, and the mapping specifies how the data should be mapped to the plot. In this case, the x aesthetic is mapped to the age variable, and the y aesthetic is mapped to the charges variable. Note that there are no data displayed in Figure 7.2 yet; we have only specified the data and aesthetics. However, you can see the structure of the plot in the output, which shows the data and aesthetics that have been specified with age on the x-axis and charges on the y-axis.",
    "crumbs": [
      "Exploring data",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Plotting with ggplot2</span>"
    ]
  },
  {
    "objectID": "ggplot.html#geometries",
    "href": "ggplot.html#geometries",
    "title": "\n7  Plotting with ggplot2\n",
    "section": "\n7.3 Geometries",
    "text": "7.3 Geometries\nThe next step is to add a geometry to the plot. Geometries are the visual representations of the data, such as points, lines, or bars. Since this is a scatter plot, we will use the geom_point() function to add points to the plot.\n\n# add points to the plot\nggplot(\n    data = insurance,\n    mapping = aes(x = age, y = charges)\n) +\n    geom_point()\n\n\n\n\n\n\nFigure 7.3: A scatter plot with age on the x-axis and charges on the y-axis results from adding geom_point() to the plot.\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nWhen using ggplot2, the + operator is used to add layers to the plot. The ggplot() function specifies the data and aesthetics, and the geom_point() function adds points to the plot. Using the + operator is a common practice in ggplot2 to add layers to a plot, but the + operator does not work for other types of plots in R.\n\n\nUsing other geometries, you can create different types of plots. For example, you can use geom_line() to create a line plot, geom_bar() to create a bar plot, or geom_boxplot() to create a box plot. Before doing so here, ask yourself if those geometries would be appropriate for the data you are working with.\nA number of parameters (options) can be specified in a geom_ function. Options for the geom_point() function include color, size, and alpha. These control the point color, size, and transparency, respectively. Transparency ranges from 0 (completely transparent) to 1 (completely opaque). Adding a degree of transparency can help visualize overlapping points such as in Figure 7.4.\n\n# add points to the plot\nggplot(\n    data = insurance,\n    mapping = aes(x = age, y = charges)\n) +\n    geom_point(\n        color = \"blue\",\n        size = 3,\n        alpha = 0.3\n    )\n\n\n\n\n\n\nFigure 7.4: A scatter plot with age on the x-axis and charges on the y-axis with colored points, larger size, and transparency.\n\n\n\n\nWe can add a best fit line to the scatter plot using the geom_smooth() function. The method parameter specifies the method used to fit the line. In this case, we will use the default method, which is linear regression, specified by method = \"lm\". The lm method fits a linear model to the data, which in this case is simple linear regression 2 of the dependent variable charges as a function of the independent variable age. The result is shown in Figure 7.5.\n2 The linear regression model is of the form \\(charges = \\alpha +  \\beta * age + \\epsilon\\) where \\(\\alpha\\) is the intercept, \\(\\beta\\) is the slope, and \\(\\epsilon\\) is the “error”.\n# add points and a best fit line to the plot\nggplot(\n    data = insurance,\n    mapping = aes(x = age, y = charges)\n) +\n    geom_point(\n        color = \"blue\",\n        alpha = 0.3\n    ) +\n    geom_smooth(method = \"lm\")\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\nFigure 7.5: A scatter plot with age on the x-axis and charges on the y-axis with a best fit line.\n\n\n\n\nWhat do you observe in Figure 7.5 with the best fit line? How well does the line fit the data? Do you think a linear model is appropriate for this data?",
    "crumbs": [
      "Exploring data",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Plotting with ggplot2</span>"
    ]
  },
  {
    "objectID": "ggplot.html#grouping",
    "href": "ggplot.html#grouping",
    "title": "\n7  Plotting with ggplot2\n",
    "section": "\n7.4 Grouping",
    "text": "7.4 Grouping\nIn addition to mapping variables to the x and y axes [i.e., aes(x = ..., y=...)], variables can be mapped to the color, shape, size, transparency, and other visual characteristics of geometric objects. This allows groups of observations to be superimposed in a single graph.\nFor example, we can map the smoker variable to the color of the points in the scatter plot. The result is shown in Figure 7.6.\n\n# add points to the plot, colored by the smoker variable\nggplot(\n    data = insurance,\n    mapping = aes(x = age, y = charges, color = smoker)\n) +\n    geom_point()\n\n\n\n\n\n\nFigure 7.6: A scatter plot with age on the x-axis and charges on the y-axis with points colored by the smoker variable.\n\n\n\n\nIn Figure 7.6, the points are colored based on the smoker variable, with smokers in orange and non-smokers in blue. This allows us to visually compare the charges of smokers and non-smokers as a function of age.\nIf we add back in the best fit line, we can see how the relationship between age and charges differs between smokers and non-smokers. The result is shown in Figure 7.7.\n\n# add points to the plot, colored by the smoker variable, and a best fit line\nggplot(\n    data = insurance,\n    mapping = aes(x = age, y = charges, color = smoker)\n) +\n    geom_point() +\n    geom_smooth(method = \"lm\")\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\nFigure 7.7: A scatter plot with age on the x-axis and charges on the y-axis with points colored by the smoker variable and a best fit line.\n\n\n\n\nHow well does the best fit line fit the data for smokers and non-smokers? Do you see any differences in the relationship between age and charges for smokers and non-smokers?",
    "crumbs": [
      "Exploring data",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Plotting with ggplot2</span>"
    ]
  },
  {
    "objectID": "ggplot.html#facets",
    "href": "ggplot.html#facets",
    "title": "\n7  Plotting with ggplot2\n",
    "section": "\n7.5 Facets",
    "text": "7.5 Facets\nFacets are a way to create multiple plots based on the levels of a categorical variable. In other words, facets allow you to create a grid of plots, with each plot showing a different subset of the data based on the levels of a categorical variable.\nIn Figure 7.7, we noticed that there are still two groups of points, even when looking at just smokers. We can further separate the data by the obese variable, creating a grid of plots with one plot for each combination of smoker and obese status.\n\n# add points to the plot, colored by the smoker variable, and faceted by the obese variable\nggplot(\n    data = insurance,\n    mapping = aes(x = age, y = charges, color = smoker)\n) +\n    geom_point() +\n    geom_smooth(method = \"lm\") +\n    facet_wrap(~obese)\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\nFigure 7.8: A grid of scatter plots with age on the x-axis and charges on the y-axis, colored by the smoker variable, and faceted by the obese variable.\n\n\n\n\nThe way that we interpret the facet_wrap(~ obese) command is that we want to create a grid of plots, with each plot showing a different subset of the data based on the levels of the obese variable. In this case, we have two levels of the obese variable: obese and not obese, so we get two plots in the grid.",
    "crumbs": [
      "Exploring data",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Plotting with ggplot2</span>"
    ]
  },
  {
    "objectID": "ggplot.html#labels",
    "href": "ggplot.html#labels",
    "title": "\n7  Plotting with ggplot2\n",
    "section": "\n7.6 Labels",
    "text": "7.6 Labels\nLabels are an important part of any plot. They help the viewer understand what the plot is showing and what the axes represent. While our plot already has labels for the x and y axes, we can add a title to the plot and change the labels for the x and y axes to make them more descriptive.\n\n# add points to the plot, colored by the smoker variable, faceted by the obese variable, and add labels\nggplot(\n    data = insurance,\n    mapping = aes(x = age, y = charges, color = smoker)\n) +\n    geom_point() +\n    geom_smooth(method = \"lm\") +\n    facet_wrap(~obese) +\n    labs(\n        title = \"Medical Charges as a function of patient characteristics\",\n        subtitle = \"US Census Bureau 2013 data\",\n        caption = \"Source: https://github.com/stedy/Machine-Learning-with-R-datasets\",\n        x = \"Age\",\n        y = \"Annual Medical Charges\",\n        color = \"Smoker?\"\n    )\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\nFigure 7.9: A scatter plot with age on the x-axis and charges on the y-axis, colored by the smoker variable, and faceted by the obese variable, with labels.",
    "crumbs": [
      "Exploring data",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Plotting with ggplot2</span>"
    ]
  },
  {
    "objectID": "ggplot.html#themes",
    "href": "ggplot.html#themes",
    "title": "\n7  Plotting with ggplot2\n",
    "section": "\n7.7 Themes",
    "text": "7.7 Themes\nThemes are a way to control the non-data ink in a plot, such as the background color, grid lines, and text size. Rather than specifying each element individually, you can use a pre-defined theme to quickly style your plot. For a nice overview of themes in ggplot2, see the the ggplot2 themes gallery.\nTo create a more visually appealing plot, we can apply the theme_minimal() theme to our plot. This theme removes the background grid lines and adds a light gray background to the plot.\n\n# add points to the plot, colored by the smoker variable, faceted by the obese variable, add labels, and apply a minimal theme\nggplot(\n    data = insurance,\n    mapping = aes(x = age, y = charges, color = smoker)\n) +\n    geom_point() +\n    geom_smooth(method = \"lm\") +\n    facet_wrap(~obese) +\n    labs(\n        title = \"Medical Charges as a function of patient characteristics\",\n        subtitle = \"US Census Bureau 2013 data\",\n        caption = \"Source: https://github.com/stedy/Machine-Learning-with-R-datasets\",\n        x = \"Age\",\n        y = \"Annual Medical Charges\",\n        color = \"Smoker?\"\n    ) +\n    theme_minimal()\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\nFigure 7.10: A scatter plot with age on the x-axis and charges on the y-axis, colored by the smoker variable, faceted by the obese variable, with labels and a minimal theme.",
    "crumbs": [
      "Exploring data",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Plotting with ggplot2</span>"
    ]
  },
  {
    "objectID": "ggplot.html#saving-a-plot",
    "href": "ggplot.html#saving-a-plot",
    "title": "\n7  Plotting with ggplot2\n",
    "section": "\n7.8 Saving a Plot",
    "text": "7.8 Saving a Plot\nOnce you have created a plot that you are happy with, you may want to save it to a file for use in a report or presentation. The ggsave() function in ggplot2 allows you to save a plot to a file in a variety of formats, including PNG, PDF, and SVG. Take a look at the help for ggsave() to see the available options. In particular, you can specify the file name, width, height, and resolution of the saved plot.\n\n# save the plot to a file\nggsave(\"insurance_plot.png\")\n\nSaving 7 x 5 in image\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\nNote\n\n\n\nThe ggsave() function saves the last plot that you created with ggplot2. ggsave() will save the plot to the working directory by default, but you can specify a different directory by providing the full path to the file name.",
    "crumbs": [
      "Exploring data",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Plotting with ggplot2</span>"
    ]
  },
  {
    "objectID": "ggplot.html#references",
    "href": "ggplot.html#references",
    "title": "\n7  Plotting with ggplot2\n",
    "section": "References",
    "text": "References\n\n\nCaron, Stéphane. 2018. “The Grammar of Graphics.” https://dotlayer.org/en/grammar-of-graphics/.\n\n\nCenter, Pew Research. 2016. “Lifelong Learning and\nTechnology.” Pew Research Center: Internet,\nScience & Tech. https://www.pewresearch.org/internet/2016/03/22/lifelong-learning-and-technology/.\n\n\nKnowles, Malcolm S., Elwood F. Holton, and Richard A. Swanson. 2005.\nThe Adult Learner: The Definitive Classic in Adult Education and\nHuman Resource Development. 6th ed. Amsterdam ; Boston: Elsevier.\n\n\nWickham, Hadley. 2014. “Tidy Data.” Journal of\nStatistical Software, Articles 59 (10): 1–23. https://doi.org/10.18637/jss.v059.i10.",
    "crumbs": [
      "Exploring data",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Plotting with ggplot2</span>"
    ]
  },
  {
    "objectID": "vectors.html",
    "href": "vectors.html",
    "title": "\n8  Vectors\n",
    "section": "",
    "text": "8.1 What is a Vector?\nA vector is the simplest and most basic data structure in R. It is a one-dimensional, ordered collection of elements, where all the elements are of the same data type. Vectors can store various types of data, such as numeric, character, or logical values. Figure 8.1 shows a pictorial representation of three vector examples.\nIn this chapter, we will provide a comprehensive overview of vectors, including how to create, access, and manipulate them. We will also discuss some unique properties and rules associated with vectors, and explore their applications in data analysis tasks.\nIn R, even a single value is a vector with length=1.\nz = 1\nz\n\n[1] 1\n\nlength(z)\n\n[1] 1\nIn the code above, we “assigned” the value 1 to the variable named z. Typing z by itself is an “expression” that returns a result which is, in this case, the value that we just assigned. The length method takes an R object and returns the R length. There are numerous ways of asking R about what an object represents, and length is one of them.\nVectors can contain numbers, strings (character data), or logical values (TRUE and FALSE) or other “atomic” data types Table 8.1. Vectors cannot contain a mix of types! We will introduce another data structure, the R list for situations when we need to store a mix of base R data types.",
    "crumbs": [
      "R data structures",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Vectors</span>"
    ]
  },
  {
    "objectID": "vectors.html#what-is-a-vector",
    "href": "vectors.html#what-is-a-vector",
    "title": "\n8  Vectors\n",
    "section": "",
    "text": "Figure 8.1: “Pictorial representation of three vector examples. The first vector is a numeric vector. The second is a ‘logical’ vector. The third is a character vector. Vectors also have indices and, optionally, names.”\n\n\n\n\n\n\n\n\n\n\n\nData type\nStores\n\n\n\nnumeric\nfloating point numbers\n\n\ninteger\nintegers\n\n\ncomplex\ncomplex numbers\n\n\nfactor\ncategorical data\n\n\ncharacter\nstrings\n\n\nlogical\nTRUE or FALSE\n\n\nNA\nmissing\n\n\nNULL\nempty\n\n\nfunction\nfunction type\n\n\n\n\n\nTable 8.1: Atomic (simplest) data types in R.",
    "crumbs": [
      "R data structures",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Vectors</span>"
    ]
  },
  {
    "objectID": "vectors.html#creating-vectors",
    "href": "vectors.html#creating-vectors",
    "title": "\n8  Vectors\n",
    "section": "\n8.2 Creating vectors",
    "text": "8.2 Creating vectors\nCharacter vectors (also sometimes called “string” vectors) are entered with each value surrounded by single or double quotes; either is acceptable, but they must match. They are always displayed by R with double quotes. Here are some examples of creating vectors:\n\n# examples of vectors\nc('hello','world')\n\n[1] \"hello\" \"world\"\n\nc(1,3,4,5,1,2)\n\n[1] 1 3 4 5 1 2\n\nc(1.12341e7,78234.126)\n\n[1] 11234100.00    78234.13\n\nc(TRUE,FALSE,TRUE,TRUE)\n\n[1]  TRUE FALSE  TRUE  TRUE\n\n# note how in the next case the TRUE is converted to \"TRUE\"\n# with quotes around it.\nc(TRUE,'hello')\n\n[1] \"TRUE\"  \"hello\"\n\n\nWe can also create vectors as “regular sequences” of numbers. For example:\n\n# create a vector of integers from 1 to 10\nx = 1:10\n# and backwards\nx = 10:1\n\nThe seq function can create more flexible regular sequences.\n\n# create a vector of numbers from 1 to 4 skipping by 0.3\ny = seq(1,4,0.3)\n\nAnd creating a new vector by concatenating existing vectors is possible, as well.\n\n# create a sequence by concatenating two other sequences\nz = c(y,x)\nz\n\n [1]  1.0  1.3  1.6  1.9  2.2  2.5  2.8  3.1  3.4  3.7  4.0 10.0  9.0  8.0  7.0\n[16]  6.0  5.0  4.0  3.0  2.0  1.0",
    "crumbs": [
      "R data structures",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Vectors</span>"
    ]
  },
  {
    "objectID": "vectors.html#vector-operations",
    "href": "vectors.html#vector-operations",
    "title": "\n8  Vectors\n",
    "section": "\n8.3 Vector Operations",
    "text": "8.3 Vector Operations\nOperations on a single vector are typically done element-by-element. For example, we can add 2 to a vector, 2 is added to each element of the vector and a new vector of the same length is returned.\n\nx = 1:10\nx + 2\n\n [1]  3  4  5  6  7  8  9 10 11 12\n\n\nIf the operation involves two vectors, the following rules apply. If the vectors are the same length: R simply applies the operation to each pair of elements.\n\nx + x\n\n [1]  2  4  6  8 10 12 14 16 18 20\n\n\nIf the vectors are different lengths, but one length a multiple of the other, R reuses the shorter vector as needed.\n\nx = 1:10\ny = c(1,2)\nx * y\n\n [1]  1  4  3  8  5 12  7 16  9 20\n\n\nIf the vectors are different lengths, but one length not a multiple of the other, R reuses the shorter vector as needed and delivers a warning.\n\nx = 1:10\ny = c(2,3,4)\nx * y\n\nWarning in x * y: longer object length is not a multiple of shorter object\nlength\n\n\n [1]  2  6 12  8 15 24 14 24 36 20\n\n\nTypical operations include multiplication (“*”), addition, subtraction, division, exponentiation (“^”), but many operations in R operate on vectors and are then called “vectorized”.\nBe aware of the recycling rule when working with vectors of different lengths, as it may lead to unexpected results if you’re not careful.",
    "crumbs": [
      "R data structures",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Vectors</span>"
    ]
  },
  {
    "objectID": "vectors.html#logical-vectors",
    "href": "vectors.html#logical-vectors",
    "title": "\n8  Vectors\n",
    "section": "\n8.4 Logical Vectors",
    "text": "8.4 Logical Vectors\nLogical vectors are vectors composed on only the values TRUE and FALSE. Note the all-upper-case and no quotation marks.\n\na = c(TRUE,FALSE,TRUE)\n\n# we can also create a logical vector from a numeric vector\n# 0 = false, everything else is 1\nb = c(1,0,217)\nd = as.logical(b)\nd\n\n[1]  TRUE FALSE  TRUE\n\n# test if a and d are the same at every element\nall.equal(a,d)\n\n[1] TRUE\n\n# We can also convert from logical to numeric\nas.numeric(a)\n\n[1] 1 0 1\n\n\n\n8.4.1 Logical Operators\nSome operators like &lt;, &gt;, ==, &gt;=, &lt;=, != can be used to create logical vectors.\n\n# create a numeric vector\nx = 1:10\n# testing whether x &gt; 5 creates a logical vector\nx &gt; 5\n\n [1] FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE\n\nx &lt;= 5\n\n [1]  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE\n\nx != 5\n\n [1]  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE\n\nx == 5\n\n [1] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE\n\n\nWe can also assign the results to a variable:\n\ny = (x == 5)\ny\n\n [1] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE",
    "crumbs": [
      "R data structures",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Vectors</span>"
    ]
  },
  {
    "objectID": "vectors.html#indexing-vectors",
    "href": "vectors.html#indexing-vectors",
    "title": "\n8  Vectors\n",
    "section": "\n8.5 Indexing Vectors",
    "text": "8.5 Indexing Vectors\nIn R, an index is used to refer to a specific element or set of elements in an vector (or other data structure). [R uses [ and ] to perform indexing, although other approaches to getting subsets of larger data structures are common in R.\n\nx = seq(0,1,0.1)\n# create a new vector from the 4th element of x\nx[4]\n\n[1] 0.3\n\n\nWe can even use other vectors to perform the “indexing”.\n\nx[c(3,5,6)]\n\n[1] 0.2 0.4 0.5\n\ny = 3:6\nx[y]\n\n[1] 0.2 0.3 0.4 0.5\n\n\nCombining the concept of indexing with the concept of logical vectors results in a very power combination.\n\n# use help('rnorm') to figure out what is happening next\nmyvec = rnorm(10)\n\n# create logical vector that is TRUE where myvec is &gt;0.25\ngt1 = (myvec &gt; 0.25)\nsum(gt1)\n\n[1] 3\n\n# and use our logical vector to create a vector of myvec values that are &gt;0.25\nmyvec[gt1]\n\n[1] 1.5585511 0.9283030 0.8883716\n\n# or &lt;=0.25 using the logical \"not\" operator, \"!\"\nmyvec[!gt1]\n\n[1] -1.2038367 -1.6330208 -1.0636007 -0.6771796 -0.3581292 -1.2560844 -0.3534214\n\n# shorter, one line approach\nmyvec[myvec &gt; 0.25]\n\n[1] 1.5585511 0.9283030 0.8883716",
    "crumbs": [
      "R data structures",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Vectors</span>"
    ]
  },
  {
    "objectID": "vectors.html#named-vectors",
    "href": "vectors.html#named-vectors",
    "title": "\n8  Vectors\n",
    "section": "\n8.6 Named Vectors",
    "text": "8.6 Named Vectors\nNamed vectors are vectors with labels or names assigned to their elements. These names can be used to access and manipulate the elements in a more meaningful way.\nTo create a named vector, use the names() function:\n\nfruit_prices &lt;- c(0.5, 0.75, 1.25)\nnames(fruit_prices) &lt;- c(\"apple\", \"banana\", \"cherry\")\nprint(fruit_prices)\n\n apple banana cherry \n  0.50   0.75   1.25 \n\n\nYou can also access and modify elements using their names:\n\nbanana_price &lt;- fruit_prices[\"banana\"]\nprint(banana_price)\n\nbanana \n  0.75 \n\nfruit_prices[\"apple\"] &lt;- 0.6\nprint(fruit_prices)\n\n apple banana cherry \n  0.60   0.75   1.25",
    "crumbs": [
      "R data structures",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Vectors</span>"
    ]
  },
  {
    "objectID": "vectors.html#character-vectors-a.k.a.-strings",
    "href": "vectors.html#character-vectors-a.k.a.-strings",
    "title": "\n8  Vectors\n",
    "section": "\n8.7 Character Vectors, A.K.A. Strings",
    "text": "8.7 Character Vectors, A.K.A. Strings\nR uses the paste function to concatenate strings.\n\npaste(\"abc\",\"def\")\n\n[1] \"abc def\"\n\npaste(\"abc\",\"def\",sep=\"THISSEP\")\n\n[1] \"abcTHISSEPdef\"\n\npaste0(\"abc\",\"def\")\n\n[1] \"abcdef\"\n\n## [1] \"abcdef\"\npaste(c(\"X\",\"Y\"),1:10)\n\n [1] \"X 1\"  \"Y 2\"  \"X 3\"  \"Y 4\"  \"X 5\"  \"Y 6\"  \"X 7\"  \"Y 8\"  \"X 9\"  \"Y 10\"\n\npaste(c(\"X\",\"Y\"),1:10,sep=\"_\")\n\n [1] \"X_1\"  \"Y_2\"  \"X_3\"  \"Y_4\"  \"X_5\"  \"Y_6\"  \"X_7\"  \"Y_8\"  \"X_9\"  \"Y_10\"\n\n\nWe can count the number of characters in a string.\n\nnchar('abc')\n\n[1] 3\n\nnchar(c('abc','d',123456))\n\n[1] 3 1 6\n\n\nPulling out parts of strings is also sometimes useful.\n\nsubstr('This is a good sentence.',start=10,stop=15)\n\n[1] \" good \"\n\n\nAnother common operation is to replace something in a string with something (a find-and-replace).\n\nsub('This','That','This is a good sentence.')\n\n[1] \"That is a good sentence.\"\n\n\nWhen we want to find all strings that match some other string, we can use grep, or “grab regular expression”.\n\ngrep('bcd',c('abcdef','abcd','bcde','cdef','defg'))\n\n[1] 1 2 3\n\ngrep('bcd',c('abcdef','abcd','bcde','cdef','defg'),value=TRUE)\n\n[1] \"abcdef\" \"abcd\"   \"bcde\"  \n\n\nRead about the grepl function (?grepl). Use that function to return a logical vector (TRUE/FALSE) for each entry above with an a in it.",
    "crumbs": [
      "R data structures",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Vectors</span>"
    ]
  },
  {
    "objectID": "vectors.html#missing-values-aka-na",
    "href": "vectors.html#missing-values-aka-na",
    "title": "\n8  Vectors\n",
    "section": "\n8.8 Missing Values, AKA “NA”",
    "text": "8.8 Missing Values, AKA “NA”\nR has a special value, “NA”, that represents a “missing” value, or Not Available, in a vector or other data structure. Here, we just create a vector to experiment.\n\nx = 1:5\nx\n\n[1] 1 2 3 4 5\n\nlength(x)\n\n[1] 5\n\n\n\nis.na(x)\n\n[1] FALSE FALSE FALSE FALSE FALSE\n\nx[2] = NA\nx\n\n[1]  1 NA  3  4  5\n\n\nThe length of x is unchanged, but there is one value that is marked as “missing” by virtue of being NA.\n\nlength(x)\n\n[1] 5\n\nis.na(x)\n\n[1] FALSE  TRUE FALSE FALSE FALSE\n\n\nWe can remove NA values by using indexing. In the following, is.na(x) returns a logical vector the length of x. The ! is the logical NOT operator and converts TRUE to FALSE and vice-versa.\n\nx[!is.na(x)]\n\n[1] 1 3 4 5",
    "crumbs": [
      "R data structures",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Vectors</span>"
    ]
  },
  {
    "objectID": "vectors.html#exercises",
    "href": "vectors.html#exercises",
    "title": "\n8  Vectors\n",
    "section": "\n8.9 Exercises",
    "text": "8.9 Exercises\n\n\nCreate a numeric vector called temperatures containing the following values: 72, 75, 78, 81, 76, 73.\n\nShow answertemperatures &lt;- c(72, 75, 78, 81, 76, 73, 93)\n\n\n\n\nCreate a character vector called days containing the following values: “Monday”, “Tuesday”, “Wednesday”, “Thursday”, “Friday”, “Saturday”, “Sunday”.\n\nShow answerdays &lt;- c(\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\")\n\n\n\n\nCalculate the average temperature for the week and store it in a variable called average_temperature.\n\nShow answeraverage_temperature &lt;- mean(temperatures)\n\n\n\n\nCreate a named vector called weekly_temperatures, where the names are the days of the week and the values are the temperatures from the temperatures vector.\n\nShow answerweekly_temperatures &lt;- temperatures\nnames(weekly_temperatures) &lt;- days\n\n\n\n\nCreate a numeric vector called ages containing the following values: 25, 30, 35, 40, 45, 50, 55, 60.\n\nShow answerages &lt;- c(25, 30, 35, 40, 45, 50, 55, 60)\n\n\n\n\nCreate a logical vector called is_adult by checking if the elements in the ages vector are greater than or equal to 18.\n\nShow answeris_adult &lt;- ages &gt;= 18\n\n\n\n\nCalculate the sum and product of the ages vector.\n\nShow answersum_ages &lt;- sum(ages)\nproduct_ages &lt;- prod(ages)\n\n\n\n\nExtract the ages greater than or equal to 40 from the ages vector and store them in a variable called older_ages.\n\nShow answerolder_ages &lt;- ages[ages &gt;= 40]",
    "crumbs": [
      "R data structures",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Vectors</span>"
    ]
  },
  {
    "objectID": "matrices.html",
    "href": "matrices.html",
    "title": "\n9  Matrices\n",
    "section": "",
    "text": "9.1 Creating a matrix\nThere are many ways to create a matrix in R. One of the simplest is to use the matrix() function. In the code below, we’ll create a matrix from a vector from 1:16.\nmat1 &lt;- matrix(1:16,nrow=4)\nmat1\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    5    9   13\n[2,]    2    6   10   14\n[3,]    3    7   11   15\n[4,]    4    8   12   16\nThe same is possible, but specifying that the matrix be “filled” by row.\nmat1 &lt;- matrix(1:16,nrow=4,byrow = TRUE)\nmat1\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    2    3    4\n[2,]    5    6    7    8\n[3,]    9   10   11   12\n[4,]   13   14   15   16\nNotice the subtle difference in the order that the numbers go into the matrix.\nWe can also build a matrix from parts by “binding” vectors together:\nx &lt;- 1:10 \ny &lt;- rnorm(10)\nEach of the vectors above is of length 10 and both are “numeric”, so we can make them into a matrix. Using rbind binds rows (r) into a matrix.\nmat &lt;- rbind(x,y)\nmat\n\n      [,1]      [,2]     [,3]       [,4]     [,5]      [,6]      [,7]\nx  1.00000  2.000000 3.000000  4.0000000 5.000000 6.0000000 7.0000000\ny -1.37595 -0.673147 1.001059 -0.6951363 1.129463 0.4337584 0.3217394\n        [,8]      [,9]     [,10]\nx 8.00000000 9.0000000 10.000000\ny 0.01821573 0.4140505 -2.094936\nThe alternative to rbind is cbind that binds columns (c) together.\nmat &lt;- cbind(x,y)\nmat\n\n       x           y\n [1,]  1 -1.37594967\n [2,]  2 -0.67314703\n [3,]  3  1.00105860\n [4,]  4 -0.69513626\n [5,]  5  1.12946279\n [6,]  6  0.43375840\n [7,]  7  0.32173943\n [8,]  8  0.01821573\n [9,]  9  0.41405046\n[10,] 10 -2.09493607\nInspecting the names associated with rows and columns is often useful, particularly if the names have human meaning.\nrownames(mat)\n\nNULL\n\ncolnames(mat)\n\n[1] \"x\" \"y\"\nWe can also change the names of the matrix by assigning valid names to the columns or rows.\ncolnames(mat) = c('apples','oranges')\ncolnames(mat)\n\n[1] \"apples\"  \"oranges\"\n\nmat\n\n      apples     oranges\n [1,]      1 -1.37594967\n [2,]      2 -0.67314703\n [3,]      3  1.00105860\n [4,]      4 -0.69513626\n [5,]      5  1.12946279\n [6,]      6  0.43375840\n [7,]      7  0.32173943\n [8,]      8  0.01821573\n [9,]      9  0.41405046\n[10,]     10 -2.09493607\nMatrices have dimensions.\ndim(mat)\n\n[1] 10  2\n\nnrow(mat)\n\n[1] 10\n\nncol(mat)\n\n[1] 2",
    "crumbs": [
      "R data structures",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Matrices</span>"
    ]
  },
  {
    "objectID": "matrices.html#accessing-elements-of-a-matrix",
    "href": "matrices.html#accessing-elements-of-a-matrix",
    "title": "\n9  Matrices\n",
    "section": "\n9.2 Accessing elements of a matrix",
    "text": "9.2 Accessing elements of a matrix\nIndexing for matrices works as for vectors except that we now need to include both the row and column (in that order). We can access elements of a matrix using the square bracket [ indexing method. Elements can be accessed as var[r, c]. Here, r and c are vectors describing the elements of the matrix to select.\n\n\n\n\n\n\nImportant\n\n\n\nThe indices in R start with one, meaning that the first element of a vector or the first row/column of a matrix is indexed as one.\nThis is different from some other programming languages, such as Python, which use zero-based indexing, meaning that the first element of a vector or the first row/column of a matrix is indexed as zero.\nIt is important to be aware of this difference when working with data in R, especially if you are coming from a programming background that uses zero-based indexing. Using the wrong index can lead to unexpected results or errors in your code.\n\n\n\n# The 2nd element of the 1st row of mat\nmat[1,2]\n\n oranges \n-1.37595 \n\n# The first ROW of mat\nmat[1,]\n\n  apples  oranges \n 1.00000 -1.37595 \n\n# The first COLUMN of mat\nmat[,1]\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n# and all elements of mat that are &gt; 4; note no comma\nmat[mat&gt;4]\n\n[1]  5  6  7  8  9 10\n\n## [1]  5  6  7  8  9 10\n\n\n\n\n\n\n\nCaution\n\n\n\nNote that in the last case, there is no “,”, so R treats the matrix as a long vector (length=20). This is convenient, sometimes, but it can also be a source of error, as some code may “work” but be doing something unexpected.\n\n\nWe can also use indexing to exclude a row or column by prefixing the selection with a - sign.\n\nmat[,-1]       # remove first column\n\n [1] -1.37594967 -0.67314703  1.00105860 -0.69513626  1.12946279  0.43375840\n [7]  0.32173943  0.01821573  0.41405046 -2.09493607\n\nmat[-c(1:5),]  # remove first five rows\n\n     apples     oranges\n[1,]      6  0.43375840\n[2,]      7  0.32173943\n[3,]      8  0.01821573\n[4,]      9  0.41405046\n[5,]     10 -2.09493607",
    "crumbs": [
      "R data structures",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Matrices</span>"
    ]
  },
  {
    "objectID": "matrices.html#changing-values-in-a-matrix",
    "href": "matrices.html#changing-values-in-a-matrix",
    "title": "\n9  Matrices\n",
    "section": "\n9.3 Changing values in a matrix",
    "text": "9.3 Changing values in a matrix\nWe can create a matrix filled with random values drawn from a normal distribution for our work below.\n\nm = matrix(rnorm(20),nrow=10)\nsummary(m)\n\n       V1                   V2         \n Min.   :-2.8804047   Min.   :-1.4665  \n 1st Qu.:-0.3318684   1st Qu.:-1.1070  \n Median : 0.5758668   Median :-0.6853  \n Mean   :-0.0009426   Mean   :-0.6084  \n 3rd Qu.: 0.6836370   3rd Qu.:-0.3374  \n Max.   : 0.8764775   Max.   : 0.8011  \n\n\nMultiplication and division works similarly to vectors. When multiplying by a vector, for example, the values of the vector are reused. In the simplest case, let’s multiply the matrix by a constant (vector of length 1).\n\n# multiply all values in the matrix by 20\nm2 = m*20\nsummary(m2)\n\n       V1                  V2         \n Min.   :-57.60809   Min.   :-29.330  \n 1st Qu.: -6.63737   1st Qu.:-22.140  \n Median : 11.51734   Median :-13.706  \n Mean   : -0.01885   Mean   :-12.168  \n 3rd Qu.: 13.67274   3rd Qu.: -6.748  \n Max.   : 17.52955   Max.   : 16.022  \n\n\nBy combining subsetting with assignment, we can make changes to just part of a matrix.\n\n# and add 100 to the first column of m\nm2[,1] = m2[,1] + 100\n# summarize m\nsummary(m2)\n\n       V1               V2         \n Min.   : 42.39   Min.   :-29.330  \n 1st Qu.: 93.36   1st Qu.:-22.140  \n Median :111.52   Median :-13.706  \n Mean   : 99.98   Mean   :-12.168  \n 3rd Qu.:113.67   3rd Qu.: -6.748  \n Max.   :117.53   Max.   : 16.022  \n\n\nA somewhat common transformation for a matrix is to transpose which changes rows to columns. One might need to do this if an assay output from a lab machine puts samples in rows and genes in columns, for example, while in Bioconductor/R, we often want the samples in columns and the genes in rows.\n\nt(m2)\n\n           [,1]      [,2]       [,3]      [,4]     [,5]      [,6]     [,7]\n[1,] 113.921282 103.48302 112.321561 89.989171 115.6439 117.52955 112.9271\n[2,]  -7.343504 -15.60652   1.357473 -6.549433 -17.4937 -11.80519  16.0219\n          [,8]      [,9]     [,10]\n[1,] 110.71311  80.89083  42.39191\n[2,] -27.23953 -23.68840 -29.32969",
    "crumbs": [
      "R data structures",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Matrices</span>"
    ]
  },
  {
    "objectID": "matrices.html#calculations-on-matrix-rows-and-columns",
    "href": "matrices.html#calculations-on-matrix-rows-and-columns",
    "title": "\n9  Matrices\n",
    "section": "\n9.4 Calculations on matrix rows and columns",
    "text": "9.4 Calculations on matrix rows and columns\nAgain, we just need a matrix to play with. We’ll use rnorm again, but with a slight twist.\n\nm3 = matrix(rnorm(100,5,2),ncol=10) # what does the 5 mean here? And the 2?\n\nSince these data are from a normal distribution, we can look at a row (or column) to see what the mean and standard deviation are.\n\nmean(m3[,1])\n\n[1] 4.178876\n\nsd(m3[,1])\n\n[1] 1.625788\n\n# or a row\nmean(m3[1,])\n\n[1] 4.867812\n\nsd(m3[1,])\n\n[1] 2.029104\n\n\nThere are some useful convenience functions for computing means and sums of data in all of the columns and rows of matrices.\n\ncolMeans(m3)\n\n [1] 4.178876 4.485702 5.003931 5.338303 5.875298 4.868359 4.279324 5.601164\n [9] 4.572530 6.219823\n\nrowMeans(m3)\n\n [1] 4.867812 4.440548 4.490479 4.523367 5.478116 5.052268 5.881956 6.032062\n [9] 4.566772 5.089929\n\nrowSums(m3)\n\n [1] 48.67812 44.40548 44.90479 45.23367 54.78116 50.52268 58.81956 60.32062\n [9] 45.66772 50.89929\n\ncolSums(m3)\n\n [1] 41.78876 44.85702 50.03931 53.38303 58.75298 48.68359 42.79324 56.01164\n [9] 45.72530 62.19823\n\n\nWe can look at the distribution of column means:\n\n# save as a variable\ncmeans = colMeans(m3)\nsummary(cmeans)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  4.179   4.507   4.936   5.042   5.535   6.220 \n\n\nNote that this is centered pretty closely around the selected mean of 5 above.\nHow about the standard deviation? There is not a colSd function, but it turns out that we can easily apply functions that take vectors as input, like sd and “apply” them across either the rows (the first dimension) or columns (the second) dimension.\n\ncsds = apply(m3, 2, sd)\nsummary(csds)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n 0.9825  1.6536  1.9689  1.9548  2.2032  3.0449 \n\n\nAgain, take a look at the distribution which is centered quite close to the selected standard deviation when we created our matrix.",
    "crumbs": [
      "R data structures",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Matrices</span>"
    ]
  },
  {
    "objectID": "matrices.html#exercises",
    "href": "matrices.html#exercises",
    "title": "\n9  Matrices\n",
    "section": "\n9.5 Exercises",
    "text": "9.5 Exercises\n\n9.5.1 Data preparation\nFor this set of exercises, we are going to rely on a dataset that comes with R. It gives the number of sunspots per month from 1749-1983. The dataset comes as a ts or time series data type which I convert to a matrix using the following code.\nJust run the code as is and focus on the rest of the exercises.\n\ndata(sunspots)\nsunspot_mat &lt;- matrix(as.vector(sunspots),ncol=12,byrow = TRUE)\ncolnames(sunspot_mat) &lt;- as.character(1:12)\nrownames(sunspot_mat) &lt;- as.character(1749:1983)\n\n\n9.5.2 Questions\n\n\nAfter the conversion above, what does sunspot_mat look like? Use functions to find the number of rows, the number of columns, the class, and some basic summary statistics.\n\nShow answerncol(sunspot_mat)\nnrow(sunspot_mat)\ndim(sunspot_mat)\nsummary(sunspot_mat)\nhead(sunspot_mat)\ntail(sunspot_mat)\n\n\n\n\nPractice subsetting the matrix a bit by selecting:\n\nThe first 10 years (rows)\nThe month of July (7th column)\nThe value for July, 1979 using the rowname to do the selection.\n\n\nShow answersunspot_mat[1:10,]\nsunspot_mat[,7]\nsunspot_mat['1979',7]\n\n\n\n\n\n\nThese next few exercises take advantage of the fact that calling a univariate statistical function (one that expects a vector) works for matrices by just making a vector of all the values in the matrix. What is the highest (max) number of sunspots recorded in these data?\n\nShow answermax(sunspot_mat)\n\n\n\n\nAnd the minimum?\n\nShow answermin(sunspot_mat)\n\n\n\n\nAnd the overall mean and median?\n\nShow answermean(sunspot_mat)\nmedian(sunspot_mat)\n\n\n\n\nUse the hist() function to look at the distribution of all the monthly sunspot data.\n\nShow answerhist(sunspot_mat)\n\n\n\n\nRead about the breaks argument to hist() to try to increase the number of breaks in the histogram to increase the resolution slightly. Adjust your hist() and breaks to your liking.\n\nShow answerhist(sunspot_mat, breaks=40)\n\n\n\n\nNow, let’s move on to summarizing the data a bit to learn about the pattern of sunspots varies by month or by year. Examine the dataset again. What do the columns represent? And the rows?\n\nShow answer# just a quick glimpse of the data will give us a sense\nhead(sunspot_mat)\n\n\n\n\nWe’d like to look at the distribution of sunspots by month. How can we do that?\n\nShow answer# the mean of the columns is the mean number of sunspots per month.\ncolMeans(sunspot_mat)\n\n# Another way to write the same thing:\napply(sunspot_mat, 2, mean)\n\n\n\n\nAssign the month summary above to a variable and summarize it to get a sense of the spread over months.\n\nShow answermonthmeans = colMeans(sunspot_mat)\nsummary(monthmeans)\n\n\n\n\nPlay the same game for years to get the per-year mean?\n\nShow answerymeans = rowMeans(sunspot_mat)\nsummary(ymeans)\n\n\n\n\nMake a plot of the yearly means. Do you see a pattern?\n\nShow answerplot(ymeans)\n# or make it clearer\nplot(ymeans, type='l')",
    "crumbs": [
      "R data structures",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Matrices</span>"
    ]
  },
  {
    "objectID": "dataframes_intro.html",
    "href": "dataframes_intro.html",
    "title": "\n10  Data Frames\n",
    "section": "",
    "text": "10.1 Dataset\nThe insurance dataset is described in the book Machine Learning with R by Brett Lantz. The dataset describes medical information and costs billed by health insurance companies for 1338 individuals in 2013, as compiled by the United States Census Bureau.\nVariables include:\nWe will load the data directly from the web, but you can also download the data from the link at github1.\ninsurance_url &lt;- \"https://raw.githubusercontent.com/stedy/Machine-Learning-with-R-datasets/master/insurance.csv\"\ninsurance &lt;- read.csv(insurance_url)\nExplore the dataset a bit to understand its structure and contents. For example, you can use the head() function to view the first few rows of the dataset.\nhead(insurance)\n\n  age    sex    bmi children smoker    region   charges\n1  19 female 27.900        0    yes southwest 16884.924\n2  18   male 33.770        1     no southeast  1725.552\n3  28   male 33.000        3     no southeast  4449.462\n4  33   male 22.705        0     no northwest 21984.471\n5  32   male 28.880        0     no northwest  3866.855\n6  31 female 25.740        0     no southeast  3756.622\nAnd you can examine the dimensions of the dataset using the dim(), which returns the number of rows and columns in the dataset, the ncol() function, which returns the number of columns, and the nrow() function, which returns the number of rows.\ndim(insurance)\n\n[1] 1338    7\n\nncol(insurance)\n\n[1] 7\n\nnrow(insurance)\n\n[1] 1338\nNote that with the dim() function, the number of rows is given first, followed by the number of columns.\nNotice that, while the BMI variable represents a measure of a person’s weight relative to their height, there is no discrete variable for whether a person is obese or not. The World Health Organization (WHO) defines obesity as a BMI greater than or equal to 30. We can create a new variable, obese, that indicates whether a person is obese based on their BMI.\ninsurance$obese &lt;- ifelse(insurance$bmi &gt;= 30, \"obese\", \"not obese\")\nIf we examine the dataset again, we can see that the new variable obese has been added to the dataset.\nhead(insurance)\n\n  age    sex    bmi children smoker    region   charges     obese\n1  19 female 27.900        0    yes southwest 16884.924 not obese\n2  18   male 33.770        1     no southeast  1725.552     obese\n3  28   male 33.000        3     no southeast  4449.462     obese\n4  33   male 22.705        0     no northwest 21984.471 not obese\n5  32   male 28.880        0     no northwest  3866.855 not obese\n6  31 female 25.740        0     no southeast  3756.622 not obese",
    "crumbs": [
      "R data structures",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Data Frames</span>"
    ]
  },
  {
    "objectID": "dataframes_intro.html#dataset",
    "href": "dataframes_intro.html#dataset",
    "title": "\n10  Data Frames\n",
    "section": "",
    "text": "age\n\nage of primary beneficiary\n\n\n\nsex\n\ninsurance contractor gender, female, male\n\n\n\nbmi\n\nBody mass index, providing an understanding of body, weights that are relatively high or low relative to height, objective index of body weight (kg / m ^ 2) using the ratio of height to weight, ideally 18.5 to 24.9\n\n\n\nchildren\n\nNumber of children covered by health insurance / Number of dependents\n\n\n\nsmoker\n\nSmoking status\n\n\n\nregion\n\nthe beneficiary’s residential area in the US, northeast, southeast, southwest, northwest.\n\n\n\ncharges\n\nIndividual medical costs billed by health insurance\n\n\n\n\n1 Insurance data csv file, https://raw.githubusercontent.com/stedy/Machine-Learning-with-R-datasets/master/insurance.csv",
    "crumbs": [
      "R data structures",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Data Frames</span>"
    ]
  },
  {
    "objectID": "dataframes_intro.html#inspecting-data.frames",
    "href": "dataframes_intro.html#inspecting-data.frames",
    "title": "\n10  Data Frames\n",
    "section": "\n10.2 Inspecting data.frames",
    "text": "10.2 Inspecting data.frames\nThere are a few functions that are useful for inspecting the contents of a data.frame:\n\nOverviews of content\n\n\nhead() to show first few rows\n\ntail() to show last few rows\n\n\nSize\n\n\ndim() for dimensions (rows, columns)\nnrow()\nncol()\n\nobject.size() for power users interested in the memory used to store an object\n\n\nData and attribute summaries\n\n\ncolnames() to get the names of the columns\n\nrownames() to get the “names” of the rows–may not be present\n\nsummary() to get per-column summaries of the data in the data.frame.\n\n\n\n\n# Show the first few rows\nhead(insurance)\n\n  age    sex    bmi children smoker    region   charges     obese\n1  19 female 27.900        0    yes southwest 16884.924 not obese\n2  18   male 33.770        1     no southeast  1725.552     obese\n3  28   male 33.000        3     no southeast  4449.462     obese\n4  33   male 22.705        0     no northwest 21984.471 not obese\n5  32   male 28.880        0     no northwest  3866.855 not obese\n6  31 female 25.740        0     no southeast  3756.622 not obese\n\n# Show the last few rows\ntail(insurance)\n\n     age    sex   bmi children smoker    region   charges     obese\n1333  52 female 44.70        3     no southwest 11411.685     obese\n1334  50   male 30.97        3     no northwest 10600.548     obese\n1335  18 female 31.92        0     no northeast  2205.981     obese\n1336  18 female 36.85        0     no southeast  1629.833     obese\n1337  21 female 25.80        0     no southwest  2007.945 not obese\n1338  61 female 29.07        0    yes northwest 29141.360 not obese\n\n# Get the dimensions of the data.frame\ndim(insurance)\n\n[1] 1338    8\n\n# Get the number of rows and columns\nnrow(insurance)\n\n[1] 1338\n\nncol(insurance)\n\n[1] 8\n\n# Get the names of the columns\ncolnames(insurance)\n\n[1] \"age\"      \"sex\"      \"bmi\"      \"children\" \"smoker\"   \"region\"   \"charges\" \n[8] \"obese\"   \n\n# Basic summary of the data\nsummary(insurance)\n\n      age            sex                 bmi           children    \n Min.   :18.00   Length:1338        Min.   :15.96   Min.   :0.000  \n 1st Qu.:27.00   Class :character   1st Qu.:26.30   1st Qu.:0.000  \n Median :39.00   Mode  :character   Median :30.40   Median :1.000  \n Mean   :39.21                      Mean   :30.66   Mean   :1.095  \n 3rd Qu.:51.00                      3rd Qu.:34.69   3rd Qu.:2.000  \n Max.   :64.00                      Max.   :53.13   Max.   :5.000  \n    smoker             region             charges         obese          \n Length:1338        Length:1338        Min.   : 1122   Length:1338       \n Class :character   Class :character   1st Qu.: 4740   Class :character  \n Mode  :character   Mode  :character   Median : 9382   Mode  :character  \n                                       Mean   :13270                     \n                                       3rd Qu.:16640                     \n                                       Max.   :63770                     \n\n\nIn RStudio, there is an additional function, View() (note the capital “V”) that opens the first 1000 rows (default) in the RStudio window, akin to a spreadsheet view.\n\nView(insurance)",
    "crumbs": [
      "R data structures",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Data Frames</span>"
    ]
  },
  {
    "objectID": "dataframes_intro.html#accessing-variables-columns-and-subsetting",
    "href": "dataframes_intro.html#accessing-variables-columns-and-subsetting",
    "title": "\n10  Data Frames\n",
    "section": "\n10.3 Accessing variables (columns) and subsetting",
    "text": "10.3 Accessing variables (columns) and subsetting\nIn R, data.frames can be subset similarly to other two-dimensional data structures. The [ in R is used to denote subsetting of any kind. When working with two-dimensional data, we need two values inside the [ ] to specify the details. The specification is [rows, columns]. For example, to get the first three rows of insurance, use:\n\ninsurance[1:3, ]\n\n  age    sex   bmi children smoker    region   charges     obese\n1  19 female 27.90        0    yes southwest 16884.924 not obese\n2  18   male 33.77        1     no southeast  1725.552     obese\n3  28   male 33.00        3     no southeast  4449.462     obese\n\n\nNote how the second number, the columns, is blank. R takes that to mean “all the columns”. Similarly, we can combine rows and columns specification arbitrarily.\n\ninsurance[1:3, 1:3]\n\n  age    sex   bmi\n1  19 female 27.90\n2  18   male 33.77\n3  28   male 33.00\n\n\nBecause selecting a single variable, or column, is such a common operation, there are two shortcuts for doing so with data.frames. The first, the $ operator works like so:\n\n# Look at the column names, just to refresh memory\ncolnames(insurance)\n\n[1] \"age\"      \"sex\"      \"bmi\"      \"children\" \"smoker\"   \"region\"   \"charges\" \n[8] \"obese\"   \n\n# Note that I am using \"head\" here to limit the output\nhead(insurance$age)\n\n[1] 19 18 28 33 32 31\n\n# What is the actual length of \"symbol\"?\nlength(insurance$age)\n\n[1] 1338\n\n\nThe second is related to the fact that, in R, data.frames are also lists. We subset a list by using [[]] notation. To get the second column of insurance, we can use:\n\nhead(insurance[[2]])\n\n[1] \"female\" \"male\"   \"male\"   \"male\"   \"male\"   \"female\"\n\n\nAlternatively, we can use the column name:\n\nhead(insurance[[\"age\"]])\n\n[1] 19 18 28 33 32 31\n\n\n\n10.3.1 Some data exploration\nThere are a couple of columns that include numeric values. Which columns are numeric?\n\nclass(insurance$age)\n\n[1] \"integer\"\n\nclass(insurance$obese)\n\n[1] \"character\"\n\nclass(insurance$children)\n\n[1] \"integer\"\n\n\n\nlibrary(gridExtra)\nlibrary(grid)\nlibrary(dplyr)\n\n\nAttaching package: 'dplyr'\n\n\nThe following object is masked from 'package:gridExtra':\n\n    combine\n\n\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n\n\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n\n# Original DataFrame\ndf &lt;- data.frame(\n    id = c(1, 2, 3, 4, 5),\n    name = c(\"Alice\", \"Bob\", \"Carol\", \"David\", \"Eve\"),\n    age = c(23, 25, 22, 24, 23),\n    score = c(88, 95, 78, 92, 85),\n    city = c(\"New York\", \"Chicago\", \"Boston\", \"Seattle\", \"Austin\")\n)\n\n# Filter\ndf_filtered &lt;- df %&gt;% filter(age &gt; 23)\n\n# Select\ndf_selected &lt;- df_filtered %&gt;% select(name, score)\n\n# Mutate\ndf_mutated &lt;- df_selected %&gt;% mutate(score_scaled = score / 100)\n\n# Arrange\ndf_arranged &lt;- df_mutated %&gt;% arrange(desc(score))\n\n# Summarize\ndf_grouped &lt;- df %&gt;%\n    group_by(city) %&gt;%\n    summarize(avg_score = mean(score))\n\n# Function to create table grobs\ncreate_table_grob &lt;- function(df, title) {\n    table_grob &lt;- tableGrob(df)\n    title_grob &lt;- textGrob(title, gp = gpar(fontsize = 16, fontface = \"bold\"))\n    padding &lt;- unit(0.5, \"line\")\n    table_grob &lt;- gtable::gtable_add_rows(table_grob, heights = grobHeight(title_grob) + padding, pos = 0)\n    table_grob &lt;- gtable::gtable_add_grob(table_grob, list(title_grob), 1, 1, 1, ncol(table_grob))\n    table_grob\n}\n\n# Creating table grobs\noriginal_grob &lt;- create_table_grob(df, \"Original DataFrame\")\nfiltered_grob &lt;- create_table_grob(df_filtered, \"Filtered (age &gt; 23)\")\nselected_grob &lt;- create_table_grob(df_selected, \"Selected (name, score)\")\nmutated_grob &lt;- create_table_grob(df_mutated, \"Mutated (score_scaled)\")\narranged_grob &lt;- create_table_grob(df_arranged, \"Arranged (by score)\")\nsummarized_grob &lt;- create_table_grob(df_grouped, \"Summarized (avg score by city)\")\n\n# Arrange tables in a grid\ngrid.arrange(\n    original_grob, filtered_grob,\n    selected_grob, mutated_grob,\n    arranged_grob, summarized_grob,\n    nrow = 6\n)",
    "crumbs": [
      "R data structures",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Data Frames</span>"
    ]
  },
  {
    "objectID": "310_microbiome.html",
    "href": "310_microbiome.html",
    "title": "\n11  Microbiome analysis\n",
    "section": "",
    "text": "11.1 Getting started\nWe’ll be using the mia package for microbiome analysis in R. The mia package provides a suite of tools for analyzing microbiome data, including functions for loading, processing, and visualizing microbiome data. The package is designed to work with the SummarizedExperiment and TreeSummarizedExperiment classes, which are specialized data structures for storing microbiome data in R.\nTo get started, you’ll need to install the mia package from GitHub using the BiocManager package. If you don’t already have the BiocManager package installed, you can install it using the following command:\n# Install the mia package\nBiocManager::install(\"microbiome/mia\")\nOnce the mia package is installed, you can load it into your R session using the following command:\n# Load the mia package\nlibrary(mia)\nNow that the mia package is loaded, we can load the microbiome dataset that we will be working with.",
    "crumbs": [
      "Applications",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Microbiome analysis</span>"
    ]
  },
  {
    "objectID": "310_microbiome.html#getting-started",
    "href": "310_microbiome.html#getting-started",
    "title": "\n11  Microbiome analysis\n",
    "section": "",
    "text": "Note\n\n\n\nNote: The mia package is part of the Bioconductor project, but in this case, we are installing it directly from GitHub using the microbiome/mia repository. This is a common practice when working with development versions of packages or with packages that are not yet available on Bioconductor.",
    "crumbs": [
      "Applications",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Microbiome analysis</span>"
    ]
  },
  {
    "objectID": "310_microbiome.html#accessing-micriobiome-datasets",
    "href": "310_microbiome.html#accessing-micriobiome-datasets",
    "title": "\n11  Microbiome analysis\n",
    "section": "\n11.2 Accessing micriobiome datasets",
    "text": "11.2 Accessing micriobiome datasets\nThere are many publicly available microbiome datasets that you can use for analysis. Bioconductor provides several packages that contain curated microbiome datasets that facilitate access to and loading microbiome data into R for analysis.\ncuratedMetagenomicData is a large collection of curated human microbiome datasets, provided as TreeSE objects (Pasolli et al. 2017). The resource provides curated human microbiome data including gene families, marker abundance, marker presence, pathway abundance, pathway coverage, and relative abundance for samples from different body sites. See the package homepage for more details on data availability and access.\nThe microbiomeDataSets package provides a collection of curated microbiome datasets for teaching and research purposes. The package contains several example datasets that can be used to explore different aspects of microbiome analysis, such as alpha and beta diversity, differential abundance analysis, and visualization.\nThe mia package and several other packages provide example datasets for learning and testing the functions in the package. These datasets are typically small and easy to work with, making them ideal for learning how to analyze microbiome data in R.\nThe MicroBioMap package provides a collection of 170,000 microbiome samples homogeneously processed. The package is designed to facilitate the use of large-scale microbiome data for research and education purposes.",
    "crumbs": [
      "Applications",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Microbiome analysis</span>"
    ]
  },
  {
    "objectID": "310_microbiome.html#data-containers",
    "href": "310_microbiome.html#data-containers",
    "title": "\n11  Microbiome analysis\n",
    "section": "\n11.3 Data containers",
    "text": "11.3 Data containers\nBioconductor provides several specialized data structures for storing and working with microbiome data in R. These data structures are designed to handle the complex and high-dimensional nature of microbiome data and provide a convenient and efficient way to store, manipulate, and analyze microbiome data in R.\nSummarizedExperiment (SE) (Morgan et al. 2020) is a generic and highly optimized container for complex data structures. It has become a common choice for analyzing various types of biomedical profiling data, such as RNAseq, ChIp-Seq, microarrays, flow cytometry, proteomics, and single-cell sequencing.\nTreeSummarizedExperiment (Huang 2020) was developed as an extension to incorporate hierarchical information (such as phylogenetic trees and sample hierarchies) and reference sequences.",
    "crumbs": [
      "Applications",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Microbiome analysis</span>"
    ]
  },
  {
    "objectID": "310_microbiome.html#loading-a-microbiome-dataset",
    "href": "310_microbiome.html#loading-a-microbiome-dataset",
    "title": "\n11  Microbiome analysis\n",
    "section": "\n11.4 Loading a microbiome dataset",
    "text": "11.4 Loading a microbiome dataset\nWe will be using the curatedMetagenomicData package to load the FengQ_2015 dataset. This dataset contains microbiome data from a study by Feng et al. (2015). The curatedMetagenomicData package provides a convenient interface for accessing microbiome datasets that have been pre-processed and curated for analysis.\nIgnore the details of the code for now, but suffice it to say that what the code will do for us is to load a dataset for downstream analysis.\n\n# Load the FengQ_2015 dataset\nlibrary(curatedMetagenomicData)\ntse &lt;- curatedMetagenomicData(\"FengQ_2015.relative_abundance\", dryrun = FALSE, rownames = \"short\")[[1]]\n\n\n$`2021-03-31.FengQ_2015.relative_abundance`\ndropping rows without rowTree matches:\n  k__Bacteria|p__Actinobacteria|c__Coriobacteriia|o__Coriobacteriales|f__Atopobiaceae|g__Olsenella|s__Olsenella_profusa\n  k__Bacteria|p__Actinobacteria|c__Coriobacteriia|o__Coriobacteriales|f__Coriobacteriaceae|g__Collinsella|s__Collinsella_stercoris\n  k__Bacteria|p__Actinobacteria|c__Coriobacteriia|o__Coriobacteriales|f__Coriobacteriaceae|g__Enorma|s__[Collinsella]_massiliensis\n  k__Bacteria|p__Firmicutes|c__Bacilli|o__Bacillales|f__Bacillales_unclassified|g__Gemella|s__Gemella_bergeri\n  k__Bacteria|p__Firmicutes|c__Bacilli|o__Lactobacillales|f__Carnobacteriaceae|g__Granulicatella|s__Granulicatella_elegans\n  k__Bacteria|p__Firmicutes|c__Clostridia|o__Clostridiales|f__Ruminococcaceae|g__Ruminococcus|s__Ruminococcus_champanellensis\n  k__Bacteria|p__Firmicutes|c__Erysipelotrichia|o__Erysipelotrichales|f__Erysipelotrichaceae|g__Bulleidia|s__Bulleidia_extructa\n  k__Bacteria|p__Proteobacteria|c__Betaproteobacteria|o__Burkholderiales|f__Sutterellaceae|g__Sutterella|s__Sutterella_parvirubra\n  k__Bacteria|p__Synergistetes|c__Synergistia|o__Synergistales|f__Synergistaceae|g__Cloacibacillus|s__Cloacibacillus_evryensis\n\n\nThis code goes out to the internet and downloads the dataset for you. The tse object is a TreeSummarizedExperiment object that contains the microbiome data from the Feng et al. (2015) study. The TreeSummarizedExperiment class is a specialized data structure for storing microbiome data in R, and it is used by the mia package for microbiome analysis.\n\n\n\n\n\n\nTip\n\n\n\nIf you are working with your own microbiome data, you will often need to load it into R using functions like read.csv() or read.table() to read tabular data files. Make sure your data is properly formatted and cleaned before loading it into R for analysis.\n\n\nOnce the data is loaded into R, we can start exploring the data to understand its structure and contents. The tse object is a TreeSummarizedExperiment object, which is a specialized data structure for storing microbiome data in R. It works quite like a data.frame in, but with many specialized structures for storing microbiome experiment data as shown in Figure 11.1. We can use various functions to explore the data stored in the tse object. See the TreeSummarizedExperiment package for more details.\nThis section provides an introduction to these data containers. In microbiome data science, these containers link taxonomic abundance tables with rich side information on the features and samples. Taxonomic abundance data can be obtained by 16S rRNA amplicon or metagenomic sequencing, phylogenetic microarrays, or by other means. Many microbiome experiments include multiple versions and types of data generated independently or derived from each other through transformation or agglomeration.\n\n\n\n\n\nFigure 11.1: Anatomy of a TreeSummarizedExperiment object. Compared to the SingleCellExperiment objects, TreeSummarizedExperiment has five additional slots. rowTree: the hierarchical structure on the rows of the assays. rowLinks: the link information between rows of the assays and the rowTree. colTree: the hierarchical structure on the columns of the assays. colLinks: the link information between columns of the assays and the colTree. referenceSeq (optional): the reference sequence data per feature (row).\n\n\nTo get an overview of the data, we can simply type the name of the object in the R console:\n\n# Print the object\ntse\n\nclass: TreeSummarizedExperiment \ndim: 601 154 \nmetadata(1): agglomerated_by_rank\nassays(1): relative_abundance\nrownames(601): [Bacteroides] pectinophilus [Butyribacterium]\n  methylotrophicum ... Weissella cibaria Weissella viridescens\nrowData names(7): superkingdom phylum ... genus species\ncolnames(154): SID31004 SID31009 ... SID532832 SID532915\ncolData names(28): study_name subject_id ... ldl hba1c\nreducedDimNames(0):\nmainExpName: NULL\naltExpNames(0):\nrowLinks: a LinkDataFrame (601 rows)\nrowTree: 1 phylo tree(s) (10430 leaves)\ncolLinks: NULL\ncolTree: NULL\n\n\nObserve how the output of the tse object will show you the dimensions of the data, the metadata associated with the samples and features, etc. However, the data themselves are not printed to the console due to the large size of the dataset. The TreeSummarizedExperiment object is a complex data structure that contains multiple components, including the abundance data, sample information, feature information, and other metadata.\nNext, we’ll look at some of the key components of the TreeSummarizedExperiment object and how to access and manipulate them.\n\n11.4.1 Assay data\nThe microbiome is the collection of all microbes (such as bacteria, viruses, fungi, etc.) in the body. When studying these microbes, data is needed, and that’s where assays come in. An assay is a way of measuring the presence and abundance of different types of microbes in a sample. For example, if you want to know how many bacteria of a certain type are in your gut, you can use an assay to measure this. When storing assays, the original data is count-based. However, the original count-based taxonomic abundance tables may undergo different transformations, such as logarithmic, Centered Log-Ratio (CLR), or relative abundance. These are typically stored in assays.\nThe assays slot contains the experimental data as multiple count matrices. The result of assays is a list of matrices.\n\nassays(tse)\n\nList of length 1\nnames(1): relative_abundance\n\n\nIndividual assays can be accessed via assay() function. The result is a matrix.\n\nassay(tse, \"relative_abundance\")[1:5, 1:5]\n\n                                   SID31004 SID31009 SID31021 SID31030 SID31071\n[Bacteroides] pectinophilus               0  0.35998  0.00000  0.00000        0\n[Butyribacterium] methylotrophicum        0  0.00000  0.00000  0.00000        0\n[Clostridium] hylemonae                   0  0.00000  0.00000  0.00000        0\n[Clostridium] innocuum                    0  0.00371  0.00384  0.01735        0\n[Clostridium] leptum                      0  0.00723  0.03135  0.03833        0\n\n\n\n11.4.2 colData\ncolData contains information about the samples used in the study. This information can include details such as the sample ID, the primers used in the analysis, the barcodes associated with the sample (truncated or complete), the type of sample (e.g. soil, fecal, mock) and a description of the sample.\n\ncolData(tse)\n\nDataFrame with 154 rows and 28 columns\n           study_name  subject_id   body_site antibiotics_current_use\n          &lt;character&gt; &lt;character&gt; &lt;character&gt;             &lt;character&gt;\nSID31004   FengQ_2015    SID31004       stool                      no\nSID31009   FengQ_2015    SID31009       stool                      no\nSID31021   FengQ_2015    SID31021       stool                      no\nSID31030   FengQ_2015    SID31030       stool                      no\nSID31071   FengQ_2015    SID31071       stool                      no\n...               ...         ...         ...                     ...\nSID532796  FengQ_2015   SID532796       stool                      no\nSID532802  FengQ_2015   SID532802       stool                      no\nSID532826  FengQ_2015   SID532826       stool                      no\nSID532832  FengQ_2015   SID532832       stool                      no\nSID532915  FengQ_2015   SID532915       stool                      no\n          study_condition                disease       age age_category\n              &lt;character&gt;            &lt;character&gt; &lt;integer&gt;  &lt;character&gt;\nSID31004              CRC CRC;fatty_liver;hype..        64        adult\nSID31009          control fatty_liver;hyperten..        68       senior\nSID31021          control                healthy        60        adult\nSID31030          adenoma adenoma;fatty_liver;..        70       senior\nSID31071          control            fatty_liver        68       senior\n...                   ...                    ...       ...          ...\nSID532796         control fatty_liver;hyperten..        73       senior\nSID532802         control                healthy        68       senior\nSID532826         control T2D;fatty_liver;hype..        78       senior\nSID532832         adenoma adenoma;fatty_liver;..        68       senior\nSID532915         control                healthy        43        adult\n               gender     country non_westernized sequencing_platform\n          &lt;character&gt; &lt;character&gt;     &lt;character&gt;         &lt;character&gt;\nSID31004         male         AUT              no       IlluminaHiSeq\nSID31009         male         AUT              no       IlluminaHiSeq\nSID31021       female         AUT              no       IlluminaHiSeq\nSID31030         male         AUT              no       IlluminaHiSeq\nSID31071         male         AUT              no       IlluminaHiSeq\n...               ...         ...             ...                 ...\nSID532796      female         AUT              no       IlluminaHiSeq\nSID532802        male         AUT              no       IlluminaHiSeq\nSID532826        male         AUT              no       IlluminaHiSeq\nSID532832      female         AUT              no       IlluminaHiSeq\nSID532915      female         AUT              no       IlluminaHiSeq\n          DNA_extraction_kit        PMID number_reads number_bases\n                 &lt;character&gt; &lt;character&gt;    &lt;integer&gt;    &lt;numeric&gt;\nSID31004               MoBio    25758642     40898340   3649611221\nSID31009               MoBio    25758642     66107961   6196998053\nSID31021               MoBio    25758642     60789126   5708593447\nSID31030               MoBio    25758642     50300253   4741158330\nSID31071               MoBio    25758642     51945426   4913627034\n...                      ...         ...          ...          ...\nSID532796              MoBio    25758642     50845712   4754848864\nSID532802              MoBio    25758642     41480415   3868696049\nSID532826              MoBio    25758642     35346002   3348368467\nSID532832              MoBio    25758642     42184599   3951224696\nSID532915              MoBio    25758642     51594677   4886998833\n          minimum_read_length median_read_length      NCBI_accession\n                    &lt;integer&gt;          &lt;integer&gt;         &lt;character&gt;\nSID31004                   30                 93 ERR688505;ERR688358\nSID31009                   30                 96 ERR688506;ERR688359\nSID31021                   30                 96 ERR688507;ERR688360\nSID31030                   30                 96 ERR688508;ERR688361\nSID31071                   30                 97 ERR688509;ERR688362\n...                       ...                ...                 ...\nSID532796                  30                 95 ERR710428;ERR710419\nSID532802                  30                 96 ERR710429;ERR710420\nSID532826                  30                 97 ERR710430;ERR710421\nSID532832                  30                 96 ERR710431;ERR710422\nSID532915                  30                 96 ERR710432;ERR710423\n                         curator       BMI        diet disease_subtype\n                     &lt;character&gt; &lt;numeric&gt; &lt;character&gt;     &lt;character&gt;\nSID31004  Paolo_Manghi;Marisa_..     29.35  vegetarian       carcinoma\nSID31009  Paolo_Manghi;Marisa_..     32.00    omnivore              NA\nSID31021  Paolo_Manghi;Marisa_..     22.10    omnivore              NA\nSID31030  Paolo_Manghi;Marisa_..     34.11    omnivore advancedadenoma\nSID31071  Paolo_Manghi;Marisa_..     23.45    omnivore              NA\n...                          ...       ...         ...             ...\nSID532796 Paolo_Manghi;Marisa_..     26.56    omnivore              NA\nSID532802 Paolo_Manghi;Marisa_..     23.53    omnivore              NA\nSID532826 Paolo_Manghi;Marisa_..     31.22    omnivore              NA\nSID532832 Paolo_Manghi;Marisa_..     27.55    omnivore advancedadenoma\nSID532915 Paolo_Manghi;Marisa_..     22.65    omnivore              NA\n                  tnm triglycerides       hdl       ldl     hba1c\n          &lt;character&gt;     &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt;\nSID31004       t1n0m0           172        28        92       5.2\nSID31009           NA           101        50       157        NA\nSID31021           NA            53        60       122        NA\nSID31030           NA            89        74       146        NA\nSID31071           NA           258        40       231        NA\n...               ...           ...       ...       ...       ...\nSID532796          NA           100        61       114       5.4\nSID532802          NA            80        67       158       5.8\nSID532826          NA           212        32        90       6.9\nSID532832          NA           141        51       184       5.6\nSID532915          NA            51        80       132       5.1\n\n\nAs you can see, there is a lot of information stored in the colData slot, including sample IDs, study conditions, and other metadata associated with the samples. This information is essential for understanding the context of the microbiome data and for performing downstream analyses.\n\n11.4.3 rowData\nrowData contains data on the features of the analyzed samples. This is particularly important in the microbiome field for storing taxonomic information. This taxonomic information is extremely important for understanding the composition and diversity of the microbiome in each sample analyzed. It enables identification of the different types of microorganisms present in samples. It also allows you to explore the relationships between microbiome composition and various environmental or health factors.\n\nhead(rowData(tse))\n\nDataFrame with 6 rows and 7 columns\n                                   superkingdom      phylum            class\n                                    &lt;character&gt; &lt;character&gt;      &lt;character&gt;\n[Bacteroides] pectinophilus            Bacteria  Firmicutes       Clostridia\n[Butyribacterium] methylotrophicum     Bacteria  Firmicutes       Clostridia\n[Clostridium] hylemonae                Bacteria  Firmicutes       Clostridia\n[Clostridium] innocuum                 Bacteria  Firmicutes Erysipelotrichia\n[Clostridium] leptum                   Bacteria  Firmicutes       Clostridia\n[Clostridium] methylpentosum           Bacteria  Firmicutes       Clostridia\n                                                order              family\n                                          &lt;character&gt;         &lt;character&gt;\n[Bacteroides] pectinophilus             Eubacteriales                  NA\n[Butyribacterium] methylotrophicum      Eubacteriales      Clostridiaceae\n[Clostridium] hylemonae                 Eubacteriales     Lachnospiraceae\n[Clostridium] innocuum             Erysipelotrichales Erysipelotrichaceae\n[Clostridium] leptum                    Eubacteriales    Oscillospiraceae\n[Clostridium] methylpentosum            Eubacteriales    Oscillospiraceae\n                                                    genus\n                                              &lt;character&gt;\n[Bacteroides] pectinophilus                            NA\n[Butyribacterium] methylotrophicum            Clostridium\n[Clostridium] hylemonae                 Lachnoclostridium\n[Clostridium] innocuum             Erysipelatoclostridium\n[Clostridium] leptum                                   NA\n[Clostridium] methylpentosum                           NA\n                                                  species\n                                              &lt;character&gt;\n[Bacteroides] pectinophilus        [Bacteroides] pectin..\n[Butyribacterium] methylotrophicum [Butyribacterium] me..\n[Clostridium] hylemonae            [Clostridium] hylemo..\n[Clostridium] innocuum             [Clostridium] innocuum\n[Clostridium] leptum                 [Clostridium] leptum\n[Clostridium] methylpentosum       [Clostridium] methyl..\n\n\n\n11.4.4 rowTree\nPhylogenetic trees also play an important role in the microbiome field. The TreeSE class can keep track of features and node relations via two functions, rowTree and rowLinks.\nA tree can be accessed via rowTree() as phylo object.\n\n\n\n\n\n\nPhylogenetic trees\n\n\n\nThe phylogenetic tree is a branching diagram or “tree” showing the inferred evolutionary relationships among various biological species or other entities based upon similarities and differences in their physical or genetic characteristics. The tree of life is a phylogenetic tree that shows the evolutionary relationships among all living organisms on Earth.\nIn the context of microbiome analysis, phylogenetic trees are used to represent the evolutionary relationships between different microbial taxa based on their genetic sequences. These trees can help researchers understand the diversity and relatedness of different microbes in a sample and provide insights into the evolutionary history of the microbial community.\nThe phylo class in R is used to represent phylogenetic trees and provides functions for working with and visualizing these trees. The ggtree package is a popular package for visualizing phylogenetic trees in R and provides a wide range of options for customizing the appearance of the tree.\n\n\n\nrowTree(tse)\n\n\nPhylogenetic tree with 10430 tips and 10429 internal nodes.\n\nTip labels:\n  k__Archaea|p__Candidatus_Micrarchaeota|c__Candidatus_Micrarchaeota_unclassified|o__Candidatus_Micrarchaeota_unclassified|f__Candidatus_Micrarchaeota_unclassified|g__Candidatus_Micrarchaeota_unclassified|s__Candidatus_Micrarchaeota_archaeon_CG1_02_55_22, k__Archaea|p__Archaea_unclassified|c__Archaea_unclassified|o__Archaea_unclassified|f__Archaea_unclassified|g__Archaea_unclassified|s__archaeon_GW2011_AR15, k__Archaea|p__Candidatus_Diapherotrites|c__Candidatus_Diapherotrites_unclassified|o__Candidatus_Diapherotrites_unclassified|f__Candidatus_Diapherotrites_unclassified|g__Candidatus_Diapherotrites_unclassified|s__Candidatus_Diapherotrites_archaeon_CG08_land_8_20_14_0_20_34_12, k__Archaea|p__Archaea_unclassified|c__Archaea_unclassified|o__Archaea_unclassified|f__Archaea_unclassified|g__Archaea_unclassified|s__archaeon_GW2011_AR10, k__Archaea|p__Candidatus_Diapherotrites|c__Candidatus_Diapherotrites_unclassified|o__Candidatus_Diapherotrites_unclassified|f__Candidatus_Diapherotrites_unclassified|g__Candidatus_Diapherotrites_unclassified|s__Candidatus_Diapherotrites_archaeon_CG11_big_fil_rev_8_21_14_0_20_37_9, k__Archaea|p__Euryarchaeota|c__Euryarchaeota_unclassified|o__Euryarchaeota_unclassified|f__Euryarchaeota_unclassified|g__Euryarchaeota_unclassified|s__Euryarchaeota_archaeon_TMED173, ...\n\nRooted; includes branch lengths.\n\n\nThe rowTree slot contains information about the hierarchical structure of the data, such as the relationships between different microbial taxa based on their genetic sequences. This information can be used to explore the evolutionary relationships between different microbes and to visualize the diversity and relatedness of the microbial community in a sample.\nWe can visualize the phylogenetic tree using the ggtree package in R. The ggtree package provides functions for visualizing phylogenetic trees in a variety of formats, including circular, rectangular, and radial layouts. Here, we’ll use the ggtree package to visualize the phylogenetic tree stored in the rowTree slot of the TreeSummarizedExperiment object.\n\nlibrary(ggtree)\nggtree(rowTree(tse))\n\n\n\n\n\n\n\nSee the ggtree package for more details on visualizing tree structures in R and, for more fun, the ggtree book.\nThe rowLink slot contains information about the relationships between the features and the tree structure. This information can be used to link the features in the data to the nodes in the tree and to explore the relationships between the features based on their abundance profiles.\n\nrowLinks(tse)\n\nLinkDataFrame with 601 rows and 5 columns\n                                                  nodeLab nodeLab_alias\n                                              &lt;character&gt;   &lt;character&gt;\n[Bacteroides] pectinophilus        k__Bacteria|p__Firmi..    alias_3706\n[Butyribacterium] methylotrophicum k__Bacteria|p__Firmi..    alias_3347\n[Clostridium] hylemonae            k__Bacteria|p__Firmi..    alias_3662\n[Clostridium] innocuum             k__Bacteria|p__Firmi..    alias_4453\n[Clostridium] leptum               k__Bacteria|p__Firmi..    alias_3525\n...                                                   ...           ...\nVeillonella sp. T11011-6           k__Bacteria|p__Firmi..    alias_3074\nVeillonella tobetsuensis           k__Bacteria|p__Firmi..    alias_3070\nVictivallis vadensis               k__Bacteria|p__Lenti..    alias_5062\nWeissella cibaria                  k__Bacteria|p__Firmi..    alias_4775\nWeissella viridescens              k__Bacteria|p__Firmi..    alias_4773\n                                     nodeNum    isLeaf   whichTree\n                                   &lt;integer&gt; &lt;logical&gt; &lt;character&gt;\n[Bacteroides] pectinophilus             3706      TRUE       phylo\n[Butyribacterium] methylotrophicum      3347      TRUE       phylo\n[Clostridium] hylemonae                 3662      TRUE       phylo\n[Clostridium] innocuum                  4453      TRUE       phylo\n[Clostridium] leptum                    3525      TRUE       phylo\n...                                      ...       ...         ...\nVeillonella sp. T11011-6                3074      TRUE       phylo\nVeillonella tobetsuensis                3070      TRUE       phylo\nVictivallis vadensis                    5062      TRUE       phylo\nWeissella cibaria                       4775      TRUE       phylo\nWeissella viridescens                   4773      TRUE       phylo\n\n\nBoth rowTree and rowLinks are optional components of the TreeSummarizedExperiment object, but when present, they provide valuable information about the hierarchical structure of the data and the relationships between the features in the data.",
    "crumbs": [
      "Applications",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Microbiome analysis</span>"
    ]
  },
  {
    "objectID": "310_microbiome.html#wrangling-and-subsetting",
    "href": "310_microbiome.html#wrangling-and-subsetting",
    "title": "\n11  Microbiome analysis\n",
    "section": "\n11.5 Wrangling and subsetting",
    "text": "11.5 Wrangling and subsetting\nThe mia package provides several functions for wrangling and subsetting microbiome data. These functions allow you to filter, transform, and manipulate the data to extract the information you need for analysis.\n\n11.5.1 Subsetting samples\nYou can subset the samples in a TreeSummarizedExperiment object similarly to how you would subset a data.frame. For example, to subset out data based on the age category of the samples, you can use the following code:\n\nhead(tse$age)\n\n[1] 64 68 60 70 68 66\n\n\nAge is a numeric variable. Let’s focus on older patients.\n\ntse_subset_by_age &lt;- tse[, tse$age &gt; 50]\ntse_subset_by_age\n\nclass: TreeSummarizedExperiment \ndim: 601 146 \nmetadata(1): agglomerated_by_rank\nassays(1): relative_abundance\nrownames(601): [Bacteroides] pectinophilus [Butyribacterium]\n  methylotrophicum ... Weissella cibaria Weissella viridescens\nrowData names(7): superkingdom phylum ... genus species\ncolnames(146): SID31004 SID31009 ... SID532826 SID532832\ncolData names(28): study_name subject_id ... ldl hba1c\nreducedDimNames(0):\nmainExpName: NULL\naltExpNames(0):\nrowLinks: a LinkDataFrame (601 rows)\nrowTree: 1 phylo tree(s) (10430 leaves)\ncolLinks: NULL\ncolTree: NULL\n\n\n\n11.5.2 Agglomerating data\nThe microbiome features (organisms) that are measured may be measured at different taxonomic levels. For example, the data may be available at the species, genus, family, or phylum level. Agglomerating data is the process of summarizing the data at a higher taxonomic level by combining the abundances of the lower-level taxa. This can be useful for simplifying the data and reducing the dimensionality of the data.\nThe agglomerateByRank function in the mia package can be used to agglomerate the data at a specified taxonomic rank. For example, to agglomerate the data at the phylum level, you can use the following code:\n\nnew_tse &lt;- agglomerateByRank(tse, rank = \"phylum\")\n\nWarning: The following values are already present in `metadata` and will be\noverwritten: 'agglomerated_by_rank'. Consider using the 'name' argument to\nspecify alternative names.\n\n# observe the new object, particularly the number of features (rows)\nnew_tse\n\nclass: TreeSummarizedExperiment \ndim: 13 154 \nmetadata(1): agglomerated_by_rank\nassays(1): relative_abundance\nrownames(13): Actinobacteria Ascomycota ... Synergistetes\n  Verrucomicrobia\nrowData names(7): superkingdom phylum ... genus species\ncolnames(154): SID31004 SID31009 ... SID532832 SID532915\ncolData names(28): study_name subject_id ... ldl hba1c\nreducedDimNames(0):\nmainExpName: NULL\naltExpNames(0):\nrowLinks: a LinkDataFrame (13 rows)\nrowTree: 1 phylo tree(s) (10430 leaves)\ncolLinks: NULL\ncolTree: NULL\n\n\nThe resulting TreeSummarizedExperiment object contains the data aggregated at the phylum level, with the abundances of the lower-level taxa combined to create a summary at the phylum level. This can make the data easier to work with and interpret, especially when dealing with large and complex microbiome datasets.",
    "crumbs": [
      "Applications",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Microbiome analysis</span>"
    ]
  },
  {
    "objectID": "310_microbiome.html#community-indices",
    "href": "310_microbiome.html#community-indices",
    "title": "\n11  Microbiome analysis\n",
    "section": "\n11.6 Community indices",
    "text": "11.6 Community indices\nIn the field of microbiome ecology several indices to describe samples and community of samples are available. In this vignette we just want to give a very brief introduction.\n\n11.6.1 Alpha diversity\ndiversity in microbiology is measured by several indices:\n\nspecies richness (total number of species)\nequitability (distribution of species within a microbiome)\ndiversity (combination of the two)\n\nFunctions for calculating alpha and beta diversity indices are available. Using addAlpha multiple diversity indices are calculated by default and results are stored automatically in colData.\nIn the code below we calculate the Shannon and observed diversity indices.\n\ntse &lt;- addAlpha(tse, index = \"shannon\", assay.type = \"relative_abundance\")\ntse &lt;- addAlpha(tse, index = \"observed\", assay.type = \"relative_abundance\")\ncolnames(colData(tse))\n\n [1] \"study_name\"              \"subject_id\"             \n [3] \"body_site\"               \"antibiotics_current_use\"\n [5] \"study_condition\"         \"disease\"                \n [7] \"age\"                     \"age_category\"           \n [9] \"gender\"                  \"country\"                \n[11] \"non_westernized\"         \"sequencing_platform\"    \n[13] \"DNA_extraction_kit\"      \"PMID\"                   \n[15] \"number_reads\"            \"number_bases\"           \n[17] \"minimum_read_length\"     \"median_read_length\"     \n[19] \"NCBI_accession\"          \"curator\"                \n[21] \"BMI\"                     \"diet\"                   \n[23] \"disease_subtype\"         \"tnm\"                    \n[25] \"triglycerides\"           \"hdl\"                    \n[27] \"ldl\"                     \"hba1c\"                  \n[29] \"shannon\"                 \"observed\"               \n\n\nThe observed index is a simple count of the number of species present in a sample, while the shannon index takes into account both the number of species and their relative abundances. These indices provide information about the diversity and richness of the microbial community in each sample.\nAnd we can look at the resulting colData() which now contains the calculated alpha diversity indices.\n\ncolData(tse)\n\nDataFrame with 154 rows and 30 columns\n           study_name  subject_id   body_site antibiotics_current_use\n          &lt;character&gt; &lt;character&gt; &lt;character&gt;             &lt;character&gt;\nSID31004   FengQ_2015    SID31004       stool                      no\nSID31009   FengQ_2015    SID31009       stool                      no\nSID31021   FengQ_2015    SID31021       stool                      no\nSID31030   FengQ_2015    SID31030       stool                      no\nSID31071   FengQ_2015    SID31071       stool                      no\n...               ...         ...         ...                     ...\nSID532796  FengQ_2015   SID532796       stool                      no\nSID532802  FengQ_2015   SID532802       stool                      no\nSID532826  FengQ_2015   SID532826       stool                      no\nSID532832  FengQ_2015   SID532832       stool                      no\nSID532915  FengQ_2015   SID532915       stool                      no\n          study_condition                disease       age age_category\n              &lt;character&gt;            &lt;character&gt; &lt;integer&gt;  &lt;character&gt;\nSID31004              CRC CRC;fatty_liver;hype..        64        adult\nSID31009          control fatty_liver;hyperten..        68       senior\nSID31021          control                healthy        60        adult\nSID31030          adenoma adenoma;fatty_liver;..        70       senior\nSID31071          control            fatty_liver        68       senior\n...                   ...                    ...       ...          ...\nSID532796         control fatty_liver;hyperten..        73       senior\nSID532802         control                healthy        68       senior\nSID532826         control T2D;fatty_liver;hype..        78       senior\nSID532832         adenoma adenoma;fatty_liver;..        68       senior\nSID532915         control                healthy        43        adult\n               gender     country non_westernized sequencing_platform\n          &lt;character&gt; &lt;character&gt;     &lt;character&gt;         &lt;character&gt;\nSID31004         male         AUT              no       IlluminaHiSeq\nSID31009         male         AUT              no       IlluminaHiSeq\nSID31021       female         AUT              no       IlluminaHiSeq\nSID31030         male         AUT              no       IlluminaHiSeq\nSID31071         male         AUT              no       IlluminaHiSeq\n...               ...         ...             ...                 ...\nSID532796      female         AUT              no       IlluminaHiSeq\nSID532802        male         AUT              no       IlluminaHiSeq\nSID532826        male         AUT              no       IlluminaHiSeq\nSID532832      female         AUT              no       IlluminaHiSeq\nSID532915      female         AUT              no       IlluminaHiSeq\n          DNA_extraction_kit        PMID number_reads number_bases\n                 &lt;character&gt; &lt;character&gt;    &lt;integer&gt;    &lt;numeric&gt;\nSID31004               MoBio    25758642     40898340   3649611221\nSID31009               MoBio    25758642     66107961   6196998053\nSID31021               MoBio    25758642     60789126   5708593447\nSID31030               MoBio    25758642     50300253   4741158330\nSID31071               MoBio    25758642     51945426   4913627034\n...                      ...         ...          ...          ...\nSID532796              MoBio    25758642     50845712   4754848864\nSID532802              MoBio    25758642     41480415   3868696049\nSID532826              MoBio    25758642     35346002   3348368467\nSID532832              MoBio    25758642     42184599   3951224696\nSID532915              MoBio    25758642     51594677   4886998833\n          minimum_read_length median_read_length      NCBI_accession\n                    &lt;integer&gt;          &lt;integer&gt;         &lt;character&gt;\nSID31004                   30                 93 ERR688505;ERR688358\nSID31009                   30                 96 ERR688506;ERR688359\nSID31021                   30                 96 ERR688507;ERR688360\nSID31030                   30                 96 ERR688508;ERR688361\nSID31071                   30                 97 ERR688509;ERR688362\n...                       ...                ...                 ...\nSID532796                  30                 95 ERR710428;ERR710419\nSID532802                  30                 96 ERR710429;ERR710420\nSID532826                  30                 97 ERR710430;ERR710421\nSID532832                  30                 96 ERR710431;ERR710422\nSID532915                  30                 96 ERR710432;ERR710423\n                         curator       BMI        diet disease_subtype\n                     &lt;character&gt; &lt;numeric&gt; &lt;character&gt;     &lt;character&gt;\nSID31004  Paolo_Manghi;Marisa_..     29.35  vegetarian       carcinoma\nSID31009  Paolo_Manghi;Marisa_..     32.00    omnivore              NA\nSID31021  Paolo_Manghi;Marisa_..     22.10    omnivore              NA\nSID31030  Paolo_Manghi;Marisa_..     34.11    omnivore advancedadenoma\nSID31071  Paolo_Manghi;Marisa_..     23.45    omnivore              NA\n...                          ...       ...         ...             ...\nSID532796 Paolo_Manghi;Marisa_..     26.56    omnivore              NA\nSID532802 Paolo_Manghi;Marisa_..     23.53    omnivore              NA\nSID532826 Paolo_Manghi;Marisa_..     31.22    omnivore              NA\nSID532832 Paolo_Manghi;Marisa_..     27.55    omnivore advancedadenoma\nSID532915 Paolo_Manghi;Marisa_..     22.65    omnivore              NA\n                  tnm triglycerides       hdl       ldl     hba1c   shannon\n          &lt;character&gt;     &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt;\nSID31004       t1n0m0           172        28        92       5.2   3.28881\nSID31009           NA           101        50       157        NA   3.10400\nSID31021           NA            53        60       122        NA   3.37028\nSID31030           NA            89        74       146        NA   2.59465\nSID31071           NA           258        40       231        NA   3.14486\n...               ...           ...       ...       ...       ...       ...\nSID532796          NA           100        61       114       5.4   3.65802\nSID532802          NA            80        67       158       5.8   3.19414\nSID532826          NA           212        32        90       6.9   3.15717\nSID532832          NA           141        51       184       5.6   3.21046\nSID532915          NA            51        80       132       5.1   3.48644\n           observed\n          &lt;numeric&gt;\nSID31004        100\nSID31009        105\nSID31021        115\nSID31030        105\nSID31071        112\n...             ...\nSID532796       131\nSID532802       109\nSID532826       101\nSID532832        93\nSID532915       126\n\n\nThe scater package provides some convenient plotting functions that are designed to work with the SummarizedExperiment class.\n\nlibrary(scater)\n\nLoading required package: scuttle\n\n\nLoading required package: ggplot2\n\n\n\nAttaching package: 'scater'\n\n\nThe following object is masked from 'package:ggtree':\n\n    multiplot\n\nplotColData(tse,\n    \"observed\",\n    \"study_condition\",\n    colour_by = \"gender\"\n) +\n    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +\n    labs(y = expression(Richness[Observed]))\n\n\n\n\n\n\n\n\n11.6.2 Beta diversity\nCommunity similarity refers to the way microorganisms resemble each other in terms of their composition and abundance of different microbial taxa. This can help us understand to what degree different samples resemble each other and finding key information. In microbiome analysis however, it’s more common to measure the dissimilarity/Beta diversity between two samples A and B using the Bray-Curtis measure which is defined as follows:\n\\[\nBC_{ij} = \\frac{\\sum_{k} |A_{k} - B_{k}|}{\\sum_{k} (A_{k} + B_{k})}\n\\]\nwhere \\(A_{k}\\) and \\(B_{k}\\) are the abundances of taxon \\(k\\) in samples A and B, respectively. The Bray-Curtis dissimilarity ranges from 0 (identical communities) to 1 (completely different communities).\nThe mia package provides functions for calculating beta diversity indices, such as the Bray-Curtis dissimilarity, Jaccard similarity, and UniFrac distance. These indices can be used to compare the microbial communities between different samples and to identify patterns and relationships between samples based on their microbial composition.\n\n# Run PCoA on relabundance assay with Bray-Curtis distances\nlibrary(vegan)\n\ntse &lt;- runMDS(tse,\n    FUN = vegdist,\n    method = \"bray\",\n    assay.type = \"relative_abundance\",\n    name = \"MDS_bray\"\n)\n\nThis code is a bit to unpack. It calculates the Bray-Curtis dissimilarity between samples in the tse object using the vegdist function from the vegan package. The resulting dissimilarity matrix is then used to perform a Principal Coordinate Analysis (PCoA) using the runMDS function from the scater package. The PCoA is a dimensionality reduction technique that projects the high-dimensional Bray-Curtis dissimilarity matrix onto a lower-dimensional space while preserving the pairwise distances between samples.\nThe resulting TreeSummarizedExperiment object now contains the Bray-Curtis dissimilarity matrix in the MDS_bray slot, which can be used to visualize the relationships between samples based on their microbial composition.\nWe can visualize the results of the PCoA using the plotReducedDim function from the scater package. This function creates a plot of the reduced dimensions (PCoA) and colors the samples based on a specified variable, such as the study condition\n\n# Create ggplot object\np &lt;- plotReducedDim(tse, \"MDS_bray\", colour_by = \"study_condition\")\n\nprint(p)\n\n\n\n\n\n\n\nYou can experiment with different variables to color the samples and explore the relationships between samples based on their microbial composition.",
    "crumbs": [
      "Applications",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Microbiome analysis</span>"
    ]
  },
  {
    "objectID": "310_microbiome.html#microbial-composition",
    "href": "310_microbiome.html#microbial-composition",
    "title": "\n11  Microbiome analysis\n",
    "section": "\n11.7 Microbial composition",
    "text": "11.7 Microbial composition\nLet’s now look at the microbial composition of the samples in the tse object. The microbial composition refers to the relative abundances of different microbial taxa in each sample. This information can provide insights into the diversity and structure of the microbial community in each sample and help identify patterns and relationships between samples based on their microbial composition.\nThe mia package provides functions for visualizing the microbial composition of samples, such as bar plots, heatmaps, and stacked bar plots. These plots can help you explore the relative abundances of different microbial taxa in each sample and identify patterns and relationships between samples based on their microbial composition.\n\n11.7.1 Abundance\nWe can start by creating a bar plot of the top 40 most abundant taxa in the dataset. This plot shows the relative abundances of the top 40 taxa in each sample, with the taxa sorted by abundance.\n\nlibrary(miaViz)\n\nLoading required package: ggraph\n\nplotAbundanceDensity(tse,\n    layout = \"jitter\",\n    assay.type = \"relative_abundance\",\n    n = 40\n) +\n    scale_x_log10(label = scales::percent)\n\nWarning in getTopFeatures(object, top = n, assay.type = assay.type):\n'getTopFeatures' is deprecated. Use 'getTop' instead.\n\n\nWarning in scale_x_log10(label = scales::percent): log-10 transformation\nintroduced infinite values.\n\n\n\n\n\n\n\n\nWe can also look at the relative abundances of specific taxa in the dataset.\n\nplotAbundanceDensity(tse,\n    layout = \"density\",\n    assay.type = \"relative_abundance\",\n    n = 5, colour_by = \"study_condition\"\n) +\n    scale_x_log10()\n\nWarning in getTopFeatures(object, top = n, assay.type = assay.type):\n'getTopFeatures' is deprecated. Use 'getTop' instead.\n\n\nWarning in scale_x_log10(): log-10 transformation introduced infinite values.\n\n\nWarning: Removed 53 rows containing non-finite outside the scale range\n(`stat_density()`).\n\n\n\n\n\n\n\n\n\n11.7.2 Prevalence\nPrevalence refers to the proportion of samples in which a taxon is present. This information can help identify the most common and rare taxa in the dataset and provide insights into the distribution of different taxa across samples.\nLet’s agglomerate the data at the genus level and then plot the prevalence of the top 20 most prevalent genera in the dataset.\n\ntse_genus &lt;- agglomerateByRank(tse, rank = \"genus\")\n\nWarning: The following values are already present in `metadata` and will be\noverwritten: 'agglomerated_by_rank'. Consider using the 'name' argument to\nspecify alternative names.\n\n\n\nhead(getPrevalence(tse_genus,\n    detection = 1 / 100,\n    sort = TRUE, assay.type = \"relative_abundance\",\n    as.relative = TRUE\n))\n\n   Bifidobacterium              Dorea   Faecalibacterium Mediterraneibacter \n         0.7857143          0.7662338          0.7337662          0.7272727 \n      Anaerostipes            Blautia \n         0.7272727          0.7077922",
    "crumbs": [
      "Applications",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Microbiome analysis</span>"
    ]
  },
  {
    "objectID": "310_microbiome.html#heatmaps",
    "href": "310_microbiome.html#heatmaps",
    "title": "\n11  Microbiome analysis\n",
    "section": "\n11.8 Heatmaps",
    "text": "11.8 Heatmaps\nHeatmaps are a common way to visualize microbiome data and can provide insights into the relative abundances of different microbial taxa in each sample. To keep things simple, we’ll create a heatmap of the relative abundances of the phyla in the dataset.\nWe first agglomerate the data at the phylum level and then create a heatmap of the relative abundances of the phyla in the dataset.\n\nlibrary(pheatmap)\ntse_phylum &lt;- agglomerateByRank(tse, rank = \"phylum\")\n\nWarning: The following values are already present in `metadata` and will be\noverwritten: 'agglomerated_by_rank'. Consider using the 'name' argument to\nspecify alternative names.\n\npheatmap(assay(tse_phylum, \"relative_abundance\"))",
    "crumbs": [
      "Applications",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Microbiome analysis</span>"
    ]
  },
  {
    "objectID": "310_microbiome.html#further-fun",
    "href": "310_microbiome.html#further-fun",
    "title": "\n11  Microbiome analysis\n",
    "section": "\n11.9 Further fun",
    "text": "11.9 Further fun\nThe mia package folks have created a book on microbome analysis in R that you can explore for more details on microbiome analysis in R. The book covers a wide range of topics related to microbiome analysis, including data loading, preprocessing, visualization, and statistical analysis. It provides detailed explanations and examples of how to work with microbiome data in R and is a valuable resource for anyone interested in learning more about microbiome analysis.",
    "crumbs": [
      "Applications",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Microbiome analysis</span>"
    ]
  },
  {
    "objectID": "data_structures_overview.html",
    "href": "data_structures_overview.html",
    "title": "R data structures",
    "section": "",
    "text": "Chapter overview\nAs you progress through these chapters, practice the examples and exercises provided, engage in discussion, and collaborate with your peers to deepen your understanding of R data structures. This solid foundation will serve as the basis for more advanced data manipulation, analysis, and visualization techniques in R.",
    "crumbs": [
      "R data structures"
    ]
  },
  {
    "objectID": "data_structures_overview.html#chapter-overview",
    "href": "data_structures_overview.html#chapter-overview",
    "title": "R data structures",
    "section": "",
    "text": "Vectors : In this chapter, we will introduce you to the simplest data structure in R, the vector. We will cover how to create, access, and manipulate vectors, as well as discuss their unique properties and limitations.\n\nMatrices\n\nNext, we will explore matrices, which are two-dimensional data structures that extend vectors. You will learn how to create, access, and manipulate matrices, and understand their usefulness in mathematical operations and data organization.\n\n\n\nLists\n\nThe third chapter will focus on lists, a versatile data structure that can store elements of different types and sizes. We will discuss how to create, access, and modify lists, and demonstrate their flexibility in handling complex data structures.\n\n\n\nData.frames\n\nFinally, we will examine data.frames, a widely-used data structure for organizing and manipulating tabular data. You will learn how to create, access, and manipulate data.frames, and understand their advantages over other data structures for data analysis tasks.\n\n\n\nArrays\n\nWhile we will not focus directly on the array data type, which are multidimensional data structures that extend matrices, they are very similar to matrices, but with a third dimension.",
    "crumbs": [
      "R data structures"
    ]
  }
]