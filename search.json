[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduction to R for BigCare 2024",
    "section": "",
    "text": "Overview\nThis is the overview.",
    "crumbs": [
      "Overview"
    ]
  },
  {
    "objectID": "010_rstudio_and_r.html",
    "href": "010_rstudio_and_r.html",
    "title": "1  Introduction",
    "section": "",
    "text": "1.1 What is R?\nR is a programming language and software environment designed for statistical computing and graphics. It is widely used by statisticians, data scientists, and researchers for data analysis and visualization. R is an open-source language, which means it is free to use, modify, and distribute. Over the years, R has become particularly popular (see Figure 1.1) in the fields of genomics and bioinformatics, owing to its extensive libraries and powerful data manipulation capabilities.\nThe R language is a dialect of the S language, which was developed in the 1970s at Bell Laboratories. The first version of R was written by Robert Gentleman and Ross Ihaka and released in 1995 (see this slide deck for Ross Ihaka’s take on R’s history). Since then, R has been continuously developed by the R Core Team, a group of statisticians and computer scientists. The R Core Team releases a new version of R every year.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "010_rstudio_and_r.html#what-is-r",
    "href": "010_rstudio_and_r.html#what-is-r",
    "title": "1  Introduction",
    "section": "",
    "text": "Figure 1.1: Google trends showing the popularity of R over time based on Google searches.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "010_rstudio_and_r.html#why-use-r",
    "href": "010_rstudio_and_r.html#why-use-r",
    "title": "1  Introduction",
    "section": "1.2 Why use R?",
    "text": "1.2 Why use R?\nThere are several reasons why R is a popular choice for data analysis, particularly in genomics and bioinformatics. These include:\n\nOpen-source1: R is free to use and has a large community of developers who contribute to its growth and development. Open source software is software with source code that anyone can inspect, modify, and enhance.\nExtensive libraries: There are thousands of R packages available for a wide range of tasks, including specialized packages for genomics and bioinformatics. These libraries have been extensively tested and ara available for free.\nData manipulation: R has powerful data manipulation capabilities, making it easy (or at least possible) to clean, process, and analyze large datasets.\nGraphics and visualization: R has excellent tools for creating high-quality graphics and visualizations that can be customized to meet the specific needs of your analysis. In most cases, graphics produced by R are publication-quality.\nReproducible research: R enables you to create reproducible research by recording your analysis in a script, which can be easily shared and executed by others. In addition, R does not have a meaningful graphical user interface (GUI), which renders analysis in R much more reproducible than tools that rely on GUI interactions.\nCross-platform: R runs on Windows, Mac, and Linux (as well as more obscure systems).\nInteroperability with other languages: R can interfact with FORTRAN, C, and many other languages.\nScalability: R is useful for small and large projects. I can develop code for analysis on my Mac laptop. I can then install the same code on our 20k core cluster and run it in parallel on 100 samples, monitor the process, and then update a database (for example) with R when complete.\n\n1 Source code is the code computer programmers can manipulate to change how a piece of software—a “program” or “application”—works. Programmers who have access to a computer program’s source code can improve that program by adding features to it or fixing parts that don’t always work correctly. For more details, see what is “open-source”?",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "010_rstudio_and_r.html#why-not-use-r",
    "href": "010_rstudio_and_r.html#why-not-use-r",
    "title": "1  Introduction",
    "section": "1.3 Why not use R?",
    "text": "1.3 Why not use R?\n\nR cannot do everything. There are some tasks that are better suited to other languages or tools. However, R can often be used to interface with these other tools.\nR is not always the “best” tool for the job. (However, it is often a “good” tool for the job.)\nR will not hold your hand. Often, it will slap your hand instead. In other words, R is not always user-friendly and can be difficult to learn. (We’ll try to make it easier for you in this book and by providing you with a good foundation for learning R and getting help when you need it.)\nThe documentation can be opaque (but there is documentation).\nR can drive you crazy (on a good day) or age you prematurely (on a bad one).\nFinding the right package to do the job you want to do can be challenging; worse, some contributed packages are unreliable or poorly documented.\nR does not have a meaningfully useful graphical user interface (GUI). If you are used to working with a GUI, you may find R difficult to use at first.\n\nAdditional reasons to consider other tools include access to expertise and support from colleagues and coworkers. If you are working in a group that uses python, for example, you may want to use python for your analysis to take advantage of the expertise of your colleagues.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "010_rstudio_and_r.html#r-license-and-the-open-source-ideal",
    "href": "010_rstudio_and_r.html#r-license-and-the-open-source-ideal",
    "title": "1  Introduction",
    "section": "1.4 R License and the Open Source Ideal",
    "text": "1.4 R License and the Open Source Ideal\nR is free (yes, totally free!) and distributed under GNU license. In particular, this license allows one to:\n\nDownload the source code\nModify the source code to your heart’s content\nDistribute the modified source code and even charge money for it, but you must distribute the modified source code under the original GNU license.\n\nThis license means that R will always be available, will always be open source, and can grow organically without constraint.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "010_rstudio_and_r.html#rstudio",
    "href": "010_rstudio_and_r.html#rstudio",
    "title": "1  Introduction",
    "section": "1.5 RStudio",
    "text": "1.5 RStudio\nRStudio is an integrated development environment (IDE) for R. RStudio also provides several other useful features, including a built-in console, syntax-highlighting editor, and tools for plotting, history, debugging, workspace management, and workspace viewing. RStudio is available in both free and commercial editions; the commercial edition provides some additional features, including support for multiple sessions and enhanced debugging. For the vast majority of users, the free version is more than sufficient.\n\n1.5.1 Getting started with RStudio\nTo get started with RStudio, you first need to install both R and RStudio on your computer. Follow these steps:\n\nDownload and install R from the official R website.\nDownload and install RStudio from the official RStudio website.\nLaunch RStudio. You should see the RStudio interface with four panels as shown in Figure 1.2.\n\n\n\n1.5.2 The RStudio Interface\nRStudio’s interface consists of four panels (see Figure 1.2) that provide different functionalities:\n\n\nConsole\n\nThis panel displays the R console, where you can enter and execute R commands directly. The console also shows the output of your code, error messages, and other information.\n\n\n\nSource\n\nThis panel is where you write and edit your R scripts. You can create new scripts, open existing ones, and run your code from this panel.\n\n\n\nEnvironment\n\nThis panel displays your current workspace, including all variables, data objects, and functions that you have created or loaded in your R session.\n\n\n\nPlots, Packages, Help, and Viewer\n\nThese panels display plots, installed packages, help files, and web content, respectively.\n\n\n\n\n\n\n\n\n\nFigure 1.2: The RStudio interface. In this layout, the source pane is in the upper left, the console is in the lower left, the environment panel is in the top right and the viewer/help/files panel is in the bottom right.\n\n\n\n\n\n\n\n\n\nDo I need to use RStudio?\n\n\n\nNo. You can use R without RStudio. Other interfaces, such as jupyter notebooks or VScode are great alternatives. However, RStudio makes it easy to write and execute R code, and it provides several useful features that are not available in the basic R console. Note that the only part of RStudio that is actually interacting with R directly is the console. The other panels are simply providing a GUI that enhances the user experience.\n\n\n\n\n\n\n\n\nCustomizing the RStudio Interface\n\n\n\nYou can customize the layout of RStudio to suit your preferences. To do so, go to Tools &gt; Global Options &gt; Appearance. Here, you can change the theme, font size, and panel layout. You can also resize the panels as needed to gain screen real estate (see Figure 1.3).\n\n\n\n\n\n\n\n\nFigure 1.3: Dealing with limited screen real estate can be a challenge, particularly when you want to open another window to, for example, view a web page. You can resize the panes by sliding the center divider (red arrows) or by clicking on the minimize/maximize buttons (see blue arrow).",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "010_rstudio_and_r.html#summary",
    "href": "010_rstudio_and_r.html#summary",
    "title": "1  Introduction",
    "section": "1.6 Summary",
    "text": "1.6 Summary\nAt this point, you should have a working Rstudio installation on your computer. In the next chapter, we will discuss the basics of R programming, including how to perform simple calculations, create variables, and use functions.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "020_r_basics.html",
    "href": "020_r_basics.html",
    "title": "\n2  Up and Running with R\n",
    "section": "",
    "text": "2.1 The R User Interface\nThe RStudio interface is simple. You type R code into the bottom line of the RStudio console pane and then click Enter to run it. The code you type is called a command, because it will command your computer to do something for you. The line you type it into is called the command line.\nWhen you type a command at the prompt and hit Enter, your computer executes the command and shows you the results. Then RStudio displays a fresh prompt for your next command. For example, if you type 1 + 1 and hit Enter, RStudio will display:\nYou’ll notice that a [1] appears next to your result. R is just letting you know that this line begins with the first value in your result. Some commands return more than one value, and their results may fill up multiple lines. For example, the command 100:130 returns 31 values; it creates a sequence of integers from 100 to 130. Notice that new bracketed numbers appear at the start of the second and third lines of output. These numbers just mean that the second line begins with the 14th value in the result, and the third line begins with the 25th value. You can mostly ignore the numbers that appear in brackets:\nIf you type an incomplete command and press Enter, R will display a + prompt, which means R is waiting for you to type the rest of your command. Either finish the command or hit Escape to start over:\nIf you type a command that R doesn’t recognize, R will return an error message. If you ever see an error message, don’t panic. R is just telling you that your computer couldn’t understand or do what you asked it to do. You can then try a different command at the next prompt:\nOnce you get the hang of the command line, you can easily do anything in R that you would do with a calculator. For example, you could do some basic arithmetic:\n2 * 3   \n\n[1] 6\n\n4 - 1   \n\n[1] 3\n\n# this obeys order-of-operations\n6 / (4 - 1)   \n\n[1] 2",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Up and Running with R</span>"
    ]
  },
  {
    "objectID": "020_r_basics.html#the-r-user-interface",
    "href": "020_r_basics.html#the-r-user-interface",
    "title": "\n2  Up and Running with R\n",
    "section": "",
    "text": "Figure 2.1: Your computer does your bidding when you type R commands at the prompt in the bottom line of the console pane. Don’t forget to hit the Enter key. When you first open RStudio, the console appears in the pane on your left, but you can change this with File &gt; Tools &gt; Global Options in the menu bar.\n\n\n\n&gt; 1 + 1\n[1] 2\n&gt;\n\n&gt; 100:130\n [1] 100 101 102 103 104 105 106 107 108 109 110 111 112\n[14] 113 114 115 116 117 118 119 120 121 122 123 124 125\n[25] 126 127 128 129 130\n\n\n\n\n\n\nTip\n\n\n\nThe colon operator (:) returns every integer between two integers. It is an easy way to create a sequence of numbers.\n\n\n\n\n\n\n\n\nWhen do we compile?\n\n\n\nIn some languages, like C, Java, and FORTRAN, you have to compile your human-readable code into machine-readable code (often 1s and 0s) before you can run it. If you’ve programmed in such a language before, you may wonder whether you have to compile your R code before you can use it. The answer is no. R is a dynamic programming language, which means R automatically interprets your code as you run it.\n\n\n\n&gt; 5 -\n+\n+ 1\n[1] 4\n\n&gt; 3 % 5\nError: unexpected input in \"3 % 5\"\n&gt;\n\n\n\n\n\n\nTip\n\n\n\nWhenever you get an error message in R, consider googling the error message. You’ll often find that someone else has had the same problem and has posted a solution online. Simply cutting-and-pasting the error message into a search engine will often work\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nR treats the hashtag character, #, in a special way; R will not run anything that follows a hashtag on a line. This makes hashtags very useful for adding comments and annotations to your code. Humans will be able to read the comments, but your computer will pass over them. The hashtag is known as the commenting symbol in R.\n\n\n\n\n\n\n\n\nCancelling commands\n\n\n\nSome R commands may take a long time to run. You can cancel a command once it has begun by pressing ctrl + c or by clicking the “stop sign” if it is available in Rstudio. Note that it may also take R a long time to cancel the command.\n\n\n\n2.1.1 An exercise\nThat’s the basic interface for executing R code in RStudio. Think you have it? If so, try doing these simple tasks. If you execute everything correctly, you should end up with the same number that you started with:\n\nChoose any number and add 2 to it.\nMultiply the result by 3.\nSubtract 6 from the answer.\nDivide what you get by 3.\n\n\n10 + 2\n\n[1] 12\n\n12 * 3\n\n[1] 36\n\n36 - 6\n\n[1] 30\n\n30 / 3\n\n[1] 10",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Up and Running with R</span>"
    ]
  },
  {
    "objectID": "020_r_basics.html#objects",
    "href": "020_r_basics.html#objects",
    "title": "\n2  Up and Running with R\n",
    "section": "\n2.2 Objects",
    "text": "2.2 Objects\nNow that you know how to use R, let’s use it to make a virtual die. The : operator from a couple of pages ago gives you a nice way to create a group of numbers from one to six. The : operator returns its results as a vector (we are going to work with vectors in more detail), a one-dimensional set of numbers:\n1:6\n## 1 2 3 4 5 6\nThat’s all there is to how a virtual die looks! But you are not done yet. Running 1:6 generated a vector of numbers for you to see, but it didn’t save that vector anywhere for later use. If we want to use those numbers again, we’ll have to ask your computer to save them somewhere. You can do that by creating an R object.\nR lets you save data by storing it inside an R object. What is an object? Just a name that you can use to call up stored data. For example, you can save data into an object like a or b. Wherever R encounters the object, it will replace it with the data saved inside, like so:\n\na &lt;- 1\na\n\n[1] 1\n\n\n\na + 2\n\n[1] 3\n\n\n\n\n\n\n\n\nWhat just happened?\n\n\n\n\nTo create an R object, choose a name and then use the less-than symbol, &lt;, followed by a minus sign, -, to save data into it. This combination looks like an arrow, &lt;-. R will make an object, give it your name, and store in it whatever follows the arrow. So a &lt;- 1 stores 1 in an object named a.\nWhen you ask R what’s in a, R tells you on the next line.\nYou can use your object in new R commands, too. Since a previously stored the value of 1, you’re now adding 1 to 2.\n\n\n\n\n\n\n\n\n\nAssignment vs expressions\n\n\n\nEverything that you type into the R console can be assigned to one of two categories:\n\nAssignments\nExpressions\n\nAn expression is a command that tells R to do something. For example, 1 + 2 is an expression that tells R to add 1 and 2. When you type an expression into the R console, R will evaluate the expression and return the result. For example, if you type 1 + 2 into the R console, R will return 3. Expressions can have “side effects” but they don’t explicitly result in anything being added to R memory.\n\n5 + 2\n\n[1] 7\n\n28 %% 3\n\n[1] 1\n\n3^2\n\n[1] 9\n\n5 + 4 * 4 + 4 ^ 4 / 10\n\n[1] 46.6\n\n\nWhile using R as a calculator is interesting, to do useful and interesting things, we need to assign values to objects. To create objects, we need to give it a name followed by the assignment operator &lt;- (or, entirely equivalently, =) and the value we want to give it:\n\nweight_kg &lt;- 55\n\n\n\nSo, for another example, the following code would create an object named die that contains the numbers one through six. To see what is stored in an object, just type the object’s name by itself:\n\ndie &lt;- 1:6\ndie\n\n[1] 1 2 3 4 5 6\n\n\nWhen you create an object, the object will appear in the environment pane of RStudio, as shown in Figure 2.2. This pane will show you all of the objects you’ve created since opening RStudio.\n\n\n\n\n\nFigure 2.2: Assignment creates an object in the environment pane.\n\n\nYou can name an object in R almost anything you want, but there are a few rules. First, a name cannot start with a number. Second, a name cannot use some special symbols, like ^, !, $, @, +, -, /, or *:\n\n\nGood names\nNames that cause errors\n\n\n\na\n1trial\n\n\nb\n$\n\n\nFOO\n^mean\n\n\nmy_var\n2nd\n\n\n.day\n!bad\n\n\n\n\n\n\n\n\n\nCapitalization matters\n\n\n\nR is case-sensitive, so name and Name will refer to different objects:\n&gt; Name = 0\n&gt; Name + 1\n[1] 1\n&gt; name + 1\nError: object 'name' not found\nThe error above is a common one!\n\n\nFinally, R will overwrite any previous information stored in an object without asking you for permission. So, it is a good idea to not use names that are already taken:\n\nmy_number &lt;- 1\nmy_number \n\n[1] 1\n\n\n\nmy_number &lt;- 999\nmy_number\n\n[1] 999\n\n\nYou can see which object names you have already used with the function ls:\nls()\nYour environment will contain different names than mine, because you have probably created different objects.\nYou can also see which names you have used by examining RStudio’s environment pane.\nWe now have a virtual die that is stored in the computer’s memory and which has a name that we can use to refer to it. You can access it whenever you like by typing the word die.\nSo what can you do with this die? Quite a lot. R will replace an object with its contents whenever the object’s name appears in a command. So, for example, you can do all sorts of math with the die. Math isn’t so helpful for rolling dice, but manipulating sets of numbers will be your stock and trade as a data scientist. So let’s take a look at how to do that:\n\ndie - 1\n\n[1] 0 1 2 3 4 5\n\ndie / 2\n\n[1] 0.5 1.0 1.5 2.0 2.5 3.0\n\ndie * die\n\n[1]  1  4  9 16 25 36\n\n\nR uses element-wise execution when working with a vector like die. When you manipulate a set of numbers, R will apply the same operation to each element in the set. So for example, when you run die - 1, R subtracts one from each element of die.\nWhen you use two or more vectors in an operation, R will line up the vectors and perform a sequence of individual operations. For example, when you run die * die, R lines up the two die vectors and then multiplies the first element of vector 1 by the first element of vector 2. R then multiplies the second element of vector 1 by the second element of vector 2, and so on, until every element has been multiplied. The result will be a new vector the same length as the first two {Figure 2.3}.\n\n\n\n\n\nFigure 2.3: “When R performs element-wise execution, it matches up vectors and then manipulates each pair of elements independently.”\n\n\nIf you give R two vectors of unequal lengths, R will repeat the shorter vector until it is as long as the longer vector, and then do the math, as shown in Figure 2.4. This isn’t a permanent change–the shorter vector will be its original size after R does the math. If the length of the short vector does not divide evenly into the length of the long vector, R will return a warning message. This behavior is known as vector recycling, and it helps R do element-wise operations:\n\n1:2\n\n[1] 1 2\n\n1:4\n\n[1] 1 2 3 4\n\ndie\n\n[1] 1 2 3 4 5 6\n\ndie + 1:2\n\n[1] 2 4 4 6 6 8\n\ndie + 1:4\n\nWarning in die + 1:4: longer object length is not a multiple of shorter object\nlength\n\n\n[1] 2 4 6 8 6 8\n\n\n\n\n\n\n\nFigure 2.4: “R will repeat a short vector to do element-wise operations with two vectors of uneven lengths.”\n\n\nElement-wise operations are a very useful feature in R because they manipulate groups of values in an orderly way. When you start working with data sets, element-wise operations will ensure that values from one observation or case are only paired with values from the same observation or case. Element-wise operations also make it easier to write your own programs and functions in R.\n\n\n\n\n\n\nElement-wise operations are not matrix operations\n\n\n\nIt is important to know that operations with vectors are not the same that you might expect if you are expecting R to perform “matrix” operations. R can do inner multiplication with the %*% operator and outer multiplication with the %o% operator:\n# Inner product (1*1 + 2*2 + 3*3 + 4*4 + 5*5 + 6*6)\ndie %*% die\n# Outer product\ndie %o% die\n\n\nNow that you can do math with your die object, let’s look at how you could “roll” it. Rolling your die will require something more sophisticated than basic arithmetic; you’ll need to randomly select one of the die’s values. And for that, you will need a function.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Up and Running with R</span>"
    ]
  },
  {
    "objectID": "020_r_basics.html#expressions",
    "href": "020_r_basics.html#expressions",
    "title": "\n2  Up and Running with R\n",
    "section": "\n3.1 Expressions",
    "text": "3.1 Expressions\n\n5 + 2\n28 %% 3\n3^2\n5 + 4 * 4 + 4 ^ 4 / 10\n\nNote that R follows order-of-operations and groupings based on parentheses.\n\n5 + 4 / 9\n(5 + 4) / 9",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Up and Running with R</span>"
    ]
  },
  {
    "objectID": "020_r_basics.html#assignment",
    "href": "020_r_basics.html#assignment",
    "title": "\n2  Up and Running with R\n",
    "section": "\n3.2 Assignment",
    "text": "3.2 Assignment\nWhile using R as a calculator is interesting, to do useful and interesting things, we need to assign values to objects. To create objects, we need to give it a name followed by the assignment operator &lt;- (or, entirely equivalently, =) and the value we want to give it:\n\nweight_kg &lt;- 55 \n\n&lt;- is the assignment operator. Assigns values on the right to objects on the left, it is like an arrow that points from the value to the object. Using an = is equivalent (in nearly all cases). Learn to use &lt;- as it is good programming practice.\nObjects can be given any name such as x, current_temperature, or subject_id (see below). You want your object names to be explicit and not too long. They cannot start with a number (2x is not valid but x2 is). R is case sensitive (e.g., weight_kg is different from Weight_kg). There are some names that cannot be used because they represent the names of fundamental functions in R (e.g., if, else, for, see here for a complete list). In general, even if it’s allowed, it’s best to not use other function names, which we’ll get into shortly (e.g., c, T, mean, data, df, weights). When in doubt, check the help to see if the name is already in use. It’s also best to avoid dots (.) within a variable name as in my.dataset. It is also recommended to use nouns for variable names, and verbs for function names.\nWhen assigning a value to an object, R does not print anything. You can force to print the value by typing the name:\n\nweight_kg\n\n[1] 55\n\n\nNow that R has weight_kg in memory, which R refers to as the “global environment”, we can do arithmetic with it. For instance, we may want to convert this weight in pounds (weight in pounds is 2.2 times the weight in kg).\n\n2.2 * weight_kg\n\n[1] 121\n\n\nWe can also change a variable’s value by assigning it a new one:\n\nweight_kg &lt;- 57.5\n2.2 * weight_kg\n\n[1] 126.5\n\n\nThis means that assigning a value to one variable does not change the values of other variables. For example, let’s store the animal’s weight in pounds in a variable.\n\nweight_lb &lt;- 2.2 * weight_kg\n\nand then change weight_kg to 100.\n\nweight_kg &lt;- 100\n\nWhat do you think is the current content of the object weight_lb, 126.5 or 220?\nYou can see what objects (variables) are stored by viewing the Environment tab in Rstudio. You can also use the ls() function. You can remove objects (variables) with the rm() function. You can do this one at a time or remove several objects at once. You can also use the little broom button in your environment pane to remove everything from your environment.\n\nls()\nrm(weight_lb, weight_kg)\nls()\n\nWhat happens when you type the following, now?\n\nweight_lb # oops! you should get an error because weight_lb no longer exists!",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Up and Running with R</span>"
    ]
  },
  {
    "objectID": "020_r_basics.html#rules-for-names-in-r",
    "href": "020_r_basics.html#rules-for-names-in-r",
    "title": "\n2  Up and Running with R\n",
    "section": "\n3.3 Rules for Names in R",
    "text": "3.3 Rules for Names in R\nR allows users to assign names to objects such as variables, functions, and even dimensions of data. However, these names must follow a few rules.\n\nNames may contain any combination of letters, numbers, underscore, and “.”\nNames may not start with numbers, underscore.\nR names are case-sensitive.\n\nExamples of valid R names include:\npi\nx\ncamelCaps\nmy_stuff\nMY_Stuff\nthis.is.the.name.of.the.man\nABC123\nabc1234asdf\n.hi",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Up and Running with R</span>"
    ]
  },
  {
    "objectID": "030_r_functions.html",
    "href": "030_r_functions.html",
    "title": "\n3  Functions\n",
    "section": "",
    "text": "3.0.1 Sample with Replacement\nIf you set size = 2, you can almost simulate a pair of dice. Before we run that code, think for a minute why that might be the case. sample will return two numbers, one for each die:\nsample(die, size = 2)\n\n[1] 2 4\nI said this “almost” works because this method does something funny. If you use it many times, you’ll notice that the second die never has the same value as the first die, which means you’ll never roll something like a pair of threes or snake eyes. What is going on?\nBy default, sample builds a sample without replacement. To see what this means, imagine that sample places all of the values of die in a jar or urn. Then imagine that sample reaches into the jar and pulls out values one by one to build its sample. Once a value has been drawn from the jar, sample sets it aside. The value doesn’t go back into the jar, so it cannot be drawn again. So if sample selects a six on its first draw, it will not be able to select a six on the second draw; six is no longer in the jar to be selected. Although sample creates its sample electronically, it follows this seemingly physical behavior.\nOne side effect of this behavior is that each draw depends on the draws that come before it. In the real world, however, when you roll a pair of dice, each die is independent of the other. If the first die comes up six, it does not prevent the second die from coming up six. In fact, it doesn’t influence the second die in any way whatsoever. You can recreate this behavior in sample by adding the argument replace = TRUE:\nsample(die, size = 2, replace = TRUE)\n\n[1] 5 5\nThe argument replace = TRUE causes sample to sample with replacement. Our jar example provides a good way to understand the difference between sampling with replacement and without. When sample uses replacement, it draws a value from the jar and records the value. Then it puts the value back into the jar. In other words, sample replaces each value after each draw. As a result, sample may select the same value on the second draw. Each value has a chance of being selected each time. It is as if every draw were the first draw.\nSampling with replacement is an easy way to create independent random samples. Each value in your sample will be a sample of size one that is independent of the other values. This is the correct way to simulate a pair of dice:\nsample(die, size = 2, replace = TRUE)\n\n[1] 6 5\nCongratulate yourself; you’ve just run your first simulation in R! You now have a method for simulating the result of rolling a pair of dice. If you want to add up the dice, you can feed your result straight into the sum function:\ndice &lt;- sample(die, size = 2, replace = TRUE)\ndice\n\n[1] 2 2\n\nsum(dice)\n\n[1] 4\nWhat would happen if you call dice multiple times? Would R generate a new pair of dice values each time? Let’s give it a try:\ndice\n\n[1] 2 2\n\ndice\n\n[1] 2 2\n\ndice\n\n[1] 2 2\nThe name dice refers to a vector of two numbers. Calling more than once does not change the favlue. Each time you call dice, R will show you the result of that one time you called sample and saved the output to dice. R won’t rerun sample(die, 2, replace = TRUE) to create a new roll of the dice. Once you save a set of results to an R object, those results do not change.\nHowever, it would be convenient to have an object that can re-roll the dice whenever you call it. You can make such an object by writing your own R function.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Functions</span>"
    ]
  },
  {
    "objectID": "030_r_functions.html#write-functions",
    "href": "030_r_functions.html#write-functions",
    "title": "\n3  Functions\n",
    "section": "\n3.1 Writing Your Own Functions",
    "text": "3.1 Writing Your Own Functions\nTo recap, you already have working R code that simulates rolling a pair of dice:\n\ndie &lt;- 1:6\ndice &lt;- sample(die, size = 2, replace = TRUE)\nsum(dice)\n\n[1] 7\n\n\nYou can retype this code into the console anytime you want to re-roll your dice. However, this is an awkward way to work with the code. It would be easier to use your code if you wrapped it into its own function, which is exactly what we’ll do now. We’re going to write a function named roll that you can use to roll your virtual dice. When you’re finished, the function will work like this: each time you call roll(), R will return the sum of rolling two dice:\nroll()\n## 8 \n\nroll()\n## 3\n\nroll()\n## 7\nFunctions may seem mysterious or fancy, but they are just another type of R object. Instead of containing data, they contain code. This code is stored in a special format that makes it easy to reuse the code in new situations. You can write your own functions by recreating this format.\n\n3.1.1 The Function Constructor\nEvery function in R has three basic parts: a name, a body of code, and a set of arguments. To make your own function, you need to replicate these parts and store them in an R object, which you can do with the function function. To do this, call function() and follow it with a pair of braces, {}:\n\nmy_function &lt;- function() {}\n\nThis function, as written, doesn’t do anything (yet). However, it is a valid function. You can call it by typing its name followed by an open and closed parenthesis:\n\nmy_function()\n\nNULL\n\n\nfunction will build a function out of whatever R code you place between the braces. For example, you can turn your dice code into a function by calling:\n\nroll &lt;- function() {\n    die &lt;- 1:6\n    dice &lt;- sample(die, size = 2, replace = TRUE)\n    sum(dice)\n}\n\n\n\n\n\n\n\nIndentation and readability\n\n\n\nNotice each line of code between the braces is indented. This makes the code easier to read but has no impact on how the code runs. R ignores spaces and line breaks and executes one complete expression at a time. Note that in other languages like python, spacing is extremely important and part of the language.\n\n\nJust hit the Enter key between each line after the first brace, {. R will wait for you to type the last brace, }, before it responds.\nDon’t forget to save the output of function to an R object. This object will become your new function. To use it, write the object’s name followed by an open and closed parenthesis:\n\nroll()\n\n[1] 10\n\n\nYou can think of the parentheses as the “trigger” that causes R to run the function. If you type in a function’s name without the parentheses, R will show you the code that is stored inside the function. If you type in the name with the parentheses, R will run that code:\n\nroll\n\nfunction() {\n    die &lt;- 1:6\n    dice &lt;- sample(die, size = 2, replace = TRUE)\n    sum(dice)\n}\n\nroll()\n\n[1] 3\n\n\nThe code that you place inside your function is known as the body of the function. When you run a function in R, R will execute all of the code in the body and then return the result of the last line of code. If the last line of code doesn’t return a value, neither will your function, so you want to ensure that your final line of code returns a value. One way to check this is to think about what would happen if you ran the body of code line by line in the command line. Would R display a result after the last line, or would it not?\nHere’s some code that would display a result:\ndice\n1 + 1\nsqrt(2)\nAnd here’s some code that would not:\ndice &lt;- sample(die, size = 2, replace = TRUE)\ntwo &lt;- 1 + 1\na &lt;- sqrt(2)\nAgain, this is just showing the distinction between expressions and assignments.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Functions</span>"
    ]
  },
  {
    "objectID": "030_r_functions.html#arguments",
    "href": "030_r_functions.html#arguments",
    "title": "\n3  Functions\n",
    "section": "\n3.2 Arguments",
    "text": "3.2 Arguments\nWhat if we removed one line of code from our function and changed the name die to bones (just a name–don’t think of it as important), like this?\n\nroll2 &lt;- function() {\n    dice &lt;- sample(bones, size = 2, replace = TRUE)\n    sum(dice)\n}\n\nNow I’ll get an error when I run the function. The function needs the object bones to do its job, but there is no object named bones to be found (you can check by typing ls() which will show you the names in the environment, or memory).\nroll2()\n## Error in sample(bones, size = 2, replace = TRUE) : \n##   object 'bones' not found\nYou can supply bones when you call roll2 if you make bones an argument of the function. To do this, put the name bones in the parentheses that follow function when you define roll2:\n\nroll2 &lt;- function(bones) {\n    dice &lt;- sample(bones, size = 2, replace = TRUE)\n    sum(dice)\n}\n\nNow roll2 will work as long as you supply bones when you call the function. You can take advantage of this to roll different types of dice each time you call roll2.\nRemember, we’re rolling pairs of dice:\n\nroll2(bones = 1:4)\n\n[1] 5\n\nroll2(bones = 1:6)\n\n[1] 7\n\nroll2(1:20)\n\n[1] 33\n\n\nNotice that roll2 will still give an error if you do not supply a value for the bones argument when you call roll2:\nroll2()\n## Error in sample(bones, size = 2, replace = TRUE) : \n##   argument \"bones\" is missing, with no default\nYou can prevent this error by giving the bones argument a default value. To do this, set bones equal to a value when you define roll2:\n\nroll2 &lt;- function(bones = 1:6) {\n    dice &lt;- sample(bones, size = 2, replace = TRUE)\n    sum(dice)\n}\n\nNow you can supply a new value for bones if you like, and roll2 will use the default if you do not:\n\nroll2()\n\n[1] 11\n\n\nYou can give your functions as many arguments as you like. Just list their names, separated by commas, in the parentheses that follow function. When the function is run, R will replace each argument name in the function body with the value that the user supplies for the argument. If the user does not supply a value, R will replace the argument name with the argument’s default value (if you defined one).\nTo summarize, function helps you construct your own R functions. You create a body of code for your function to run by writing code between the braces that follow function. You create arguments for your function to use by supplying their names in the parentheses that follow function. Finally, you give your function a name by saving its output to an R object, as shown in Figure 3.2.\nOnce you’ve created your function, R will treat it like every other function in R. Think about how useful this is. Have you ever tried to create a new Excel option and add it to Microsoft’s menu bar? Or a new slide animation and add it to Powerpoint’s options? When you work with a programming language, you can do these types of things. As you learn to program in R, you will be able to create new, customized, reproducible tools for yourself whenever you like.\n\n\n\n\n\nFigure 3.2: “Every function in R has the same parts, and you can use function to create these parts. Assign the result to a name, so you can call the function later.”",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Functions</span>"
    ]
  },
  {
    "objectID": "chatbots.html",
    "href": "chatbots.html",
    "title": "4  Chatbots as Learning Tools",
    "section": "",
    "text": "ChatGPT, developed by OpenAI, and Claude, developed by Anthropic, are advanced language models that leverage deep learning techniques to understand and generate human-like text. At their core, these chatbots operate using a variant of the Transformer architecture, which enable them to process and generate text based on the patterns and structures they learn from vast amounts of training data. These models1 excels in natural language understanding and generation tasks, making them incredibly versatile tools for a wide range of applications beyond simple chat interactions.\n1 Foundation models are a recent development in AI. These models are developed from algorithms designed to optimize for generality and versatility of output. They are based on large-scale neural networks that are often trained on a broad range of data sources and large amounts of data to accomplish a wide range of downstream tasks, including some for which they were not specifically developed and trained.In the context of programming and coding, these chatbots serve as valuable assistants by providing explanations, examples, and guidance related to programming languages like R. Users can interact with a chatbot by posing questions or requesting code snippets, which they generate based on their understanding of the input and their extensive training data. For instance, users can inquire about specific syntax rules, algorithm implementations, or even debugging tips, and chatbots can respond with clear explanations and relevant examples. This capability makes them particularly useful for learners and developers seeking quick insights or clarification on complex programming concepts.\nMoreover, chatbots can facilitate learning and problem-solving by offering personalized responses tailored to the user’s queries. Their ability to generate coherent and contextually relevant text allows them to simulate a dialogue where they guides users through coding challenges or help them understand intricate programming concepts more intuitively. This makes chatbots not only a powerful tool for acquiring programming knowledge but also a supportive companion in the journey of mastering programming languages like R.\nIn this tutorial, we will explore how chatbots like ChatGPT and Claude can be leveraged as learning tools for programming in R. We will discuss their features, capabilities, and potential applications in the context of programming education. By the end of this tutorial, you will have a better understanding of how chatbots can enhance the learning experience and support your programming endeavors.\n\nFeatures of Chatbots\nChatbots like ChatGPT and Claude offer a range of features that make them valuable learning tools for programming in R. Some of the key features include:\n\nNatural Language Understanding: Chatbots can interpret and respond to user queries in natural language, making interactions more intuitive and user-friendly.\nCode Generation: Chatbots can generate code snippets, examples, and explanations based on the user’s input, helping users understand and implement programming concepts.\nPersonalized Responses: Chatbots can provide personalized responses tailored to the user’s queries, enhancing the learning experience and engagement.\nInteractive Learning: Chatbots can engage users in interactive learning experiences, guiding them through coding challenges and providing real-time feedback.\n24/7 Availability: Chatbots are available round the clock, allowing users to seek assistance and guidance at any time, making them convenient learning companions.\nExtensive Knowledge Base: Chatbots have access to vast amounts of training data and information, enabling them to provide accurate and up-to-date responses to user queries.\nScalability: Chatbots can scale to accommodate a large number of users simultaneously, making them suitable for both individual learners and educational institutions.\nFeedback and Evaluation: Chatbots can provide feedback and evaluation on user-generated code, helping users identify and correct errors in their programming assignments.\nMultimodal Capabilities: Chatbots can support multimodal interactions, such as text, voice, and visual inputs, enhancing the user experience and accessibility.\nContinuous Learning: Chatbots can continuously learn and improve their responses based on user interactions and feedback, ensuring that they stay relevant and up-to-date.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Chatbots as Learning Tools</span>"
    ]
  },
  {
    "objectID": "data_structures_intro.html",
    "href": "data_structures_intro.html",
    "title": "\n5  Vectors\n",
    "section": "",
    "text": "5.1 Creating vectors\nCharacter vectors (also sometimes called “string” vectors) are entered with each value surrounded by single or double quotes; either is acceptable, but they must match. They are always displayed by R with double quotes. Here are some examples of creating vectors:\n# examples of vectors\nc('hello','world')\n\n[1] \"hello\" \"world\"\n\nc(1,3,4,5,1,2)\n\n[1] 1 3 4 5 1 2\n\nc(1.12341e7,78234.126)\n\n[1] 11234100.00    78234.13\n\nc(TRUE,FALSE,TRUE,TRUE)\n\n[1]  TRUE FALSE  TRUE  TRUE\n\n# note how in the next case the TRUE is converted to \"TRUE\"\n# with quotes around it.\nc(TRUE,'hello')\n\n[1] \"TRUE\"  \"hello\"\nWe can also create vectors as “regular sequences” of numbers. For example:\n# create a vector of integers from 1 to 10\nx = 1:10\n# and backwards\nx = 10:1\nThe seq function can create more flexible regular sequences.\n# create a vector of numbers from 1 to 4 skipping by 0.3\ny = seq(1,4,0.3)\nAnd creating a new vector by concatenating existing vectors is possible, as well.\n# create a sequence by concatenating two other sequences\nz = c(y,x)\nz\n\n [1]  1.0  1.3  1.6  1.9  2.2  2.5  2.8  3.1  3.4  3.7  4.0 10.0  9.0  8.0  7.0\n[16]  6.0  5.0  4.0  3.0  2.0  1.0",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Vectors</span>"
    ]
  },
  {
    "objectID": "data_structures_intro.html#vector-operations",
    "href": "data_structures_intro.html#vector-operations",
    "title": "\n5  Vectors\n",
    "section": "\n5.2 Vector Operations",
    "text": "5.2 Vector Operations\nOperations on a single vector are typically done element-by-element. For example, we can add 2 to a vector, 2 is added to each element of the vector and a new vector of the same length is returned.\n\nx = 1:10\nx + 2\n\n [1]  3  4  5  6  7  8  9 10 11 12\n\n\nIf the operation involves two vectors, the following rules apply. If the vectors are the same length: R simply applies the operation to each pair of elements.\n\nx + x\n\n [1]  2  4  6  8 10 12 14 16 18 20\n\n\nIf the vectors are different lengths, but one length a multiple of the other, R reuses the shorter vector as needed.\n\nx = 1:10\ny = c(1,2)\nx * y\n\n [1]  1  4  3  8  5 12  7 16  9 20\n\n\nIf the vectors are different lengths, but one length not a multiple of the other, R reuses the shorter vector as needed and delivers a warning.\n\nx = 1:10\ny = c(2,3,4)\nx * y\n\nWarning in x * y: longer object length is not a multiple of shorter object\nlength\n\n\n [1]  2  6 12  8 15 24 14 24 36 20\n\n\nTypical operations include multiplication (“*”), addition, subtraction, division, exponentiation (“^”), but many operations in R operate on vectors and are then called “vectorized”.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Vectors</span>"
    ]
  },
  {
    "objectID": "data_structures_intro.html#logical-vectors",
    "href": "data_structures_intro.html#logical-vectors",
    "title": "\n5  Vectors\n",
    "section": "\n5.3 Logical Vectors",
    "text": "5.3 Logical Vectors\nLogical vectors are vectors composed on only the values TRUE and FALSE. Note the all-upper-case and no quotation marks.\n\na = c(TRUE,FALSE,TRUE)\n\n# we can also create a logical vector from a numeric vector\n# 0 = false, everything else is 1\nb = c(1,0,217)\nd = as.logical(b)\nd\n\n[1]  TRUE FALSE  TRUE\n\n# test if a and d are the same at every element\nall.equal(a,d)\n\n[1] TRUE\n\n# We can also convert from logical to numeric\nas.numeric(a)\n\n[1] 1 0 1\n\n\n\n5.3.1 Logical Operators\nSome operators like &lt;, &gt;, ==, &gt;=, &lt;=, != can be used to create logical vectors.\n\n# create a numeric vector\nx = 1:10\n# testing whether x &gt; 5 creates a logical vector\nx &gt; 5\n\n [1] FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE\n\nx &lt;= 5\n\n [1]  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE\n\nx != 5\n\n [1]  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE\n\nx == 5\n\n [1] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE\n\n\nWe can also assign the results to a variable:\n\ny = (x == 5)\ny\n\n [1] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Vectors</span>"
    ]
  },
  {
    "objectID": "data_structures_intro.html#indexing-vectors",
    "href": "data_structures_intro.html#indexing-vectors",
    "title": "\n5  Vectors\n",
    "section": "\n5.4 Indexing Vectors",
    "text": "5.4 Indexing Vectors\nIn R, an index is used to refer to a specific element or set of elements in an vector (or other data structure). [R uses [ and ] to perform indexing, although other approaches to getting subsets of larger data structures are common in R.\n\nx = seq(0,1,0.1)\n# create a new vector from the 4th element of x\nx[4]\n\n[1] 0.3\n\n\nWe can even use other vectors to perform the “indexing”.\n\nx[c(3,5,6)]\n\n[1] 0.2 0.4 0.5\n\ny = 3:6\nx[y]\n\n[1] 0.2 0.3 0.4 0.5\n\n\nCombining the concept of indexing with the concept of logical vectors results in a very power combination.\n\n# use help('rnorm') to figure out what is happening next\nmyvec = rnorm(10)\n\n# create logical vector that is TRUE where myvec is &gt;0.25\ngt1 = (myvec &gt; 0.25)\nsum(gt1)\n\n[1] 5\n\n# and use our logical vector to create a vector of myvec values that are &gt;0.25\nmyvec[gt1]\n\n[1] 0.7831174 0.5358207 0.8832050 0.4218819 0.9551676\n\n# or &lt;=0.25 using the logical \"not\" operator, \"!\"\nmyvec[!gt1]\n\n[1] -0.2431059  0.1258777 -0.1795923 -1.6136884 -1.3488314\n\n# shorter, one line approach\nmyvec[myvec &gt; 0.25]\n\n[1] 0.7831174 0.5358207 0.8832050 0.4218819 0.9551676",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Vectors</span>"
    ]
  },
  {
    "objectID": "data_structures_intro.html#character-vectors-a.k.a.-strings",
    "href": "data_structures_intro.html#character-vectors-a.k.a.-strings",
    "title": "\n5  Vectors\n",
    "section": "\n5.5 Character Vectors, A.K.A. Strings",
    "text": "5.5 Character Vectors, A.K.A. Strings\nR uses the paste function to concatenate strings.\n\npaste(\"abc\",\"def\")\n\n[1] \"abc def\"\n\npaste(\"abc\",\"def\",sep=\"THISSEP\")\n\n[1] \"abcTHISSEPdef\"\n\npaste0(\"abc\",\"def\")\n\n[1] \"abcdef\"\n\n## [1] \"abcdef\"\npaste(c(\"X\",\"Y\"),1:10)\n\n [1] \"X 1\"  \"Y 2\"  \"X 3\"  \"Y 4\"  \"X 5\"  \"Y 6\"  \"X 7\"  \"Y 8\"  \"X 9\"  \"Y 10\"\n\npaste(c(\"X\",\"Y\"),1:10,sep=\"_\")\n\n [1] \"X_1\"  \"Y_2\"  \"X_3\"  \"Y_4\"  \"X_5\"  \"Y_6\"  \"X_7\"  \"Y_8\"  \"X_9\"  \"Y_10\"\n\n\nWe can count the number of characters in a string.\n\nnchar('abc')\n\n[1] 3\n\nnchar(c('abc','d',123456))\n\n[1] 3 1 6\n\n\nPulling out parts of strings is also sometimes useful.\n\nsubstr('This is a good sentence.',start=10,stop=15)\n\n[1] \" good \"\n\n\nAnother common operation is to replace something in a string with something (a find-and-replace).\n\nsub('This','That','This is a good sentence.')\n\n[1] \"That is a good sentence.\"\n\n\nWhen we want to find all strings that match some other string, we can use grep, or “grab regular expression”.\n\ngrep('bcd',c('abcdef','abcd','bcde','cdef','defg'))\n\n[1] 1 2 3\n\ngrep('bcd',c('abcdef','abcd','bcde','cdef','defg'),value=TRUE)\n\n[1] \"abcdef\" \"abcd\"   \"bcde\"",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Vectors</span>"
    ]
  },
  {
    "objectID": "data_structures_intro.html#missing-values-aka-na",
    "href": "data_structures_intro.html#missing-values-aka-na",
    "title": "\n5  Vectors\n",
    "section": "\n5.6 Missing Values, AKA “NA”",
    "text": "5.6 Missing Values, AKA “NA”\nR has a special value, “NA”, that represents a “missing” value, or Not Available, in a vector or other data structure. Here, we just create a vector to experiment.\n\nx = 1:5\nx\n\n[1] 1 2 3 4 5\n\nlength(x)\n\n[1] 5\n\n\n\nis.na(x)\n\n[1] FALSE FALSE FALSE FALSE FALSE\n\nx[2] = NA\nx\n\n[1]  1 NA  3  4  5\n\n\nThe length of x is unchanged, but there is one value that is marked as “missing” by virtue of being NA.\n\nlength(x)\n\n[1] 5\n\nis.na(x)\n\n[1] FALSE  TRUE FALSE FALSE FALSE\n\n\nWe can remove NA values by using indexing. In the following, is.na(x) returns a logical vector the length of x. The ! is the logical NOT operator and converts TRUE to FALSE and vice-versa.\n\nx[!is.na(x)]\n\n[1] 1 3 4 5",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Vectors</span>"
    ]
  },
  {
    "objectID": "data_structures_intro.html#factors",
    "href": "data_structures_intro.html#factors",
    "title": "\n5  Vectors\n",
    "section": "\n5.7 Factors",
    "text": "5.7 Factors\nA factor is a special type of vector, normally used to hold a categorical variable–such as smoker/nonsmoker, state of residency, zipcode–in many statistical functions. Such vectors have class “factor”. Factors are primarily used in Analysis of Variance (ANOVA) or other situations when “categories” are needed. When a factor is used as a predictor variable, the corresponding indicator variables are created (more later).\nNote of caution that factors in R often appear to be character vectors when printed, but you will notice that they do not have double quotes around them. They are stored in R as numbers with a key name, so sometimes you will note that the factor behaves like a numeric vector.\n\n# create the character vector\ncitizen&lt;-c(\"uk\",\"us\",\"no\",\"au\",\"uk\",\"us\",\"us\",\"no\",\"au\") \n\n# convert to factor\ncitizenf&lt;-factor(citizen)                                \ncitizen             \n\n[1] \"uk\" \"us\" \"no\" \"au\" \"uk\" \"us\" \"us\" \"no\" \"au\"\n\ncitizenf\n\n[1] uk us no au uk us us no au\nLevels: au no uk us\n\n# convert factor back to character vector\nas.character(citizenf)\n\n[1] \"uk\" \"us\" \"no\" \"au\" \"uk\" \"us\" \"us\" \"no\" \"au\"\n\n# convert to numeric vector\nas.numeric(citizenf)\n\n[1] 3 4 2 1 3 4 4 2 1\n\n\nR stores many data structures as vectors with “attributes” and “class” (just so you have seen this).\n\nattributes(citizenf)\n\n$levels\n[1] \"au\" \"no\" \"uk\" \"us\"\n\n$class\n[1] \"factor\"\n\nclass(citizenf)\n\n[1] \"factor\"\n\n# note that after unclassing, we can see the \n# underlying numeric structure again\nunclass(citizenf)\n\n[1] 3 4 2 1 3 4 4 2 1\nattr(,\"levels\")\n[1] \"au\" \"no\" \"uk\" \"us\"\n\n\nTabulating factors is a useful way to get a sense of the “sample” set available.\n\ntable(citizenf)\n\ncitizenf\nau no uk us \n 2  2  2  3",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Vectors</span>"
    ]
  },
  {
    "objectID": "dataframes_intro.html",
    "href": "dataframes_intro.html",
    "title": "\n6  Data Frames\n",
    "section": "",
    "text": "6.1 Dataset\nThe insurance dataset is described in the book Machine Learning with R by Brett Lantz. The dataset describes medical information and costs billed by health insurance companies for 1338 individuals in 2013, as compiled by the United States Census Bureau.\nVariables include:\nWe will load the data directly from the web, but you can also download the data from the link at github1.\ninsurance_url &lt;- \"https://raw.githubusercontent.com/stedy/Machine-Learning-with-R-datasets/master/insurance.csv\"\ninsurance &lt;- read.csv(insurance_url)\nExplore the dataset a bit to understand its structure and contents. For example, you can use the head() function to view the first few rows of the dataset.\nhead(insurance)\n\n  age    sex    bmi children smoker    region   charges\n1  19 female 27.900        0    yes southwest 16884.924\n2  18   male 33.770        1     no southeast  1725.552\n3  28   male 33.000        3     no southeast  4449.462\n4  33   male 22.705        0     no northwest 21984.471\n5  32   male 28.880        0     no northwest  3866.855\n6  31 female 25.740        0     no southeast  3756.622\nAnd you can examine the dimensions of the dataset using the dim(), which returns the number of rows and columns in the dataset, the ncol() function, which returns the number of columns, and the nrow() function, which returns the number of rows.\ndim(insurance)\n\n[1] 1338    7\n\nncol(insurance)\n\n[1] 7\n\nnrow(insurance)\n\n[1] 1338\nNote that with the dim() function, the number of rows is given first, followed by the number of columns.\nNotice that, while the BMI variable represents a measure of a person’s weight relative to their height, there is no discrete variable for whether a person is obese or not. The World Health Organization (WHO) defines obesity as a BMI greater than or equal to 30. We can create a new variable, obese, that indicates whether a person is obese based on their BMI.\ninsurance$obese &lt;- ifelse(insurance$bmi &gt;= 30, \"obese\", \"not obese\")\nIf we examine the dataset again, we can see that the new variable obese has been added to the dataset.\nhead(insurance)\n\n  age    sex    bmi children smoker    region   charges     obese\n1  19 female 27.900        0    yes southwest 16884.924 not obese\n2  18   male 33.770        1     no southeast  1725.552     obese\n3  28   male 33.000        3     no southeast  4449.462     obese\n4  33   male 22.705        0     no northwest 21984.471 not obese\n5  32   male 28.880        0     no northwest  3866.855 not obese\n6  31 female 25.740        0     no southeast  3756.622 not obese",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Data Frames</span>"
    ]
  },
  {
    "objectID": "dataframes_intro.html#dataset",
    "href": "dataframes_intro.html#dataset",
    "title": "\n6  Data Frames\n",
    "section": "",
    "text": "age\n\nage of primary beneficiary\n\n\n\nsex\n\ninsurance contractor gender, female, male\n\n\n\nbmi\n\nBody mass index, providing an understanding of body, weights that are relatively high or low relative to height, objective index of body weight (kg / m ^ 2) using the ratio of height to weight, ideally 18.5 to 24.9\n\n\n\nchildren\n\nNumber of children covered by health insurance / Number of dependents\n\n\n\nsmoker\n\nSmoking status\n\n\n\nregion\n\nthe beneficiary’s residential area in the US, northeast, southeast, southwest, northwest.\n\n\n\ncharges\n\nIndividual medical costs billed by health insurance\n\n\n\n\n1 Insurance data csv file, https://raw.githubusercontent.com/stedy/Machine-Learning-with-R-datasets/master/insurance.csv",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Data Frames</span>"
    ]
  },
  {
    "objectID": "dataframes_intro.html#inspecting-data.frames",
    "href": "dataframes_intro.html#inspecting-data.frames",
    "title": "\n6  Data Frames\n",
    "section": "\n6.2 Inspecting data.frames",
    "text": "6.2 Inspecting data.frames\nThere are a few functions that are useful for inspecting the contents of a data.frame:\n\nOverviews of content\n\n\nhead() to show first few rows\n\ntail() to show last few rows\n\n\nSize\n\n\ndim() for dimensions (rows, columns)\nnrow()\nncol()\n\nobject.size() for power users interested in the memory used to store an object\n\n\nData and attribute summaries\n\n\ncolnames() to get the names of the columns\n\nrownames() to get the “names” of the rows–may not be present\n\nsummary() to get per-column summaries of the data in the data.frame.\n\n\n\n\n# Show the first few rows\nhead(insurance)\n\n  age    sex    bmi children smoker    region   charges     obese\n1  19 female 27.900        0    yes southwest 16884.924 not obese\n2  18   male 33.770        1     no southeast  1725.552     obese\n3  28   male 33.000        3     no southeast  4449.462     obese\n4  33   male 22.705        0     no northwest 21984.471 not obese\n5  32   male 28.880        0     no northwest  3866.855 not obese\n6  31 female 25.740        0     no southeast  3756.622 not obese\n\n# Show the last few rows\ntail(insurance)\n\n     age    sex   bmi children smoker    region   charges     obese\n1333  52 female 44.70        3     no southwest 11411.685     obese\n1334  50   male 30.97        3     no northwest 10600.548     obese\n1335  18 female 31.92        0     no northeast  2205.981     obese\n1336  18 female 36.85        0     no southeast  1629.833     obese\n1337  21 female 25.80        0     no southwest  2007.945 not obese\n1338  61 female 29.07        0    yes northwest 29141.360 not obese\n\n# Get the dimensions of the data.frame\ndim(insurance)\n\n[1] 1338    8\n\n# Get the number of rows and columns\nnrow(insurance)\n\n[1] 1338\n\nncol(insurance)\n\n[1] 8\n\n# Get the names of the columns\ncolnames(insurance)\n\n[1] \"age\"      \"sex\"      \"bmi\"      \"children\" \"smoker\"   \"region\"   \"charges\" \n[8] \"obese\"   \n\n# Basic summary of the data\nsummary(insurance)\n\n      age            sex                 bmi           children    \n Min.   :18.00   Length:1338        Min.   :15.96   Min.   :0.000  \n 1st Qu.:27.00   Class :character   1st Qu.:26.30   1st Qu.:0.000  \n Median :39.00   Mode  :character   Median :30.40   Median :1.000  \n Mean   :39.21                      Mean   :30.66   Mean   :1.095  \n 3rd Qu.:51.00                      3rd Qu.:34.69   3rd Qu.:2.000  \n Max.   :64.00                      Max.   :53.13   Max.   :5.000  \n    smoker             region             charges         obese          \n Length:1338        Length:1338        Min.   : 1122   Length:1338       \n Class :character   Class :character   1st Qu.: 4740   Class :character  \n Mode  :character   Mode  :character   Median : 9382   Mode  :character  \n                                       Mean   :13270                     \n                                       3rd Qu.:16640                     \n                                       Max.   :63770                     \n\n\nIn RStudio, there is an additional function, View() (note the capital “V”) that opens the first 1000 rows (default) in the RStudio window, akin to a spreadsheet view.\n\nView(insurance)",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Data Frames</span>"
    ]
  },
  {
    "objectID": "dataframes_intro.html#accessing-variables-columns-and-subsetting",
    "href": "dataframes_intro.html#accessing-variables-columns-and-subsetting",
    "title": "\n6  Data Frames\n",
    "section": "\n6.3 Accessing variables (columns) and subsetting",
    "text": "6.3 Accessing variables (columns) and subsetting\nIn R, data.frames can be subset similarly to other two-dimensional data structures. The [ in R is used to denote subsetting of any kind. When working with two-dimensional data, we need two values inside the [ ] to specify the details. The specification is [rows, columns]. For example, to get the first three rows of insurance, use:\n\ninsurance[1:3, ]\n\n  age    sex   bmi children smoker    region   charges     obese\n1  19 female 27.90        0    yes southwest 16884.924 not obese\n2  18   male 33.77        1     no southeast  1725.552     obese\n3  28   male 33.00        3     no southeast  4449.462     obese\n\n\nNote how the second number, the columns, is blank. R takes that to mean “all the columns”. Similarly, we can combine rows and columns specification arbitrarily.\n\ninsurance[1:3, 1:3]\n\n  age    sex   bmi\n1  19 female 27.90\n2  18   male 33.77\n3  28   male 33.00\n\n\nBecause selecting a single variable, or column, is such a common operation, there are two shortcuts for doing so with data.frames. The first, the $ operator works like so:\n\n# Look at the column names, just to refresh memory\ncolnames(insurance)\n\n[1] \"age\"      \"sex\"      \"bmi\"      \"children\" \"smoker\"   \"region\"   \"charges\" \n[8] \"obese\"   \n\n# Note that I am using \"head\" here to limit the output\nhead(insurance$age)\n\n[1] 19 18 28 33 32 31\n\n# What is the actual length of \"symbol\"?\nlength(insurance$age)\n\n[1] 1338\n\n\nThe second is related to the fact that, in R, data.frames are also lists. We subset a list by using [[]] notation. To get the second column of insurance, we can use:\n\nhead(insurance[[2]])\n\n[1] \"female\" \"male\"   \"male\"   \"male\"   \"male\"   \"female\"\n\n\nAlternatively, we can use the column name:\n\nhead(insurance[[\"age\"]])\n\n[1] 19 18 28 33 32 31\n\n\n\n6.3.1 Some data exploration\nThere are a couple of columns that include numeric values. Which columns are numeric?\n\nclass(insurance$age)\n\n[1] \"integer\"\n\nclass(insurance$obese)\n\n[1] \"character\"\n\nclass(insurance$children)\n\n[1] \"integer\"\n\n\n\nlibrary(gridExtra)\nlibrary(grid)\nlibrary(dplyr)\n\n\nAttaching package: 'dplyr'\n\n\nThe following object is masked from 'package:gridExtra':\n\n    combine\n\n\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n\n\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n\n# Original DataFrame\ndf &lt;- data.frame(\n    id = c(1, 2, 3, 4, 5),\n    name = c(\"Alice\", \"Bob\", \"Carol\", \"David\", \"Eve\"),\n    age = c(23, 25, 22, 24, 23),\n    score = c(88, 95, 78, 92, 85),\n    city = c(\"New York\", \"Chicago\", \"Boston\", \"Seattle\", \"Austin\")\n)\n\n# Filter\ndf_filtered &lt;- df %&gt;% filter(age &gt; 23)\n\n# Select\ndf_selected &lt;- df_filtered %&gt;% select(name, score)\n\n# Mutate\ndf_mutated &lt;- df_selected %&gt;% mutate(score_scaled = score / 100)\n\n# Arrange\ndf_arranged &lt;- df_mutated %&gt;% arrange(desc(score))\n\n# Summarize\ndf_grouped &lt;- df %&gt;%\n    group_by(city) %&gt;%\n    summarize(avg_score = mean(score))\n\n# Function to create table grobs\ncreate_table_grob &lt;- function(df, title) {\n    table_grob &lt;- tableGrob(df)\n    title_grob &lt;- textGrob(title, gp = gpar(fontsize = 16, fontface = \"bold\"))\n    padding &lt;- unit(0.5, \"line\")\n    table_grob &lt;- gtable::gtable_add_rows(table_grob, heights = grobHeight(title_grob) + padding, pos = 0)\n    table_grob &lt;- gtable::gtable_add_grob(table_grob, list(title_grob), 1, 1, 1, ncol(table_grob))\n    table_grob\n}\n\n# Creating table grobs\noriginal_grob &lt;- create_table_grob(df, \"Original DataFrame\")\nfiltered_grob &lt;- create_table_grob(df_filtered, \"Filtered (age &gt; 23)\")\nselected_grob &lt;- create_table_grob(df_selected, \"Selected (name, score)\")\nmutated_grob &lt;- create_table_grob(df_mutated, \"Mutated (score_scaled)\")\narranged_grob &lt;- create_table_grob(df_arranged, \"Arranged (by score)\")\nsummarized_grob &lt;- create_table_grob(df_grouped, \"Summarized (avg score by city)\")\n\n# Arrange tables in a grid\ngrid.arrange(\n    original_grob, filtered_grob,\n    selected_grob, mutated_grob,\n    arranged_grob, summarized_grob,\n    nrow = 6\n)",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Data Frames</span>"
    ]
  },
  {
    "objectID": "ggplot.html",
    "href": "ggplot.html",
    "title": "\n7  Plotting with ggplot2\n",
    "section": "",
    "text": "7.1 Data\nThe first step in creating a ggplot2 plot is to specify the data to be visualized. The data should be in a tidy format (Wickham (2014)), with each row representing an observation and each column representing a variable. The insurance dataset is described in the book Machine Learning with R by Brett Lantz. The dataset describes medical information and costs billed by health insurance companies for 1338 individuals in 2013, as compiled by the United States Census Bureau.\nVariables include:\nWe will load the data directly from the web, but you can also download the data from the link at github1.\ninsurance_url &lt;- \"https://raw.githubusercontent.com/stedy/Machine-Learning-with-R-datasets/master/insurance.csv\"\ninsurance &lt;- read.csv(insurance_url)\nExplore the dataset a bit to understand its structure and contents. For example, you can use the head() function to view the first few rows of the dataset.\nhead(insurance)\n\n  age    sex    bmi children smoker    region   charges\n1  19 female 27.900        0    yes southwest 16884.924\n2  18   male 33.770        1     no southeast  1725.552\n3  28   male 33.000        3     no southeast  4449.462\n4  33   male 22.705        0     no northwest 21984.471\n5  32   male 28.880        0     no northwest  3866.855\n6  31 female 25.740        0     no southeast  3756.622\nAnd you can examine the dimensions of the dataset using the dim(), which returns the number of rows and columns in the dataset, the ncol() function, which returns the number of columns, and the nrow() function, which returns the number of rows.\ndim(insurance)\n\n[1] 1338    7\n\nncol(insurance)\n\n[1] 7\n\nnrow(insurance)\n\n[1] 1338\nNote that with the dim() function, the number of rows is given first, followed by the number of columns.\nNotice that, while the BMI variable represents a measure of a person’s weight relative to their height, there is no discrete variable for whether a person is obese or not. The World Health Organization (WHO) defines obesity as a BMI greater than or equal to 30. We can create a new variable, obese, that indicates whether a person is obese based on their BMI.\ninsurance$obese &lt;- ifelse(insurance$bmi &gt;= 30, \"obese\", \"not obese\")\nIf we examine the dataset again, we can see that the new variable obese has been added to the dataset.\nhead(insurance)\n\n  age    sex    bmi children smoker    region   charges     obese\n1  19 female 27.900        0    yes southwest 16884.924 not obese\n2  18   male 33.770        1     no southeast  1725.552     obese\n3  28   male 33.000        3     no southeast  4449.462     obese\n4  33   male 22.705        0     no northwest 21984.471 not obese\n5  32   male 28.880        0     no northwest  3866.855 not obese\n6  31 female 25.740        0     no southeast  3756.622 not obese",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Plotting with ggplot2</span>"
    ]
  },
  {
    "objectID": "ggplot.html#data",
    "href": "ggplot.html#data",
    "title": "\n7  Plotting with ggplot2\n",
    "section": "",
    "text": "age\n\nage of primary beneficiary\n\n\n\nsex\n\ninsurance contractor gender, female, male\n\n\n\nbmi\n\nBody mass index, providing an understanding of body, weights that are relatively high or low relative to height, objective index of body weight (kg / m ^ 2) using the ratio of height to weight, ideally 18.5 to 24.9\n\n\n\nchildren\n\nNumber of children covered by health insurance / Number of dependents\n\n\n\nsmoker\n\nSmoking status\n\n\n\nregion\n\nthe beneficiary’s residential area in the US, northeast, southeast, southwest, northwest.\n\n\n\ncharges\n\nIndividual medical costs billed by health insurance\n\n\n\n\n1 Insurance data csv file, https://raw.githubusercontent.com/stedy/Machine-Learning-with-R-datasets/master/insurance.csv",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Plotting with ggplot2</span>"
    ]
  },
  {
    "objectID": "ggplot.html#aesthetics",
    "href": "ggplot.html#aesthetics",
    "title": "\n7  Plotting with ggplot2\n",
    "section": "\n7.2 Aesthetics",
    "text": "7.2 Aesthetics\nThe next step in creating a ggplot2 plot is to specify the aesthetics of the plot. Aesthetics are visual properties of the plot that map data to visual elements.\n\n# specify dataset and mapping\nlibrary(ggplot2)\nggplot(\n    data = insurance,\n    mapping = aes(x = age, y = charges)\n)\n\n\n\n\n\n\nFigure 7.2: A plot with age on the x-axis and charges on the y-axis.\n\n\n\n\nIn the code above, the data are the data to be visualized, and the mapping specifies how the data should be mapped to the plot. In this case, the x aesthetic is mapped to the age variable, and the y aesthetic is mapped to the charges variable. Note that there are no data displayed in Figure 7.2 yet; we have only specified the data and aesthetics. However, you can see the structure of the plot in the output, which shows the data and aesthetics that have been specified with age on the x-axis and charges on the y-axis.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Plotting with ggplot2</span>"
    ]
  },
  {
    "objectID": "ggplot.html#geometries",
    "href": "ggplot.html#geometries",
    "title": "\n7  Plotting with ggplot2\n",
    "section": "\n7.3 Geometries",
    "text": "7.3 Geometries\nThe next step is to add a geometry to the plot. Geometries are the visual representations of the data, such as points, lines, or bars. Since this is a scatter plot, we will use the geom_point() function to add points to the plot.\n\n# add points to the plot\nggplot(\n    data = insurance,\n    mapping = aes(x = age, y = charges)\n) +\n    geom_point()\n\n\n\n\n\n\nFigure 7.3: A scatter plot with age on the x-axis and charges on the y-axis results from adding geom_point() to the plot.\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nWhen using ggplot2, the + operator is used to add layers to the plot. The ggplot() function specifies the data and aesthetics, and the geom_point() function adds points to the plot. Using the + operator is a common practice in ggplot2 to add layers to a plot, but the + operator does not work for other types of plots in R.\n\n\nUsing other geometries, you can create different types of plots. For example, you can use geom_line() to create a line plot, geom_bar() to create a bar plot, or geom_boxplot() to create a box plot. Before doing so here, ask yourself if those geometries would be appropriate for the data you are working with.\nA number of parameters (options) can be specified in a geom_ function. Options for the geom_point() function include color, size, and alpha. These control the point color, size, and transparency, respectively. Transparency ranges from 0 (completely transparent) to 1 (completely opaque). Adding a degree of transparency can help visualize overlapping points such as in Figure 7.4.\n\n# add points to the plot\nggplot(\n    data = insurance,\n    mapping = aes(x = age, y = charges)\n) +\n    geom_point(\n        color = \"blue\",\n        size = 3,\n        alpha = 0.3\n    )\n\n\n\n\n\n\nFigure 7.4: A scatter plot with age on the x-axis and charges on the y-axis with colored points, larger size, and transparency.\n\n\n\n\nWe can add a best fit line to the scatter plot using the geom_smooth() function. The method parameter specifies the method used to fit the line. In this case, we will use the default method, which is linear regression, specified by method = \"lm\". The lm method fits a linear model to the data, which in this case is simple linear regression 2 of the dependent variable charges as a function of the independent variable age. The result is shown in Figure 7.5.\n2 The linear regression model is of the form \\(charges = \\alpha +  \\beta * age + \\epsilon\\) where \\(\\alpha\\) is the intercept, \\(\\beta\\) is the slope, and \\(\\epsilon\\) is the “error”.\n# add points and a best fit line to the plot\nggplot(\n    data = insurance,\n    mapping = aes(x = age, y = charges)\n) +\n    geom_point(\n        color = \"blue\",\n        alpha = 0.3\n    ) +\n    geom_smooth(method = \"lm\")\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\nFigure 7.5: A scatter plot with age on the x-axis and charges on the y-axis with a best fit line.\n\n\n\n\nWhat do you observe in Figure 7.5 with the best fit line? How well does the line fit the data? Do you think a linear model is appropriate for this data?",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Plotting with ggplot2</span>"
    ]
  },
  {
    "objectID": "ggplot.html#grouping",
    "href": "ggplot.html#grouping",
    "title": "\n7  Plotting with ggplot2\n",
    "section": "\n7.4 Grouping",
    "text": "7.4 Grouping\nIn addition to mapping variables to the x and y axes [i.e., aes(x = ..., y=...)], variables can be mapped to the color, shape, size, transparency, and other visual characteristics of geometric objects. This allows groups of observations to be superimposed in a single graph.\nFor example, we can map the smoker variable to the color of the points in the scatter plot. The result is shown in Figure 7.6.\n\n# add points to the plot, colored by the smoker variable\nggplot(\n    data = insurance,\n    mapping = aes(x = age, y = charges, color = smoker)\n) +\n    geom_point()\n\n\n\n\n\n\nFigure 7.6: A scatter plot with age on the x-axis and charges on the y-axis with points colored by the smoker variable.\n\n\n\n\nIn Figure 7.6, the points are colored based on the smoker variable, with smokers in orange and non-smokers in blue. This allows us to visually compare the charges of smokers and non-smokers as a function of age.\nIf we add back in the best fit line, we can see how the relationship between age and charges differs between smokers and non-smokers. The result is shown in Figure 7.7.\n\n# add points to the plot, colored by the smoker variable, and a best fit line\nggplot(\n    data = insurance,\n    mapping = aes(x = age, y = charges, color = smoker)\n) +\n    geom_point() +\n    geom_smooth(method = \"lm\")\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\nFigure 7.7: A scatter plot with age on the x-axis and charges on the y-axis with points colored by the smoker variable and a best fit line.\n\n\n\n\nHow well does the best fit line fit the data for smokers and non-smokers? Do you see any differences in the relationship between age and charges for smokers and non-smokers?",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Plotting with ggplot2</span>"
    ]
  },
  {
    "objectID": "ggplot.html#facets",
    "href": "ggplot.html#facets",
    "title": "\n7  Plotting with ggplot2\n",
    "section": "\n7.5 Facets",
    "text": "7.5 Facets\nFacets are a way to create multiple plots based on the levels of a categorical variable. In other words, facets allow you to create a grid of plots, with each plot showing a different subset of the data based on the levels of a categorical variable.\nIn Figure 7.7, we noticed that there are still two groups of points, even when looking at just smokers. We can further separate the data by the obese variable, creating a grid of plots with one plot for each combination of smoker and obese status.\n\n# add points to the plot, colored by the smoker variable, and faceted by the obese variable\nggplot(\n    data = insurance,\n    mapping = aes(x = age, y = charges, color = smoker)\n) +\n    geom_point() +\n    geom_smooth(method = \"lm\") +\n    facet_wrap(~obese)\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\nFigure 7.8: A grid of scatter plots with age on the x-axis and charges on the y-axis, colored by the smoker variable, and faceted by the obese variable.\n\n\n\n\nThe way that we interpret the facet_wrap(~ obese) command is that we want to create a grid of plots, with each plot showing a different subset of the data based on the levels of the obese variable. In this case, we have two levels of the obese variable: obese and not obese, so we get two plots in the grid.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Plotting with ggplot2</span>"
    ]
  },
  {
    "objectID": "ggplot.html#labels",
    "href": "ggplot.html#labels",
    "title": "\n7  Plotting with ggplot2\n",
    "section": "\n7.6 Labels",
    "text": "7.6 Labels\nLabels are an important part of any plot. They help the viewer understand what the plot is showing and what the axes represent. While our plot already has labels for the x and y axes, we can add a title to the plot and change the labels for the x and y axes to make them more descriptive.\n\n# add points to the plot, colored by the smoker variable, faceted by the obese variable, and add labels\nggplot(\n    data = insurance,\n    mapping = aes(x = age, y = charges, color = smoker)\n) +\n    geom_point() +\n    geom_smooth(method = \"lm\") +\n    facet_wrap(~obese) +\n    labs(\n        title = \"Medical Charges as a function of patient characteristics\",\n        subtitle = \"US Census Bureau 2013 data\",\n        caption = \"Source: https://github.com/stedy/Machine-Learning-with-R-datasets\",\n        x = \"Age\",\n        y = \"Annual Medical Charges\",\n        color = \"Smoker?\"\n    )\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\nFigure 7.9: A scatter plot with age on the x-axis and charges on the y-axis, colored by the smoker variable, and faceted by the obese variable, with labels.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Plotting with ggplot2</span>"
    ]
  },
  {
    "objectID": "ggplot.html#themes",
    "href": "ggplot.html#themes",
    "title": "\n7  Plotting with ggplot2\n",
    "section": "\n7.7 Themes",
    "text": "7.7 Themes\nThemes are a way to control the non-data ink in a plot, such as the background color, grid lines, and text size. Rather than specifying each element individually, you can use a pre-defined theme to quickly style your plot. For a nice overview of themes in ggplot2, see the the ggplot2 themes gallery.\nTo create a more visually appealing plot, we can apply the theme_minimal() theme to our plot. This theme removes the background grid lines and adds a light gray background to the plot.\n\n# add points to the plot, colored by the smoker variable, faceted by the obese variable, add labels, and apply a minimal theme\nggplot(\n    data = insurance,\n    mapping = aes(x = age, y = charges, color = smoker)\n) +\n    geom_point() +\n    geom_smooth(method = \"lm\") +\n    facet_wrap(~obese) +\n    labs(\n        title = \"Medical Charges as a function of patient characteristics\",\n        subtitle = \"US Census Bureau 2013 data\",\n        caption = \"Source: https://github.com/stedy/Machine-Learning-with-R-datasets\",\n        x = \"Age\",\n        y = \"Annual Medical Charges\",\n        color = \"Smoker?\"\n    ) +\n    theme_minimal()\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\nFigure 7.10: A scatter plot with age on the x-axis and charges on the y-axis, colored by the smoker variable, faceted by the obese variable, with labels and a minimal theme.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Plotting with ggplot2</span>"
    ]
  },
  {
    "objectID": "ggplot.html#saving-a-plot",
    "href": "ggplot.html#saving-a-plot",
    "title": "\n7  Plotting with ggplot2\n",
    "section": "\n7.8 Saving a Plot",
    "text": "7.8 Saving a Plot\nOnce you have created a plot that you are happy with, you may want to save it to a file for use in a report or presentation. The ggsave() function in ggplot2 allows you to save a plot to a file in a variety of formats, including PNG, PDF, and SVG. Take a look at the help for ggsave() to see the available options. In particular, you can specify the file name, width, height, and resolution of the saved plot.\n\n# save the plot to a file\nggsave(\"insurance_plot.png\")\n\nSaving 7 x 5 in image\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\nNote\n\n\n\nThe ggsave() function saves the last plot that you created with ggplot2. ggsave() will save the plot to the working directory by default, but you can specify a different directory by providing the full path to the file name.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Plotting with ggplot2</span>"
    ]
  },
  {
    "objectID": "ggplot.html#references",
    "href": "ggplot.html#references",
    "title": "\n7  Plotting with ggplot2\n",
    "section": "References",
    "text": "References\n\n\nCaron, Stéphane. 2018. “The Grammar of Graphics.” https://dotlayer.org/en/grammar-of-graphics/.\n\n\nWickham, Hadley. 2014. “Tidy Data.” Journal of\nStatistical Software, Articles 59 (10): 1–23. https://doi.org/10.18637/jss.v059.i10.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Plotting with ggplot2</span>"
    ]
  }
]