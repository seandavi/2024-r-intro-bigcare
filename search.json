[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduction to R for BigCare 2024",
    "section": "",
    "text": "Overview\nThis is the overview.",
    "crumbs": [
      "Overview"
    ]
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Introduction to R and RStudio",
    "section": "",
    "text": "1.1 Introduction\nIn this chapter, we will discuss the basics of R and RStudio, two essential tools in genomics data analysis. We will cover the advantages of using R and RStudio, how to set up RStudio, and the different panels of the RStudio interface.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction to R and RStudio</span>"
    ]
  },
  {
    "objectID": "intro.html#questions",
    "href": "intro.html#questions",
    "title": "1  Introduction to R and RStudio",
    "section": "Questions",
    "text": "Questions\n\nWhat is R?\nWhy use R?\nWhy not use R?\nWhy use RStudio and how does it differ from R?",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction to R and RStudio</span>"
    ]
  },
  {
    "objectID": "intro.html#learning-objectives",
    "href": "intro.html#learning-objectives",
    "title": "1  Introduction to R and RStudio",
    "section": "Learning Objectives",
    "text": "Learning Objectives\n\nKnow advantages of analyzing data in R\nKnow advantages of using RStudio\nBe able to start RStudio on your computer\nIdentify the panels of the RStudio interface\nBe able to customize the RStudio layout",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction to R and RStudio</span>"
    ]
  },
  {
    "objectID": "intro.html#what-is-r",
    "href": "intro.html#what-is-r",
    "title": "1  Introduction to R and RStudio",
    "section": "1.2 What is R?",
    "text": "1.2 What is R?\nR is a programming language and software environment designed for statistical computing and graphics. It is widely used by statisticians, data scientists, and researchers for data analysis and visualization. R is an open-source language, which means it is free to use, modify, and distribute. Over the years, R has become particularly popular (see Figure 1.1) in the fields of genomics and bioinformatics, owing to its extensive libraries and powerful data manipulation capabilities.\nThe R language is a dialect of the S language, which was developed in the 1970s at Bell Laboratories. The first version of R was written by Robert Gentleman and Ross Ihaka and released in 1995 (see this slide deck for Ross Ihaka’s take on R’s history). Since then, R has been continuously developed by the R Core Team, a group of statisticians and computer scientists. The R Core Team releases a new version of R every year.\n\n\n\n\n\n\n\nFigure 1.1: Google trends showing the popularity of R over time based on Google searches.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction to R and RStudio</span>"
    ]
  },
  {
    "objectID": "intro.html#why-use-r",
    "href": "intro.html#why-use-r",
    "title": "1  Introduction to R and RStudio",
    "section": "1.3 Why use R?",
    "text": "1.3 Why use R?\nThere are several reasons why R is a popular choice for data analysis, particularly in genomics and bioinformatics. These include:\n\nOpen-source1: R is free to use and has a large community of developers who contribute to its growth and development. Open source software is software with source code that anyone can inspect, modify, and enhance.\nExtensive libraries: There are thousands of R packages available for a wide range of tasks, including specialized packages for genomics and bioinformatics. These libraries have been extensively tested and ara available for free.\nData manipulation: R has powerful data manipulation capabilities, making it easy (or at least possible) to clean, process, and analyze large datasets.\nGraphics and visualization: R has excellent tools for creating high-quality graphics and visualizations that can be customized to meet the specific needs of your analysis. In most cases, graphics produced by R are publication-quality.\nReproducible research: R enables you to create reproducible research by recording your analysis in a script, which can be easily shared and executed by others. In addition, R does not have a meaningful graphical user interface (GUI), which renders analysis in R much more reproducible than tools that rely on GUI interactions.\nCross-platform: R runs on Windows, Mac, and Linux (as well as more obscure systems).\nInteroperability with other languages: R can interfact with FORTRAN, C, and many other languages.\nScalability: R is useful for small and large projects. I can develop code for analysis on my Mac laptop. I can then install the same code on our 20k core cluster and run it in parallel on 100 samples, monitor the process, and then update a database (for example) with R when complete.\n\n1 Source code is the code computer programmers can manipulate to change how a piece of software—a “program” or “application”—works. Programmers who have access to a computer program’s source code can improve that program by adding features to it or fixing parts that don’t always work correctly. For more details, see what is “open-source”?",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction to R and RStudio</span>"
    ]
  },
  {
    "objectID": "intro.html#why-not-use-r",
    "href": "intro.html#why-not-use-r",
    "title": "1  Introduction to R and RStudio",
    "section": "1.4 Why not use R?",
    "text": "1.4 Why not use R?\n\nR cannot do everything.\nR is not always the “best” tool for the job.\nR will not hold your hand. Often, it will slap your hand instead.\nThe documentation can be opaque (but there is documentation).\nR can drive you crazy (on a good day) or age you prematurely (on a bad one).\nFinding the right package to do the job you want to do can be challenging; worse, some contributed packages are unreliable.]{}\nR does not have a meaningfully useful graphical user interface (GUI).",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction to R and RStudio</span>"
    ]
  },
  {
    "objectID": "intro.html#r-license-and-the-open-source-ideal",
    "href": "intro.html#r-license-and-the-open-source-ideal",
    "title": "1  Introduction to R and RStudio",
    "section": "1.5 R License and the Open Source Ideal",
    "text": "1.5 R License and the Open Source Ideal\nR is free (yes, totally free!) and distributed under GNU license. In particular, this license allows one to:\n\nDownload the source code\nModify the source code to your heart’s content\nDistribute the modified source code and even charge money for it, but you must distribute the modified source code under the original GNU license]{}\n\nThis license means that R will always be available, will always be open source, and can grow organically without constraint.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction to R and RStudio</span>"
    ]
  },
  {
    "objectID": "intro.html#rstudio",
    "href": "intro.html#rstudio",
    "title": "1  Introduction to R and RStudio",
    "section": "1.6 RStudio",
    "text": "1.6 RStudio\nRStudio is an integrated development environment (IDE) for R. It provides a graphical user interface (GUI) for R, making it easier to write and execute R code. RStudio also provides several other useful features, including a built-in console, syntax-highlighting editor, and tools for plotting, history, debugging, workspace management, and workspace viewing. RStudio is available in both free and commercial editions; the commercial edition provides some additional features, including support for multiple sessions and enhanced debugging\n\n1.6.1 Getting started with RStudio\nTo get started with RStudio, you first need to install both R and RStudio on your computer. Follow these steps:\n\nDownload and install R from the official R website.\nDownload and install RStudio from the official RStudio website.\nLaunch RStudio. You should see the RStudio interface with four panels.\n\n\n\n1.6.2 The RStudio Interface\nRStudio’s interface consists of four panels (see Figure 1.2):\n\n\nConsole\n\nThis panel displays the R console, where you can enter and execute R commands directly. The console also shows the output of your code, error messages, and other information.\n\n\n\nSource\n\nThis panel is where you write and edit your R scripts. You can create new scripts, open existing ones, and run your code from this panel.\n\n\n\nEnvironment\n\nThis panel displays your current workspace, including all variables, data objects, and functions that you have created or loaded in your R session.\n\n\n\nPlots, Packages, Help, and Viewer\n\nThese panels display plots, installed packages, help files, and web content, respectively.\n\n\n\n\n\n\n\n\n\nFigure 1.2: The RStudio interface. In this layout, the source pane is in the upper left, the console is in the lower left, the environment panel is in the top right and the viewer/help/files panel is in the bottom right.\n\n\n\n\n\n\n\n\n\nDo I need to use RStudio?\n\n\n\nNo. You can use R without RStudio. However, RStudio makes it easier to write and execute R code, and it provides several useful features that are not available in the basic R console. Note that the only part of RStudio that is actually interacting with R directly is the console. The other panels are simply providing a GUI that enhances the user experience.\n\n\n\n\n\n\n\n\nCustomizing the RStudio Interface\n\n\n\nYou can customize the layout of RStudio to suit your preferences. To do so, go to Tools &gt; Global Options &gt; Appearance. Here, you can change the theme, font size, and panel layout. You can also resize the panels as needed to gain screen real estate (see Figure 1.3).\n\n\n\n\n\n\n\n\nFigure 1.3: Dealing with limited screen real estate can be a challenge, particularly when you want to open another window to, for example, view a web page. You can resize the panes by sliding the center divider (red arrows) or by clicking on the minimize/maximize buttons (see blue arrow).\n\n\n\nIn summary, R and RStudio are powerful tools for genomics data analysis. By understanding the advantages of using R and RStudio and familiarizing yourself with the RStudio interface, you can efficiently analyze and visualize your data. In the following chapters, we will delve deeper into the functionality of R, Bioconductor, and various statistical methods to help you gain a comprehensive understanding of genomics data analysis.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction to R and RStudio</span>"
    ]
  },
  {
    "objectID": "chatbots.html",
    "href": "chatbots.html",
    "title": "2  Chatbots as Learning Tools",
    "section": "",
    "text": "ChatGPT, developed by OpenAI, and Claude, developed by Anthropic, are advanced language models that leverage deep learning techniques to understand and generate human-like text. At their core, these chatbots operate using a variant of the Transformer architecture, which enable them to process and generate text based on the patterns and structures they learn from vast amounts of training data. These models1 excels in natural language understanding and generation tasks, making them incredibly versatile tools for a wide range of applications beyond simple chat interactions.\n1 Foundation models are a recent development in AI. These models are developed from algorithms designed to optimize for generality and versatility of output. They are based on large-scale neural networks that are often trained on a broad range of data sources and large amounts of data to accomplish a wide range of downstream tasks, including some for which they were not specifically developed and trained.In the context of programming and coding, these chatbots serve as valuable assistants by providing explanations, examples, and guidance related to programming languages like R. Users can interact with a chatbot by posing questions or requesting code snippets, which they generate based on their understanding of the input and their extensive training data. For instance, users can inquire about specific syntax rules, algorithm implementations, or even debugging tips, and chatbots can respond with clear explanations and relevant examples. This capability makes them particularly useful for learners and developers seeking quick insights or clarification on complex programming concepts.\nMoreover, chatbots can facilitate learning and problem-solving by offering personalized responses tailored to the user’s queries. Their ability to generate coherent and contextually relevant text allows them to simulate a dialogue where they guides users through coding challenges or help them understand intricate programming concepts more intuitively. This makes chatbots not only a powerful tool for acquiring programming knowledge but also a supportive companion in the journey of mastering programming languages like R.\nIn this tutorial, we will explore how chatbots like ChatGPT and Claude can be leveraged as learning tools for programming in R. We will discuss their features, capabilities, and potential applications in the context of programming education. By the end of this tutorial, you will have a better understanding of how chatbots can enhance the learning experience and support your programming endeavors.\n\nFeatures of Chatbots\nChatbots like ChatGPT and Claude offer a range of features that make them valuable learning tools for programming in R. Some of the key features include:\n\nNatural Language Understanding: Chatbots can interpret and respond to user queries in natural language, making interactions more intuitive and user-friendly.\nCode Generation: Chatbots can generate code snippets, examples, and explanations based on the user’s input, helping users understand and implement programming concepts.\nPersonalized Responses: Chatbots can provide personalized responses tailored to the user’s queries, enhancing the learning experience and engagement.\nInteractive Learning: Chatbots can engage users in interactive learning experiences, guiding them through coding challenges and providing real-time feedback.\n24/7 Availability: Chatbots are available round the clock, allowing users to seek assistance and guidance at any time, making them convenient learning companions.\nExtensive Knowledge Base: Chatbots have access to vast amounts of training data and information, enabling them to provide accurate and up-to-date responses to user queries.\nScalability: Chatbots can scale to accommodate a large number of users simultaneously, making them suitable for both individual learners and educational institutions.\nFeedback and Evaluation: Chatbots can provide feedback and evaluation on user-generated code, helping users identify and correct errors in their programming assignments.\nMultimodal Capabilities: Chatbots can support multimodal interactions, such as text, voice, and visual inputs, enhancing the user experience and accessibility.\nContinuous Learning: Chatbots can continuously learn and improve their responses based on user interactions and feedback, ensuring that they stay relevant and up-to-date.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Chatbots as Learning Tools</span>"
    ]
  },
  {
    "objectID": "data_structures_intro.html",
    "href": "data_structures_intro.html",
    "title": "\n3  Vectors\n",
    "section": "",
    "text": "3.1 Creating vectors\nCharacter vectors (also sometimes called “string” vectors) are entered with each value surrounded by single or double quotes; either is acceptable, but they must match. They are always displayed by R with double quotes. Here are some examples of creating vectors:\n# examples of vectors\nc('hello','world')\n\n[1] \"hello\" \"world\"\n\nc(1,3,4,5,1,2)\n\n[1] 1 3 4 5 1 2\n\nc(1.12341e7,78234.126)\n\n[1] 11234100.00    78234.13\n\nc(TRUE,FALSE,TRUE,TRUE)\n\n[1]  TRUE FALSE  TRUE  TRUE\n\n# note how in the next case the TRUE is converted to \"TRUE\"\n# with quotes around it.\nc(TRUE,'hello')\n\n[1] \"TRUE\"  \"hello\"\nWe can also create vectors as “regular sequences” of numbers. For example:\n# create a vector of integers from 1 to 10\nx = 1:10\n# and backwards\nx = 10:1\nThe seq function can create more flexible regular sequences.\n# create a vector of numbers from 1 to 4 skipping by 0.3\ny = seq(1,4,0.3)\nAnd creating a new vector by concatenating existing vectors is possible, as well.\n# create a sequence by concatenating two other sequences\nz = c(y,x)\nz\n\n [1]  1.0  1.3  1.6  1.9  2.2  2.5  2.8  3.1  3.4  3.7  4.0 10.0  9.0  8.0  7.0\n[16]  6.0  5.0  4.0  3.0  2.0  1.0",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Vectors</span>"
    ]
  },
  {
    "objectID": "data_structures_intro.html#vector-operations",
    "href": "data_structures_intro.html#vector-operations",
    "title": "\n3  Vectors\n",
    "section": "\n3.2 Vector Operations",
    "text": "3.2 Vector Operations\nOperations on a single vector are typically done element-by-element. For example, we can add 2 to a vector, 2 is added to each element of the vector and a new vector of the same length is returned.\n\nx = 1:10\nx + 2\n\n [1]  3  4  5  6  7  8  9 10 11 12\n\n\nIf the operation involves two vectors, the following rules apply. If the vectors are the same length: R simply applies the operation to each pair of elements.\n\nx + x\n\n [1]  2  4  6  8 10 12 14 16 18 20\n\n\nIf the vectors are different lengths, but one length a multiple of the other, R reuses the shorter vector as needed.\n\nx = 1:10\ny = c(1,2)\nx * y\n\n [1]  1  4  3  8  5 12  7 16  9 20\n\n\nIf the vectors are different lengths, but one length not a multiple of the other, R reuses the shorter vector as needed and delivers a warning.\n\nx = 1:10\ny = c(2,3,4)\nx * y\n\nWarning in x * y: longer object length is not a multiple of shorter object\nlength\n\n\n [1]  2  6 12  8 15 24 14 24 36 20\n\n\nTypical operations include multiplication (“*”), addition, subtraction, division, exponentiation (“^”), but many operations in R operate on vectors and are then called “vectorized”.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Vectors</span>"
    ]
  },
  {
    "objectID": "data_structures_intro.html#logical-vectors",
    "href": "data_structures_intro.html#logical-vectors",
    "title": "\n3  Vectors\n",
    "section": "\n3.3 Logical Vectors",
    "text": "3.3 Logical Vectors\nLogical vectors are vectors composed on only the values TRUE and FALSE. Note the all-upper-case and no quotation marks.\n\na = c(TRUE,FALSE,TRUE)\n\n# we can also create a logical vector from a numeric vector\n# 0 = false, everything else is 1\nb = c(1,0,217)\nd = as.logical(b)\nd\n\n[1]  TRUE FALSE  TRUE\n\n# test if a and d are the same at every element\nall.equal(a,d)\n\n[1] TRUE\n\n# We can also convert from logical to numeric\nas.numeric(a)\n\n[1] 1 0 1\n\n\n\n3.3.1 Logical Operators\nSome operators like &lt;, &gt;, ==, &gt;=, &lt;=, != can be used to create logical vectors.\n\n# create a numeric vector\nx = 1:10\n# testing whether x &gt; 5 creates a logical vector\nx &gt; 5\n\n [1] FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE\n\nx &lt;= 5\n\n [1]  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE\n\nx != 5\n\n [1]  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE\n\nx == 5\n\n [1] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE\n\n\nWe can also assign the results to a variable:\n\ny = (x == 5)\ny\n\n [1] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Vectors</span>"
    ]
  },
  {
    "objectID": "data_structures_intro.html#indexing-vectors",
    "href": "data_structures_intro.html#indexing-vectors",
    "title": "\n3  Vectors\n",
    "section": "\n3.4 Indexing Vectors",
    "text": "3.4 Indexing Vectors\nIn R, an index is used to refer to a specific element or set of elements in an vector (or other data structure). [R uses [ and ] to perform indexing, although other approaches to getting subsets of larger data structures are common in R.\n\nx = seq(0,1,0.1)\n# create a new vector from the 4th element of x\nx[4]\n\n[1] 0.3\n\n\nWe can even use other vectors to perform the “indexing”.\n\nx[c(3,5,6)]\n\n[1] 0.2 0.4 0.5\n\ny = 3:6\nx[y]\n\n[1] 0.2 0.3 0.4 0.5\n\n\nCombining the concept of indexing with the concept of logical vectors results in a very power combination.\n\n# use help('rnorm') to figure out what is happening next\nmyvec = rnorm(10)\n\n# create logical vector that is TRUE where myvec is &gt;0.25\ngt1 = (myvec &gt; 0.25)\nsum(gt1)\n\n[1] 3\n\n# and use our logical vector to create a vector of myvec values that are &gt;0.25\nmyvec[gt1]\n\n[1] 0.9927046 2.6965794 1.0271138\n\n# or &lt;=0.25 using the logical \"not\" operator, \"!\"\nmyvec[!gt1]\n\n[1] -0.9381846 -2.2263262 -0.2430687 -0.2758258  0.2207109 -1.1993946  0.1047671\n\n# shorter, one line approach\nmyvec[myvec &gt; 0.25]\n\n[1] 0.9927046 2.6965794 1.0271138",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Vectors</span>"
    ]
  },
  {
    "objectID": "data_structures_intro.html#character-vectors-a.k.a.-strings",
    "href": "data_structures_intro.html#character-vectors-a.k.a.-strings",
    "title": "\n3  Vectors\n",
    "section": "\n3.5 Character Vectors, A.K.A. Strings",
    "text": "3.5 Character Vectors, A.K.A. Strings\nR uses the paste function to concatenate strings.\n\npaste(\"abc\",\"def\")\n\n[1] \"abc def\"\n\npaste(\"abc\",\"def\",sep=\"THISSEP\")\n\n[1] \"abcTHISSEPdef\"\n\npaste0(\"abc\",\"def\")\n\n[1] \"abcdef\"\n\n## [1] \"abcdef\"\npaste(c(\"X\",\"Y\"),1:10)\n\n [1] \"X 1\"  \"Y 2\"  \"X 3\"  \"Y 4\"  \"X 5\"  \"Y 6\"  \"X 7\"  \"Y 8\"  \"X 9\"  \"Y 10\"\n\npaste(c(\"X\",\"Y\"),1:10,sep=\"_\")\n\n [1] \"X_1\"  \"Y_2\"  \"X_3\"  \"Y_4\"  \"X_5\"  \"Y_6\"  \"X_7\"  \"Y_8\"  \"X_9\"  \"Y_10\"\n\n\nWe can count the number of characters in a string.\n\nnchar('abc')\n\n[1] 3\n\nnchar(c('abc','d',123456))\n\n[1] 3 1 6\n\n\nPulling out parts of strings is also sometimes useful.\n\nsubstr('This is a good sentence.',start=10,stop=15)\n\n[1] \" good \"\n\n\nAnother common operation is to replace something in a string with something (a find-and-replace).\n\nsub('This','That','This is a good sentence.')\n\n[1] \"That is a good sentence.\"\n\n\nWhen we want to find all strings that match some other string, we can use grep, or “grab regular expression”.\n\ngrep('bcd',c('abcdef','abcd','bcde','cdef','defg'))\n\n[1] 1 2 3\n\ngrep('bcd',c('abcdef','abcd','bcde','cdef','defg'),value=TRUE)\n\n[1] \"abcdef\" \"abcd\"   \"bcde\"",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Vectors</span>"
    ]
  },
  {
    "objectID": "data_structures_intro.html#missing-values-aka-na",
    "href": "data_structures_intro.html#missing-values-aka-na",
    "title": "\n3  Vectors\n",
    "section": "\n3.6 Missing Values, AKA “NA”",
    "text": "3.6 Missing Values, AKA “NA”\nR has a special value, “NA”, that represents a “missing” value, or Not Available, in a vector or other data structure. Here, we just create a vector to experiment.\n\nx = 1:5\nx\n\n[1] 1 2 3 4 5\n\nlength(x)\n\n[1] 5\n\n\n\nis.na(x)\n\n[1] FALSE FALSE FALSE FALSE FALSE\n\nx[2] = NA\nx\n\n[1]  1 NA  3  4  5\n\n\nThe length of x is unchanged, but there is one value that is marked as “missing” by virtue of being NA.\n\nlength(x)\n\n[1] 5\n\nis.na(x)\n\n[1] FALSE  TRUE FALSE FALSE FALSE\n\n\nWe can remove NA values by using indexing. In the following, is.na(x) returns a logical vector the length of x. The ! is the logical NOT operator and converts TRUE to FALSE and vice-versa.\n\nx[!is.na(x)]\n\n[1] 1 3 4 5",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Vectors</span>"
    ]
  },
  {
    "objectID": "data_structures_intro.html#factors",
    "href": "data_structures_intro.html#factors",
    "title": "\n3  Vectors\n",
    "section": "\n3.7 Factors",
    "text": "3.7 Factors\nA factor is a special type of vector, normally used to hold a categorical variable–such as smoker/nonsmoker, state of residency, zipcode–in many statistical functions. Such vectors have class “factor”. Factors are primarily used in Analysis of Variance (ANOVA) or other situations when “categories” are needed. When a factor is used as a predictor variable, the corresponding indicator variables are created (more later).\nNote of caution that factors in R often appear to be character vectors when printed, but you will notice that they do not have double quotes around them. They are stored in R as numbers with a key name, so sometimes you will note that the factor behaves like a numeric vector.\n\n# create the character vector\ncitizen&lt;-c(\"uk\",\"us\",\"no\",\"au\",\"uk\",\"us\",\"us\",\"no\",\"au\") \n\n# convert to factor\ncitizenf&lt;-factor(citizen)                                \ncitizen             \n\n[1] \"uk\" \"us\" \"no\" \"au\" \"uk\" \"us\" \"us\" \"no\" \"au\"\n\ncitizenf\n\n[1] uk us no au uk us us no au\nLevels: au no uk us\n\n# convert factor back to character vector\nas.character(citizenf)\n\n[1] \"uk\" \"us\" \"no\" \"au\" \"uk\" \"us\" \"us\" \"no\" \"au\"\n\n# convert to numeric vector\nas.numeric(citizenf)\n\n[1] 3 4 2 1 3 4 4 2 1\n\n\nR stores many data structures as vectors with “attributes” and “class” (just so you have seen this).\n\nattributes(citizenf)\n\n$levels\n[1] \"au\" \"no\" \"uk\" \"us\"\n\n$class\n[1] \"factor\"\n\nclass(citizenf)\n\n[1] \"factor\"\n\n# note that after unclassing, we can see the \n# underlying numeric structure again\nunclass(citizenf)\n\n[1] 3 4 2 1 3 4 4 2 1\nattr(,\"levels\")\n[1] \"au\" \"no\" \"uk\" \"us\"\n\n\nTabulating factors is a useful way to get a sense of the “sample” set available.\n\ntable(citizenf)\n\ncitizenf\nau no uk us \n 2  2  2  3",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Vectors</span>"
    ]
  },
  {
    "objectID": "dataframes_intro.html",
    "href": "dataframes_intro.html",
    "title": "\n4  Data Frames\n",
    "section": "",
    "text": "4.1 Learning goals",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Data Frames</span>"
    ]
  },
  {
    "objectID": "dataframes_intro.html#learning-goals",
    "href": "dataframes_intro.html#learning-goals",
    "title": "\n4  Data Frames\n",
    "section": "",
    "text": "Understand how data.frames are different from matrices.\nKnow a few functions for examing the contents of a data.frame.\nList approaches for subsetting data.frames.\nBe able to load and save tabular data from and to disk.\nShow how to create a data.frames from scratch.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Data Frames</span>"
    ]
  },
  {
    "objectID": "dataframes_intro.html#learning-objectives",
    "href": "dataframes_intro.html#learning-objectives",
    "title": "\n4  Data Frames\n",
    "section": "\n4.2 Learning objectives",
    "text": "4.2 Learning objectives\n\nLoad the yeast growth dataset into R using read.csv.\nExamine the contents of the dataset.\nUse subsetting to find genes that may be involved with nutrient metabolism and transport.\nSummarize data measurements by categories.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Data Frames</span>"
    ]
  },
  {
    "objectID": "dataframes_intro.html#dataset",
    "href": "dataframes_intro.html#dataset",
    "title": "\n4  Data Frames\n",
    "section": "\n4.3 Dataset",
    "text": "4.3 Dataset\nThe insurance dataset is described in the book Machine Learning with R by Brett Lantz. The dataset describes medical information and costs billed by health insurance companies for 1338 individuals in 2013, as compiled by the United States Census Bureau.\nVariables include:\n\n\nage\n\nage of primary beneficiary\n\n\n\nsex\n\ninsurance contractor gender, female, male\n\n\n\nbmi\n\nBody mass index, providing an understanding of body, weights that are relatively high or low relative to height, objective index of body weight (kg / m ^ 2) using the ratio of height to weight, ideally 18.5 to 24.9\n\n\n\nchildren\n\nNumber of children covered by health insurance / Number of dependents\n\n\n\nsmoker\n\nSmoking status\n\n\n\nregion\n\nthe beneficiary’s residential area in the US, northeast, southeast, southwest, northwest.\n\n\n\ncharges\n\nIndividual medical costs billed by health insurance\n\n\n\nWe will load the data directly from the web, but you can also download the data from the link at github1.\n1 Insurance data csv file, https://raw.githubusercontent.com/stedy/Machine-Learning-with-R-datasets/master/insurance.csv\ninsurance_url &lt;- \"https://raw.githubusercontent.com/stedy/Machine-Learning-with-R-datasets/master/insurance.csv\"\ninsurance &lt;- read.csv(insurance_url)\n\nExplore the dataset a bit to understand its structure and contents. For example, you can use the head() function to view the first few rows of the dataset.\n\nhead(insurance)\n\n  age    sex    bmi children smoker    region   charges\n1  19 female 27.900        0    yes southwest 16884.924\n2  18   male 33.770        1     no southeast  1725.552\n3  28   male 33.000        3     no southeast  4449.462\n4  33   male 22.705        0     no northwest 21984.471\n5  32   male 28.880        0     no northwest  3866.855\n6  31 female 25.740        0     no southeast  3756.622\n\n\nAnd you can examine the dimensions of the dataset using the dim(), which returns the number of rows and columns in the dataset, the ncol() function, which returns the number of columns, and the nrow() function, which returns the number of rows.\n\ndim(insurance)\n\n[1] 1338    7\n\nncol(insurance)\n\n[1] 7\n\nnrow(insurance)\n\n[1] 1338\n\n\nNote that with the dim() function, the number of rows is given first, followed by the number of columns.\nNotice that, while the BMI variable represents a measure of a person’s weight relative to their height, there is no discrete variable for whether a person is obese or not. The World Health Organization (WHO) defines obesity as a BMI greater than or equal to 30. We can create a new variable, obese, that indicates whether a person is obese based on their BMI.\n\ninsurance$obese &lt;- ifelse(insurance$bmi &gt;= 30, \"obese\", \"not obese\")\n\nIf we examine the dataset again, we can see that the new variable obese has been added to the dataset.\n\nhead(insurance)\n\n  age    sex    bmi children smoker    region   charges     obese\n1  19 female 27.900        0    yes southwest 16884.924 not obese\n2  18   male 33.770        1     no southeast  1725.552     obese\n3  28   male 33.000        3     no southeast  4449.462     obese\n4  33   male 22.705        0     no northwest 21984.471 not obese\n5  32   male 28.880        0     no northwest  3866.855 not obese\n6  31 female 25.740        0     no southeast  3756.622 not obese",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Data Frames</span>"
    ]
  },
  {
    "objectID": "dataframes_intro.html#inspecting-data.frames",
    "href": "dataframes_intro.html#inspecting-data.frames",
    "title": "\n4  Data Frames\n",
    "section": "\n4.4 Inspecting data.frames",
    "text": "4.4 Inspecting data.frames\nThere are a few functions that are useful for inspecting the contents of a data.frame:\n\nOverviews of content\n\n\nhead() to show first few rows\n\ntail() to show last few rows\n\n\nSize\n\n\ndim() for dimensions (rows, columns)\nnrow()\nncol()\n\nobject.size() for power users interested in the memory used to store an object\n\n\nData and attribute summaries\n\n\ncolnames() to get the names of the columns\n\nrownames() to get the “names” of the rows–may not be present\n\nsummary() to get per-column summaries of the data in the data.frame.\n\n\n\n\n# Show the first few rows\nhead(insurance)\n\n  age    sex    bmi children smoker    region   charges     obese\n1  19 female 27.900        0    yes southwest 16884.924 not obese\n2  18   male 33.770        1     no southeast  1725.552     obese\n3  28   male 33.000        3     no southeast  4449.462     obese\n4  33   male 22.705        0     no northwest 21984.471 not obese\n5  32   male 28.880        0     no northwest  3866.855 not obese\n6  31 female 25.740        0     no southeast  3756.622 not obese\n\n# Show the last few rows\ntail(insurance)\n\n     age    sex   bmi children smoker    region   charges     obese\n1333  52 female 44.70        3     no southwest 11411.685     obese\n1334  50   male 30.97        3     no northwest 10600.548     obese\n1335  18 female 31.92        0     no northeast  2205.981     obese\n1336  18 female 36.85        0     no southeast  1629.833     obese\n1337  21 female 25.80        0     no southwest  2007.945 not obese\n1338  61 female 29.07        0    yes northwest 29141.360 not obese\n\n# Get the dimensions of the data.frame\ndim(insurance)\n\n[1] 1338    8\n\n# Get the number of rows and columns\nnrow(insurance)\n\n[1] 1338\n\nncol(insurance)\n\n[1] 8\n\n# Get the names of the columns\ncolnames(insurance)\n\n[1] \"age\"      \"sex\"      \"bmi\"      \"children\" \"smoker\"   \"region\"   \"charges\" \n[8] \"obese\"   \n\n# Basic summary of the data\nsummary(insurance)\n\n      age            sex                 bmi           children    \n Min.   :18.00   Length:1338        Min.   :15.96   Min.   :0.000  \n 1st Qu.:27.00   Class :character   1st Qu.:26.30   1st Qu.:0.000  \n Median :39.00   Mode  :character   Median :30.40   Median :1.000  \n Mean   :39.21                      Mean   :30.66   Mean   :1.095  \n 3rd Qu.:51.00                      3rd Qu.:34.69   3rd Qu.:2.000  \n Max.   :64.00                      Max.   :53.13   Max.   :5.000  \n    smoker             region             charges         obese          \n Length:1338        Length:1338        Min.   : 1122   Length:1338       \n Class :character   Class :character   1st Qu.: 4740   Class :character  \n Mode  :character   Mode  :character   Median : 9382   Mode  :character  \n                                       Mean   :13270                     \n                                       3rd Qu.:16640                     \n                                       Max.   :63770                     \n\n\nIn RStudio, there is an additional function, View() (note the capital “V”) that opens the first 1000 rows (default) in the RStudio window, akin to a spreadsheet view.\n\nView(insurance)",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Data Frames</span>"
    ]
  },
  {
    "objectID": "dataframes_intro.html#accessing-variables-columns-and-subsetting",
    "href": "dataframes_intro.html#accessing-variables-columns-and-subsetting",
    "title": "\n4  Data Frames\n",
    "section": "\n4.5 Accessing variables (columns) and subsetting",
    "text": "4.5 Accessing variables (columns) and subsetting\nIn R, data.frames can be subset similarly to other two-dimensional data structures. The [ in R is used to denote subsetting of any kind. When working with two-dimensional data, we need two values inside the [ ] to specify the details. The specification is [rows, columns]. For example, to get the first three rows of insurance, use:\n\ninsurance[1:3, ]\n\n  age    sex   bmi children smoker    region   charges     obese\n1  19 female 27.90        0    yes southwest 16884.924 not obese\n2  18   male 33.77        1     no southeast  1725.552     obese\n3  28   male 33.00        3     no southeast  4449.462     obese\n\n\nNote how the second number, the columns, is blank. R takes that to mean “all the columns”. Similarly, we can combine rows and columns specification arbitrarily.\n\ninsurance[1:3, 1:3]\n\n  age    sex   bmi\n1  19 female 27.90\n2  18   male 33.77\n3  28   male 33.00\n\n\nBecause selecting a single variable, or column, is such a common operation, there are two shortcuts for doing so with data.frames. The first, the $ operator works like so:\n\n# Look at the column names, just to refresh memory\ncolnames(insurance)\n\n[1] \"age\"      \"sex\"      \"bmi\"      \"children\" \"smoker\"   \"region\"   \"charges\" \n[8] \"obese\"   \n\n# Note that I am using \"head\" here to limit the output\nhead(insurance$age)\n\n[1] 19 18 28 33 32 31\n\n# What is the actual length of \"symbol\"?\nlength(insurance$age)\n\n[1] 1338\n\n\nThe second is related to the fact that, in R, data.frames are also lists. We subset a list by using [[]] notation. To get the second column of insurance, we can use:\n\nhead(insurance[[2]])\n\n[1] \"female\" \"male\"   \"male\"   \"male\"   \"male\"   \"female\"\n\n\nAlternatively, we can use the column name:\n\nhead(insurance[[\"age\"]])\n\n[1] 19 18 28 33 32 31\n\n\n\n4.5.1 Some data exploration\nThere are a couple of columns that include numeric values. Which columns are numeric?\n\nclass(insurance$age)\n\n[1] \"integer\"\n\nclass(insurance$obese)\n\n[1] \"character\"\n\nclass(insurance$children)\n\n[1] \"integer\"\n\n\n\nlibrary(gridExtra)\nlibrary(grid)\nlibrary(dplyr)\n\n\nAttaching package: 'dplyr'\n\n\nThe following object is masked from 'package:gridExtra':\n\n    combine\n\n\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n\n\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n\n# Original DataFrame\ndf &lt;- data.frame(\n    id = c(1, 2, 3, 4, 5),\n    name = c(\"Alice\", \"Bob\", \"Carol\", \"David\", \"Eve\"),\n    age = c(23, 25, 22, 24, 23),\n    score = c(88, 95, 78, 92, 85),\n    city = c(\"New York\", \"Chicago\", \"Boston\", \"Seattle\", \"Austin\")\n)\n\n# Filter\ndf_filtered &lt;- df %&gt;% filter(age &gt; 23)\n\n# Select\ndf_selected &lt;- df_filtered %&gt;% select(name, score)\n\n# Mutate\ndf_mutated &lt;- df_selected %&gt;% mutate(score_scaled = score / 100)\n\n# Arrange\ndf_arranged &lt;- df_mutated %&gt;% arrange(desc(score))\n\n# Summarize\ndf_grouped &lt;- df %&gt;%\n    group_by(city) %&gt;%\n    summarize(avg_score = mean(score))\n\n# Function to create table grobs\ncreate_table_grob &lt;- function(df, title) {\n    table_grob &lt;- tableGrob(df)\n    title_grob &lt;- textGrob(title, gp = gpar(fontsize = 16, fontface = \"bold\"))\n    padding &lt;- unit(0.5, \"line\")\n    table_grob &lt;- gtable::gtable_add_rows(table_grob, heights = grobHeight(title_grob) + padding, pos = 0)\n    table_grob &lt;- gtable::gtable_add_grob(table_grob, list(title_grob), 1, 1, 1, ncol(table_grob))\n    table_grob\n}\n\n# Creating table grobs\noriginal_grob &lt;- create_table_grob(df, \"Original DataFrame\")\nfiltered_grob &lt;- create_table_grob(df_filtered, \"Filtered (age &gt; 23)\")\nselected_grob &lt;- create_table_grob(df_selected, \"Selected (name, score)\")\nmutated_grob &lt;- create_table_grob(df_mutated, \"Mutated (score_scaled)\")\narranged_grob &lt;- create_table_grob(df_arranged, \"Arranged (by score)\")\nsummarized_grob &lt;- create_table_grob(df_grouped, \"Summarized (avg score by city)\")\n\n# Arrange tables in a grid\ngrid.arrange(\n    original_grob, filtered_grob,\n    selected_grob, mutated_grob,\n    arranged_grob, summarized_grob,\n    nrow = 6\n)",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Data Frames</span>"
    ]
  },
  {
    "objectID": "ggplot.html",
    "href": "ggplot.html",
    "title": "\n5  Plotting with ggplot2\n",
    "section": "",
    "text": "5.1 Data\nThe first step in creating a ggplot2 plot is to specify the data to be visualized. The data should be in a tidy format (Wickham (2014)), with each row representing an observation and each column representing a variable. The insurance dataset is described in the book Machine Learning with R by Brett Lantz. The dataset describes medical information and costs billed by health insurance companies for 1338 individuals in 2013, as compiled by the United States Census Bureau.\nVariables include:\nWe will load the data directly from the web, but you can also download the data from the link at github1.\ninsurance_url &lt;- \"https://raw.githubusercontent.com/stedy/Machine-Learning-with-R-datasets/master/insurance.csv\"\ninsurance &lt;- read.csv(insurance_url)\nExplore the dataset a bit to understand its structure and contents. For example, you can use the head() function to view the first few rows of the dataset.\nhead(insurance)\n\n  age    sex    bmi children smoker    region   charges\n1  19 female 27.900        0    yes southwest 16884.924\n2  18   male 33.770        1     no southeast  1725.552\n3  28   male 33.000        3     no southeast  4449.462\n4  33   male 22.705        0     no northwest 21984.471\n5  32   male 28.880        0     no northwest  3866.855\n6  31 female 25.740        0     no southeast  3756.622\nAnd you can examine the dimensions of the dataset using the dim(), which returns the number of rows and columns in the dataset, the ncol() function, which returns the number of columns, and the nrow() function, which returns the number of rows.\ndim(insurance)\n\n[1] 1338    7\n\nncol(insurance)\n\n[1] 7\n\nnrow(insurance)\n\n[1] 1338\nNote that with the dim() function, the number of rows is given first, followed by the number of columns.\nNotice that, while the BMI variable represents a measure of a person’s weight relative to their height, there is no discrete variable for whether a person is obese or not. The World Health Organization (WHO) defines obesity as a BMI greater than or equal to 30. We can create a new variable, obese, that indicates whether a person is obese based on their BMI.\ninsurance$obese &lt;- ifelse(insurance$bmi &gt;= 30, \"obese\", \"not obese\")\nIf we examine the dataset again, we can see that the new variable obese has been added to the dataset.\nhead(insurance)\n\n  age    sex    bmi children smoker    region   charges     obese\n1  19 female 27.900        0    yes southwest 16884.924 not obese\n2  18   male 33.770        1     no southeast  1725.552     obese\n3  28   male 33.000        3     no southeast  4449.462     obese\n4  33   male 22.705        0     no northwest 21984.471 not obese\n5  32   male 28.880        0     no northwest  3866.855 not obese\n6  31 female 25.740        0     no southeast  3756.622 not obese",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Plotting with ggplot2</span>"
    ]
  },
  {
    "objectID": "ggplot.html#data",
    "href": "ggplot.html#data",
    "title": "\n5  Plotting with ggplot2\n",
    "section": "",
    "text": "age\n\nage of primary beneficiary\n\n\n\nsex\n\ninsurance contractor gender, female, male\n\n\n\nbmi\n\nBody mass index, providing an understanding of body, weights that are relatively high or low relative to height, objective index of body weight (kg / m ^ 2) using the ratio of height to weight, ideally 18.5 to 24.9\n\n\n\nchildren\n\nNumber of children covered by health insurance / Number of dependents\n\n\n\nsmoker\n\nSmoking status\n\n\n\nregion\n\nthe beneficiary’s residential area in the US, northeast, southeast, southwest, northwest.\n\n\n\ncharges\n\nIndividual medical costs billed by health insurance\n\n\n\n\n1 Insurance data csv file, https://raw.githubusercontent.com/stedy/Machine-Learning-with-R-datasets/master/insurance.csv",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Plotting with ggplot2</span>"
    ]
  },
  {
    "objectID": "ggplot.html#aesthetics",
    "href": "ggplot.html#aesthetics",
    "title": "\n5  Plotting with ggplot2\n",
    "section": "\n5.2 Aesthetics",
    "text": "5.2 Aesthetics\nThe next step in creating a ggplot2 plot is to specify the aesthetics of the plot. Aesthetics are visual properties of the plot that map data to visual elements.\n\n# specify dataset and mapping\nlibrary(ggplot2)\nggplot(\n    data = insurance,\n    mapping = aes(x = age, y = charges)\n)\n\n\n\n\n\n\nFigure 5.2: A plot with age on the x-axis and charges on the y-axis.\n\n\n\n\nIn the code above, the data are the data to be visualized, and the mapping specifies how the data should be mapped to the plot. In this case, the x aesthetic is mapped to the age variable, and the y aesthetic is mapped to the charges variable. Note that there are no data displayed in Figure 5.2 yet; we have only specified the data and aesthetics. However, you can see the structure of the plot in the output, which shows the data and aesthetics that have been specified with age on the x-axis and charges on the y-axis.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Plotting with ggplot2</span>"
    ]
  },
  {
    "objectID": "ggplot.html#geometries",
    "href": "ggplot.html#geometries",
    "title": "\n5  Plotting with ggplot2\n",
    "section": "\n5.3 Geometries",
    "text": "5.3 Geometries\nThe next step is to add a geometry to the plot. Geometries are the visual representations of the data, such as points, lines, or bars. Since this is a scatter plot, we will use the geom_point() function to add points to the plot.\n\n# add points to the plot\nggplot(\n    data = insurance,\n    mapping = aes(x = age, y = charges)\n) +\n    geom_point()\n\n\n\n\n\n\nFigure 5.3: A scatter plot with age on the x-axis and charges on the y-axis results from adding geom_point() to the plot.\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nWhen using ggplot2, the + operator is used to add layers to the plot. The ggplot() function specifies the data and aesthetics, and the geom_point() function adds points to the plot. Using the + operator is a common practice in ggplot2 to add layers to a plot, but the + operator does not work for other types of plots in R.\n\n\nUsing other geometries, you can create different types of plots. For example, you can use geom_line() to create a line plot, geom_bar() to create a bar plot, or geom_boxplot() to create a box plot. Before doing so here, ask yourself if those geometries would be appropriate for the data you are working with.\nA number of parameters (options) can be specified in a geom_ function. Options for the geom_point() function include color, size, and alpha. These control the point color, size, and transparency, respectively. Transparency ranges from 0 (completely transparent) to 1 (completely opaque). Adding a degree of transparency can help visualize overlapping points such as in Figure 5.4.\n\n# add points to the plot\nggplot(\n    data = insurance,\n    mapping = aes(x = age, y = charges)\n) +\n    geom_point(\n        color = \"blue\",\n        size = 3,\n        alpha = 0.3\n    )\n\n\n\n\n\n\nFigure 5.4: A scatter plot with age on the x-axis and charges on the y-axis with colored points, larger size, and transparency.\n\n\n\n\nWe can add a best fit line to the scatter plot using the geom_smooth() function. The method parameter specifies the method used to fit the line. In this case, we will use the default method, which is linear regression, specified by method = \"lm\". The lm method fits a linear model to the data, which in this case is simple linear regression 2 of the dependent variable charges as a function of the independent variable age. The result is shown in Figure 5.5.\n2 The linear regression model is of the form \\(charges = \\alpha +  \\beta * age + \\epsilon\\) where \\(\\alpha\\) is the intercept, \\(\\beta\\) is the slope, and \\(\\epsilon\\) is the “error”.\n# add points and a best fit line to the plot\nggplot(\n    data = insurance,\n    mapping = aes(x = age, y = charges)\n) +\n    geom_point(\n        color = \"blue\",\n        alpha = 0.3\n    ) +\n    geom_smooth(method = \"lm\")\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\nFigure 5.5: A scatter plot with age on the x-axis and charges on the y-axis with a best fit line.\n\n\n\n\nWhat do you observe in Figure 5.5 with the best fit line? How well does the line fit the data? Do you think a linear model is appropriate for this data?",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Plotting with ggplot2</span>"
    ]
  },
  {
    "objectID": "ggplot.html#grouping",
    "href": "ggplot.html#grouping",
    "title": "\n5  Plotting with ggplot2\n",
    "section": "\n5.4 Grouping",
    "text": "5.4 Grouping\nIn addition to mapping variables to the x and y axes [i.e., aes(x = ..., y=...)], variables can be mapped to the color, shape, size, transparency, and other visual characteristics of geometric objects. This allows groups of observations to be superimposed in a single graph.\nFor example, we can map the smoker variable to the color of the points in the scatter plot. The result is shown in Figure 5.6.\n\n# add points to the plot, colored by the smoker variable\nggplot(\n    data = insurance,\n    mapping = aes(x = age, y = charges, color = smoker)\n) +\n    geom_point()\n\n\n\n\n\n\nFigure 5.6: A scatter plot with age on the x-axis and charges on the y-axis with points colored by the smoker variable.\n\n\n\n\nIn Figure 5.6, the points are colored based on the smoker variable, with smokers in orange and non-smokers in blue. This allows us to visually compare the charges of smokers and non-smokers as a function of age.\nIf we add back in the best fit line, we can see how the relationship between age and charges differs between smokers and non-smokers. The result is shown in Figure 5.7.\n\n# add points to the plot, colored by the smoker variable, and a best fit line\nggplot(\n    data = insurance,\n    mapping = aes(x = age, y = charges, color = smoker)\n) +\n    geom_point() +\n    geom_smooth(method = \"lm\")\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\nFigure 5.7: A scatter plot with age on the x-axis and charges on the y-axis with points colored by the smoker variable and a best fit line.\n\n\n\n\nHow well does the best fit line fit the data for smokers and non-smokers? Do you see any differences in the relationship between age and charges for smokers and non-smokers?",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Plotting with ggplot2</span>"
    ]
  },
  {
    "objectID": "ggplot.html#facets",
    "href": "ggplot.html#facets",
    "title": "\n5  Plotting with ggplot2\n",
    "section": "\n5.5 Facets",
    "text": "5.5 Facets\nFacets are a way to create multiple plots based on the levels of a categorical variable. In other words, facets allow you to create a grid of plots, with each plot showing a different subset of the data based on the levels of a categorical variable.\nIn Figure 5.7, we noticed that there are still two groups of points, even when looking at just smokers. We can further separate the data by the obese variable, creating a grid of plots with one plot for each combination of smoker and obese status.\n\n# add points to the plot, colored by the smoker variable, and faceted by the obese variable\nggplot(\n    data = insurance,\n    mapping = aes(x = age, y = charges, color = smoker)\n) +\n    geom_point() +\n    geom_smooth(method = \"lm\") +\n    facet_wrap(~obese)\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\nFigure 5.8: A grid of scatter plots with age on the x-axis and charges on the y-axis, colored by the smoker variable, and faceted by the obese variable.\n\n\n\n\nThe way that we interpret the facet_wrap(~ obese) command is that we want to create a grid of plots, with each plot showing a different subset of the data based on the levels of the obese variable. In this case, we have two levels of the obese variable: obese and not obese, so we get two plots in the grid.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Plotting with ggplot2</span>"
    ]
  },
  {
    "objectID": "ggplot.html#labels",
    "href": "ggplot.html#labels",
    "title": "\n5  Plotting with ggplot2\n",
    "section": "\n5.6 Labels",
    "text": "5.6 Labels\nLabels are an important part of any plot. They help the viewer understand what the plot is showing and what the axes represent. While our plot already has labels for the x and y axes, we can add a title to the plot and change the labels for the x and y axes to make them more descriptive.\n\n# add points to the plot, colored by the smoker variable, faceted by the obese variable, and add labels\nggplot(\n    data = insurance,\n    mapping = aes(x = age, y = charges, color = smoker)\n) +\n    geom_point() +\n    geom_smooth(method = \"lm\") +\n    facet_wrap(~obese) +\n    labs(\n        title = \"Medical Charges as a function of patient characteristics\",\n        subtitle = \"US Census Bureau 2013 data\",\n        caption = \"Source: https://github.com/stedy/Machine-Learning-with-R-datasets\",\n        x = \"Age\",\n        y = \"Annual Medical Charges\",\n        color = \"Smoker?\"\n    )\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\nFigure 5.9: A scatter plot with age on the x-axis and charges on the y-axis, colored by the smoker variable, and faceted by the obese variable, with labels.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Plotting with ggplot2</span>"
    ]
  },
  {
    "objectID": "ggplot.html#themes",
    "href": "ggplot.html#themes",
    "title": "\n5  Plotting with ggplot2\n",
    "section": "\n5.7 Themes",
    "text": "5.7 Themes\nThemes are a way to control the non-data ink in a plot, such as the background color, grid lines, and text size. Rather than specifying each element individually, you can use a pre-defined theme to quickly style your plot. For a nice overview of themes in ggplot2, see the the ggplot2 themes gallery.\nTo create a more visually appealing plot, we can apply the theme_minimal() theme to our plot. This theme removes the background grid lines and adds a light gray background to the plot.\n\n# add points to the plot, colored by the smoker variable, faceted by the obese variable, add labels, and apply a minimal theme\nggplot(\n    data = insurance,\n    mapping = aes(x = age, y = charges, color = smoker)\n) +\n    geom_point() +\n    geom_smooth(method = \"lm\") +\n    facet_wrap(~obese) +\n    labs(\n        title = \"Medical Charges as a function of patient characteristics\",\n        subtitle = \"US Census Bureau 2013 data\",\n        caption = \"Source: https://github.com/stedy/Machine-Learning-with-R-datasets\",\n        x = \"Age\",\n        y = \"Annual Medical Charges\",\n        color = \"Smoker?\"\n    ) +\n    theme_minimal()\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\nFigure 5.10: A scatter plot with age on the x-axis and charges on the y-axis, colored by the smoker variable, faceted by the obese variable, with labels and a minimal theme.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Plotting with ggplot2</span>"
    ]
  },
  {
    "objectID": "ggplot.html#saving-a-plot",
    "href": "ggplot.html#saving-a-plot",
    "title": "\n5  Plotting with ggplot2\n",
    "section": "\n5.8 Saving a Plot",
    "text": "5.8 Saving a Plot\nOnce you have created a plot that you are happy with, you may want to save it to a file for use in a report or presentation. The ggsave() function in ggplot2 allows you to save a plot to a file in a variety of formats, including PNG, PDF, and SVG. Take a look at the help for ggsave() to see the available options. In particular, you can specify the file name, width, height, and resolution of the saved plot.\n\n# save the plot to a file\nggsave(\"insurance_plot.png\")\n\nSaving 7 x 5 in image\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\nNote\n\n\n\nThe ggsave() function saves the last plot that you created with ggplot2. ggsave() will save the plot to the working directory by default, but you can specify a different directory by providing the full path to the file name.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Plotting with ggplot2</span>"
    ]
  },
  {
    "objectID": "ggplot.html#references",
    "href": "ggplot.html#references",
    "title": "\n5  Plotting with ggplot2\n",
    "section": "References",
    "text": "References\n\n\nCaron, Stéphane. 2018. “The Grammar of Graphics.” https://dotlayer.org/en/grammar-of-graphics/.\n\n\nWickham, Hadley. 2014. “Tidy Data.” Journal of\nStatistical Software, Articles 59 (10): 1–23. https://doi.org/10.18637/jss.v059.i10.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Plotting with ggplot2</span>"
    ]
  }
]