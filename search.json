[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduction to R for BigCare 2024",
    "section": "",
    "text": "Preface",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#who-is-this-book-for",
    "href": "index.html#who-is-this-book-for",
    "title": "Introduction to R for BigCare 2024",
    "section": "Who is this book for?",
    "text": "Who is this book for?\n\nPeople who want to learn data science\nPeople who want to teach data science\nPeople who want to learn how to teach data science\nPeople who want to learn how to learn data science",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#why-this-book",
    "href": "index.html#why-this-book",
    "title": "Introduction to R for BigCare 2024",
    "section": "Why this book?",
    "text": "Why this book?\nThis book is a collection of resources for learning R and Bioconductor. It is meant to be largely self-directed, but for those looking to teach data science, it can also be used as a guide for structuring a course. Material is a bit variable in terms of difficulty, prerequisites, and format which is a reflection of the organic creation of the material.\nStudents are encouraged to work with others to learn the material. Instructors are encouraged to use the material to create a course that is tailored to the needs of their students and to spend lots of time in 1:1 and small groups to support students in their learning. See below for additional thoughts on adult learning and how it relates to this material.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#adult-learners",
    "href": "index.html#adult-learners",
    "title": "Introduction to R for BigCare 2024",
    "section": "Adult learners",
    "text": "Adult learners\nAdult Learning Theory, also known as Andragogy, is the concept and practice of designing, developing, and delivering instructional experiences for adult learners. It is based on the belief that adults learn differently than children, and thus, require distinct approaches to engage, motivate, and retain information (Center 2016). The term was first introduced by Malcolm Knowles, an American educator who is known for his work in adult education (Knowles, Holton, and Swanson 2005).\nOne of the fundamental principles of Adult Learning Theory is that adults are self-directed learners. This means that we prefer to take control of our own learning process and set personal goals for themselves. We are motivated by our desire to solve problems or gain knowledge to improve our lives (see Figure 1). As a result, educational content for adults should be relevant and applicable to real-life situations. Furthermore, adult learners should be given opportunities to actively engage in the learning process by making choices, setting goals, and evaluating their progress.\n\n\n\n\n\nFigure 1: Why do adults choose to learn something?\n\n\nAnother key aspect of Adult Learning Theory is the role of experience. We bring a wealth of experience to the learning process, which serves as a resource for new learning. We often have well-established beliefs, values, and mental models that can influence our willingness to accept new ideas and concepts. Therefore, it is essential to acknowledge and respect our shared and unique past experiences and create an environment where we all feel comfortable sharing our perspectives.\nTo effectively learn as a group of adult learners, it is crucial to establish a collaborative learning environment that promotes open communication and fosters trust among participants. We all appreciate and strive for a respectful and supportive atmosphere where we can express our opinions without fear of judgment. Instructors should help facilitate discussions, encourage peer-to-peer interactions, and incorporate group activities and collaboration to capitalize on the collective knowledge of participants.\nAdditionally, adult learners often have multiple responsibilities outside of the learning environment, such as work and family commitments. As a result, we require flexible learning opportunities that accommodate busy schedules. Offering a variety of instructional formats, such as online modules, self-paced learning, or evening classes, can help ensure that adult learners have access to education despite any time constraints.\nAdult learners benefit from a learner-centered approach that focuses on the individual needs, preferences, and interests of each participant can greatly enhance the overall learning experience. In addition, we tend to be more intrinsically motivated to learn when we have a sense of autonomy and can practice and experiment (see Figure 2) with new concepts in a safe environment.\n\n\n\n\n\n\n\nFigure 2: How to stay stuck in data science (or anything). The “Read-Do” loop tends to deliver the best results. Too much reading between doing can be somewhat effective. Reading and simply copy-paste is probably the least effective. When working through material, experiment. Try to break things. Incorporate your own experience or applications whenever possible.\n\n\n\n\nUnderstanding Adult Learning Theory and its principles can significantly enhance the effectiveness of teaching and learning as adults. By respecting our autonomy, acknowledging our experiences, creating a supportive learning environment, offering flexible learning opportunities, and utilizing diverse teaching methods, we can better cater to the unique needs and preferences of adult learners.\nIn practice, that means that we will will not be prescriptive in our approach to teaching data science. We will not tell you what to do, but rather we will provide you with a variety of options and you can choose what works best for you. We will also provide you with a variety of resources and you can choose where to focus your time. Given that we cannot possibly cover everything, we will provide you with a framework for learning and you can fill in the gaps as you see fit. A key component of our success as adult learners is to gain the confidence to ask questions and problem-solve on our own.\n\n\n\n\n\n\nCenter, Pew Research. 2016. “Lifelong Learning and Technology.” Pew Research Center: Internet, Science & Tech. https://www.pewresearch.org/internet/2016/03/22/lifelong-learning-and-technology/.\n\n\nKnowles, Malcolm S., Elwood F. Holton, and Richard A. Swanson. 2005. The Adult Learner: The Definitive Classic in Adult Education and Human Resource Development. 6th ed. Amsterdam ; Boston: Elsevier.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "010_rstudio_and_r.html",
    "href": "010_rstudio_and_r.html",
    "title": "1  Introduction",
    "section": "",
    "text": "1.1 What is R?\nR is a programming language and software environment designed for statistical computing and graphics. It is widely used by statisticians, data scientists, and researchers for data analysis and visualization. R is an open-source language, which means it is free to use, modify, and distribute. Over the years, R has become particularly popular (see Figure 1.1) in the fields of genomics and bioinformatics, owing to its extensive libraries and powerful data manipulation capabilities.\nThe R language is a dialect of the S language, which was developed in the 1970s at Bell Laboratories. The first version of R was written by Robert Gentleman and Ross Ihaka and released in 1995 (see this slide deck for Ross Ihaka’s take on R’s history). Since then, R has been continuously developed by the R Core Team, a group of statisticians and computer scientists. The R Core Team releases a new version of R every year.",
    "crumbs": [
      "Getting started",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "010_rstudio_and_r.html#what-is-r",
    "href": "010_rstudio_and_r.html#what-is-r",
    "title": "1  Introduction",
    "section": "",
    "text": "Figure 1.1: Google trends showing the popularity of R over time based on Google searches.",
    "crumbs": [
      "Getting started",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "010_rstudio_and_r.html#why-use-r",
    "href": "010_rstudio_and_r.html#why-use-r",
    "title": "1  Introduction",
    "section": "1.2 Why use R?",
    "text": "1.2 Why use R?\nThere are several reasons why R is a popular choice for data analysis, particularly in genomics and bioinformatics. These include:\n\nOpen-source1: R is free to use and has a large community of developers who contribute to its growth and development. Open source software is software with source code that anyone can inspect, modify, and enhance.\nExtensive libraries: There are thousands of R packages available for a wide range of tasks, including specialized packages for genomics and bioinformatics. These libraries have been extensively tested and ara available for free.\nData manipulation: R has powerful data manipulation capabilities, making it easy (or at least possible) to clean, process, and analyze large datasets.\nGraphics and visualization: R has excellent tools for creating high-quality graphics and visualizations that can be customized to meet the specific needs of your analysis. In most cases, graphics produced by R are publication-quality.\nReproducible research: R enables you to create reproducible research by recording your analysis in a script, which can be easily shared and executed by others. In addition, R does not have a meaningful graphical user interface (GUI), which renders analysis in R much more reproducible than tools that rely on GUI interactions.\nCross-platform: R runs on Windows, Mac, and Linux (as well as more obscure systems).\nInteroperability with other languages: R can interfact with FORTRAN, C, and many other languages.\nScalability: R is useful for small and large projects. I can develop code for analysis on my Mac laptop. I can then install the same code on our 20k core cluster and run it in parallel on 100 samples, monitor the process, and then update a database (for example) with R when complete.\n\n1 Source code is the code computer programmers can manipulate to change how a piece of software—a “program” or “application”—works. Programmers who have access to a computer program’s source code can improve that program by adding features to it or fixing parts that don’t always work correctly. For more details, see what is “open-source”?",
    "crumbs": [
      "Getting started",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "010_rstudio_and_r.html#why-not-use-r",
    "href": "010_rstudio_and_r.html#why-not-use-r",
    "title": "1  Introduction",
    "section": "1.3 Why not use R?",
    "text": "1.3 Why not use R?\n\nR cannot do everything. There are some tasks that are better suited to other languages or tools. However, R can often be used to interface with these other tools.\nR is not always the “best” tool for the job. (However, it is often a “good” tool for the job.)\nR will not hold your hand. Often, it will slap your hand instead. In other words, R is not always user-friendly and can be difficult to learn. (We’ll try to make it easier for you in this book and by providing you with a good foundation for learning R and getting help when you need it.)\nThe documentation can be opaque (but there is documentation).\nR can drive you crazy (on a good day) or age you prematurely (on a bad one).\nFinding the right package to do the job you want to do can be challenging; worse, some contributed packages are unreliable or poorly documented.\nR does not have a meaningfully useful graphical user interface (GUI). If you are used to working with a GUI, you may find R difficult to use at first.\n\nAdditional reasons to consider other tools include access to expertise and support from colleagues and coworkers. If you are working in a group that uses python, for example, you may want to use python for your analysis to take advantage of the expertise of your colleagues.",
    "crumbs": [
      "Getting started",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "010_rstudio_and_r.html#r-license-and-the-open-source-ideal",
    "href": "010_rstudio_and_r.html#r-license-and-the-open-source-ideal",
    "title": "1  Introduction",
    "section": "1.4 R License and the Open Source Ideal",
    "text": "1.4 R License and the Open Source Ideal\nR is free (yes, totally free!) and distributed under GNU license. In particular, this license allows one to:\n\nDownload the source code\nModify the source code to your heart’s content\nDistribute the modified source code and even charge money for it, but you must distribute the modified source code under the original GNU license.\n\nThis license means that R will always be available, will always be open source, and can grow organically without constraint.",
    "crumbs": [
      "Getting started",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "010_rstudio_and_r.html#rstudio",
    "href": "010_rstudio_and_r.html#rstudio",
    "title": "1  Introduction",
    "section": "1.5 RStudio",
    "text": "1.5 RStudio\nRStudio is an integrated development environment (IDE) for R. RStudio also provides several other useful features, including a built-in console, syntax-highlighting editor, and tools for plotting, history, debugging, workspace management, and workspace viewing. RStudio is available in both free and commercial editions; the commercial edition provides some additional features, including support for multiple sessions and enhanced debugging. For the vast majority of users, the free version is more than sufficient.\n\n1.5.1 Getting started with RStudio\nTo get started with RStudio, you first need to install both R and RStudio on your computer. Follow these steps:\n\nDownload and install R from the official R website.\nDownload and install RStudio from the official RStudio website.\nLaunch RStudio. You should see the RStudio interface with four panels as shown in Figure 1.2.\n\n\n\n1.5.2 The RStudio Interface\nRStudio’s interface consists of four panels (see Figure 1.2) that provide different functionalities:\n\n\nConsole\n\nThis panel displays the R console, where you can enter and execute R commands directly. The console also shows the output of your code, error messages, and other information.\n\n\n\nSource\n\nThis panel is where you write and edit your R scripts. You can create new scripts, open existing ones, and run your code from this panel.\n\n\n\nEnvironment\n\nThis panel displays your current workspace, including all variables, data objects, and functions that you have created or loaded in your R session.\n\n\n\nPlots, Packages, Help, and Viewer\n\nThese panels display plots, installed packages, help files, and web content, respectively.\n\n\n\n\n\n\n\n\n\nFigure 1.2: The RStudio interface. In this layout, the source pane is in the upper left, the console is in the lower left, the environment panel is in the top right and the viewer/help/files panel is in the bottom right.\n\n\n\n\n\n\n\n\n\nDo I need to use RStudio?\n\n\n\nNo. You can use R without RStudio. Other interfaces, such as jupyter notebooks or VScode are great alternatives. However, RStudio makes it easy to write and execute R code, and it provides several useful features that are not available in the basic R console. Note that the only part of RStudio that is actually interacting with R directly is the console. The other panels are simply providing a GUI that enhances the user experience.\n\n\n\n\n\n\n\n\nCustomizing the RStudio Interface\n\n\n\nYou can customize the layout of RStudio to suit your preferences. To do so, go to Tools &gt; Global Options &gt; Appearance. Here, you can change the theme, font size, and panel layout. You can also resize the panels as needed to gain screen real estate (see Figure 1.3).\n\n\n\n\n\n\n\n\nFigure 1.3: Dealing with limited screen real estate can be a challenge, particularly when you want to open another window to, for example, view a web page. You can resize the panes by sliding the center divider (red arrows) or by clicking on the minimize/maximize buttons (see blue arrow).",
    "crumbs": [
      "Getting started",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "010_rstudio_and_r.html#summary",
    "href": "010_rstudio_and_r.html#summary",
    "title": "1  Introduction",
    "section": "1.6 Summary",
    "text": "1.6 Summary\nAt this point, you should have a working Rstudio installation on your computer. In the next chapter, we will discuss the basics of R programming, including how to perform simple calculations, create variables, and use functions.",
    "crumbs": [
      "Getting started",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "020_r_basics.html",
    "href": "020_r_basics.html",
    "title": "\n2  The R language\n",
    "section": "",
    "text": "2.1 The R User Interface\nThe RStudio interface is simple. You type R code into the bottom line of the RStudio console pane and then click Enter to run it. The code you type is called a command, because it will command your computer to do something for you. The line you type it into is called the command line.\nWhen you type a command at the prompt and hit Enter, your computer executes the command and shows you the results. Then RStudio displays a fresh prompt for your next command. For example, if you type 1 + 1 and hit Enter, RStudio will display:\nYou’ll notice that a [1] appears next to your result. R is just letting you know that this line begins with the first value in your result. Some commands return more than one value, and their results may fill up multiple lines. For example, the command 100:130 returns 31 values; it creates a sequence of integers from 100 to 130. Notice that new bracketed numbers appear at the start of the second and third lines of output. These numbers just mean that the second line begins with the 14th value in the result, and the third line begins with the 25th value. You can mostly ignore the numbers that appear in brackets:\nIf you type an incomplete command and press Enter, R will display a + prompt, which means R is waiting for you to type the rest of your command. Either finish the command or hit Escape to start over:\nIf you type a command that R doesn’t recognize, R will return an error message. If you ever see an error message, don’t panic. R is just telling you that your computer couldn’t understand or do what you asked it to do. You can then try a different command at the next prompt:\nOnce you get the hang of the command line, you can easily do anything in R that you would do with a calculator. For example, you could do some basic arithmetic:\n2 * 3   \n\n[1] 6\n\n4 - 1   \n\n[1] 3\n\n# this obeys order-of-operations\n6 / (4 - 1)   \n\n[1] 2\nMost of the arithmetic operators in R are the same as those on a calculator, but R uses different symbols for some of them:\nThe ^ operator raises the number to its left to the power of the number to its right: for example 3^2 is 9. The modulo returns the remainder of the division of the number to the left by the number on its right, for example 5 modulo 3 or 5 %% 3 is 2.",
    "crumbs": [
      "Getting started",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>The R language</span>"
    ]
  },
  {
    "objectID": "020_r_basics.html#the-r-user-interface",
    "href": "020_r_basics.html#the-r-user-interface",
    "title": "\n2  The R language\n",
    "section": "",
    "text": "Figure 2.1: Your computer does your bidding when you type R commands at the prompt in the bottom line of the console pane. Don’t forget to hit the Enter key. When you first open RStudio, the console appears in the pane on your left, but you can change this with File &gt; Tools &gt; Global Options in the menu bar.\n\n\n\n&gt; 1 + 1\n[1] 2\n&gt;\n\n&gt; 100:130\n [1] 100 101 102 103 104 105 106 107 108 109 110 111 112\n[14] 113 114 115 116 117 118 119 120 121 122 123 124 125\n[25] 126 127 128 129 130\n\n\n\n\n\n\nTip\n\n\n\nThe colon operator (:) returns every integer between two integers. It is an easy way to create a sequence of numbers.\n\n\n\n\n\n\n\n\nWhen do we compile?\n\n\n\nIn some languages, like C, Java, and FORTRAN, you have to compile your human-readable code into machine-readable code (often 1s and 0s) before you can run it. If you’ve programmed in such a language before, you may wonder whether you have to compile your R code before you can use it. The answer is no. R is a dynamic programming language, which means R automatically interprets your code as you run it.\n\n\n\n&gt; 5 -\n+\n+ 1\n[1] 4\n\n&gt; 3 % 5\nError: unexpected input in \"3 % 5\"\n&gt;\n\n\n\n\n\n\nTip\n\n\n\nWhenever you get an error message in R, consider googling the error message. You’ll often find that someone else has had the same problem and has posted a solution online. Simply cutting-and-pasting the error message into a search engine will often work\n\n\n\n\n\n\nAddition: +\n\nSubtraction: -\n\nMultiplication: *\n\nDivision: /\n\nExponentiation: ^\n\nModulo: %%\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nR treats the hashtag character, #, in a special way; R will not run anything that follows a hashtag on a line. This makes hashtags very useful for adding comments and annotations to your code. Humans will be able to read the comments, but your computer will pass over them. The hashtag is known as the commenting symbol in R.\n\n\n\n\n\n\n\n\nCancelling commands\n\n\n\nSome R commands may take a long time to run. You can cancel a command once it has begun by pressing ctrl + c or by clicking the “stop sign” if it is available in Rstudio. Note that it may also take R a long time to cancel the command.\n\n\n\n2.1.1 An exercise\nThat’s the basic interface for executing R code in RStudio. Think you have it? If so, try doing these simple tasks. If you execute everything correctly, you should end up with the same number that you started with:\n\nChoose any number and add 2 to it.\nMultiply the result by 3.\nSubtract 6 from the answer.\nDivide what you get by 3.\n\n\n10 + 2\n\n[1] 12\n\n12 * 3\n\n[1] 36\n\n36 - 6\n\n[1] 30\n\n30 / 3\n\n[1] 10",
    "crumbs": [
      "Getting started",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>The R language</span>"
    ]
  },
  {
    "objectID": "020_r_basics.html#objects",
    "href": "020_r_basics.html#objects",
    "title": "\n2  The R language\n",
    "section": "\n2.2 Objects",
    "text": "2.2 Objects\nNow that you know how to use R, let’s use it to make a virtual die. The : operator from a couple of pages ago gives you a nice way to create a group of numbers from one to six. The : operator returns its results as a vector (we are going to work with vectors in more detail), a one-dimensional set of numbers:\n1:6\n## 1 2 3 4 5 6\nThat’s all there is to how a virtual die looks! But you are not done yet. Running 1:6 generated a vector of numbers for you to see, but it didn’t save that vector anywhere for later use. If we want to use those numbers again, we’ll have to ask your computer to save them somewhere. You can do that by creating an R object.\nR lets you save data by storing it inside an R object. What is an object? Just a name that you can use to call up stored data. For example, you can save data into an object like a or b. Wherever R encounters the object, it will replace it with the data saved inside, like so:\n\na &lt;- 1\na\n\n[1] 1\n\n\n\na + 2\n\n[1] 3\n\n\n\n\n\n\n\n\nWhat just happened?\n\n\n\n\nTo create an R object, choose a name and then use the less-than symbol, &lt;, followed by a minus sign, -, to save data into it. This combination looks like an arrow, &lt;-. R will make an object, give it your name, and store in it whatever follows the arrow. So a &lt;- 1 stores 1 in an object named a.\nWhen you ask R what’s in a, R tells you on the next line.\nYou can use your object in new R commands, too. Since a previously stored the value of 1, you’re now adding 1 to 2.\n\n\n\n\n\n\n\n\n\nAssignment vs expressions\n\n\n\nEverything that you type into the R console can be assigned to one of two categories:\n\nAssignments\nExpressions\n\nAn expression is a command that tells R to do something. For example, 1 + 2 is an expression that tells R to add 1 and 2. When you type an expression into the R console, R will evaluate the expression and return the result. For example, if you type 1 + 2 into the R console, R will return 3. Expressions can have “side effects” but they don’t explicitly result in anything being added to R memory.\n\n5 + 2\n\n[1] 7\n\n28 %% 3\n\n[1] 1\n\n3^2\n\n[1] 9\n\n5 + 4 * 4 + 4 ^ 4 / 10\n\n[1] 46.6\n\n\nWhile using R as a calculator is interesting, to do useful and interesting things, we need to assign values to objects. To create objects, we need to give it a name followed by the assignment operator &lt;- (or, entirely equivalently, =) and the value we want to give it:\n\nweight_kg &lt;- 55\n\n\n\nSo, for another example, the following code would create an object named die that contains the numbers one through six. To see what is stored in an object, just type the object’s name by itself:\n\ndie &lt;- 1:6\ndie\n\n[1] 1 2 3 4 5 6\n\n\nWhen you create an object, the object will appear in the environment pane of RStudio, as shown in Figure 2.2. This pane will show you all of the objects you’ve created since opening RStudio.\n\n\n\n\n\nFigure 2.2: Assignment creates an object in the environment pane.\n\n\nYou can name an object in R almost anything you want, but there are a few rules. First, a name cannot start with a number. Second, a name cannot use some special symbols, like ^, !, $, @, +, -, /, or *:\n\n\nGood names\nNames that cause errors\n\n\n\na\n1trial\n\n\nb\n$\n\n\nFOO\n^mean\n\n\nmy_var\n2nd\n\n\n.day\n!bad\n\n\n\n\n\n\n\n\n\nCapitalization matters\n\n\n\nR is case-sensitive, so name and Name will refer to different objects:\n&gt; Name = 0\n&gt; Name + 1\n[1] 1\n&gt; name + 1\nError: object 'name' not found\nThe error above is a common one!\n\n\nFinally, R will overwrite any previous information stored in an object without asking you for permission. So, it is a good idea to not use names that are already taken:\n\nmy_number &lt;- 1\nmy_number \n\n[1] 1\n\n\n\nmy_number &lt;- 999\nmy_number\n\n[1] 999\n\n\nYou can see which object names you have already used with the function ls:\nls()\nYour environment will contain different names than mine, because you have probably created different objects.\nYou can also see which names you have used by examining RStudio’s environment pane.\nWe can remove an object from the environment using the rm function. For example, to create and then remove an object named to_disappear, you could run the following code:\nto_disappear &lt;- 1\nrm(to_disappear)\nto_disappear # this will return an error\nWe now have a virtual die that is stored in the computer’s memory and which has a name that we can use to refer to it. You can access it whenever you like by typing the word die.\nSo what can you do with this die? Quite a lot. R will replace an object with its contents whenever the object’s name appears in a command. So, for example, you can do all sorts of math with the die. Math isn’t so helpful for rolling dice, but manipulating sets of numbers will be your stock and trade as a data scientist. So let’s take a look at how to do that:\n\ndie - 1\n\n[1] 0 1 2 3 4 5\n\ndie / 2\n\n[1] 0.5 1.0 1.5 2.0 2.5 3.0\n\ndie * die\n\n[1]  1  4  9 16 25 36\n\n\nR uses element-wise execution when working with a vector like die. When you manipulate a set of numbers, R will apply the same operation to each element in the set. So for example, when you run die - 1, R subtracts one from each element of die.\nWhen you use two or more vectors in an operation, R will line up the vectors and perform a sequence of individual operations. For example, when you run die * die, R lines up the two die vectors and then multiplies the first element of vector 1 by the first element of vector 2. R then multiplies the second element of vector 1 by the second element of vector 2, and so on, until every element has been multiplied. The result will be a new vector the same length as the first two {Figure 2.3}.\n\n\n\n\n\nFigure 2.3: “When R performs element-wise execution, it matches up vectors and then manipulates each pair of elements independently.”\n\n\nIf you give R two vectors of unequal lengths, R will repeat the shorter vector until it is as long as the longer vector, and then do the math, as shown in Figure 2.4. This isn’t a permanent change–the shorter vector will be its original size after R does the math. If the length of the short vector does not divide evenly into the length of the long vector, R will return a warning message. This behavior is known as vector recycling, and it helps R do element-wise operations:\n\n1:2\n\n[1] 1 2\n\n1:4\n\n[1] 1 2 3 4\n\ndie\n\n[1] 1 2 3 4 5 6\n\ndie + 1:2\n\n[1] 2 4 4 6 6 8\n\ndie + 1:4\n\nWarning in die + 1:4: longer object length is not a multiple of shorter object\nlength\n\n\n[1] 2 4 6 8 6 8\n\n\n\n\n\n\n\nFigure 2.4: “R will repeat a short vector to do element-wise operations with two vectors of uneven lengths.”\n\n\nElement-wise operations are a very useful feature in R because they manipulate groups of values in an orderly way. When you start working with data sets, element-wise operations will ensure that values from one observation or case are only paired with values from the same observation or case. Element-wise operations also make it easier to write your own programs and functions in R.\n\n\n\n\n\n\nElement-wise operations are not matrix operations\n\n\n\nIt is important to know that operations with vectors are not the same that you might expect if you are expecting R to perform “matrix” operations. R can do inner multiplication with the %*% operator and outer multiplication with the %o% operator:\n# Inner product (1*1 + 2*2 + 3*3 + 4*4 + 5*5 + 6*6)\ndie %*% die\n# Outer product (will be a 6 x 6 matrix with \n#  all possible products of the two vectors)\ndie %o% die\n\n\nNow that you can do math with your die object, let’s look at how you could “roll” it. Rolling your die will require something more sophisticated than basic arithmetic; you’ll need to randomly select one of the die’s values. And for that, you will need a function.\nWhile we’ve seen functions already, the next section will discuss R functions more formally.",
    "crumbs": [
      "Getting started",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>The R language</span>"
    ]
  },
  {
    "objectID": "030_r_functions.html",
    "href": "030_r_functions.html",
    "title": "\n3  Using functions in R\n",
    "section": "",
    "text": "3.1 Function example: sample with replacement\nIf you set size = 2, you can almost simulate a pair of dice. Before we run that code, think for a minute why that might be the case. sample will return two numbers, one for each die:\nsample(die, size = 2)\n\n[1] 6 1\nI said this “almost” works because this method does something funny. If you use it many times, you’ll notice that the second die never has the same value as the first die, which means you’ll never roll something like a pair of threes or snake eyes. What is going on?\nBy default, sample builds a sample without replacement. To see what this means, imagine that sample places all of the values of die in a jar or urn. Then imagine that sample reaches into the jar and pulls out values one by one to build its sample. Once a value has been drawn from the jar, sample sets it aside. The value doesn’t go back into the jar, so it cannot be drawn again. So if sample selects a six on its first draw, it will not be able to select a six on the second draw; six is no longer in the jar to be selected. Although sample creates its sample electronically, it follows this seemingly physical behavior.\nOne side effect of this behavior is that each draw depends on the draws that come before it. In the real world, however, when you roll a pair of dice, each die is independent of the other. If the first die comes up six, it does not prevent the second die from coming up six. In fact, it doesn’t influence the second die in any way whatsoever. You can recreate this behavior in sample by adding the argument replace = TRUE:\nsample(die, size = 2, replace = TRUE)\n\n[1] 2 5\nThe argument replace = TRUE causes sample to sample with replacement. Our jar example provides a good way to understand the difference between sampling with replacement and without. When sample uses replacement, it draws a value from the jar and records the value. Then it puts the value back into the jar. In other words, sample replaces each value after each draw. As a result, sample may select the same value on the second draw. Each value has a chance of being selected each time. It is as if every draw were the first draw.\nSampling with replacement is an easy way to create independent random samples. Each value in your sample will be a sample of size one that is independent of the other values. This is the correct way to simulate a pair of dice:\nsample(die, size = 2, replace = TRUE)\n\n[1] 2 5\nCongratulate yourself; you’ve just run your first simulation in R! You now have a method for simulating the result of rolling a pair of dice. If you want to add up the dice, you can feed your result straight into the sum function:\ndice &lt;- sample(die, size = 2, replace = TRUE)\ndice\n\n[1] 3 1\n\nsum(dice)\n\n[1] 4\nWhat would happen if you call dice multiple times? Would R generate a new pair of dice values each time? Let’s give it a try:\ndice\n\n[1] 3 1\n\ndice\n\n[1] 3 1\n\ndice\n\n[1] 3 1\nThe name dice refers to a vector of two numbers. Calling more than once does not change the favlue. Each time you call dice, R will show you the result of that one time you called sample and saved the output to dice. R won’t rerun sample(die, 2, replace = TRUE) to create a new roll of the dice. Once you save a set of results to an R object, those results do not change.\nHowever, it would be convenient to have an object that can re-roll the dice whenever you call it. You can make such an object by writing your own R function.",
    "crumbs": [
      "Getting started",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Using functions in R</span>"
    ]
  },
  {
    "objectID": "030_r_functions.html#write-functions",
    "href": "030_r_functions.html#write-functions",
    "title": "\n3  Using functions in R\n",
    "section": "\n3.2 Writing Your Own Functions",
    "text": "3.2 Writing Your Own Functions\nTo recap, you already have working R code that simulates rolling a pair of dice:\n\ndie &lt;- 1:6\ndice &lt;- sample(die, size = 2, replace = TRUE)\nsum(dice)\n\n[1] 12\n\n\nYou can retype this code into the console anytime you want to re-roll your dice. However, this is an awkward way to work with the code. It would be easier to use your code if you wrapped it into its own function, which is exactly what we’ll do now. We’re going to write a function named roll that you can use to roll your virtual dice. When you’re finished, the function will work like this: each time you call roll(), R will return the sum of rolling two dice:\nroll()\n## 8 \n\nroll()\n## 3\n\nroll()\n## 7\nFunctions may seem mysterious or fancy, but they are just another type of R object. Instead of containing data, they contain code. This code is stored in a special format that makes it easy to reuse the code in new situations. You can write your own functions by recreating this format.\n\n3.2.1 The Function Constructor\nEvery function in R has three basic parts: a name, a body of code, and a set of arguments. To make your own function, you need to replicate these parts and store them in an R object, which you can do with the function function. To do this, call function() and follow it with a pair of braces, {}:\n\nmy_function &lt;- function() {}\n\nThis function, as written, doesn’t do anything (yet). However, it is a valid function. You can call it by typing its name followed by an open and closed parenthesis:\n\nmy_function()\n\nNULL\n\n\nfunction will build a function out of whatever R code you place between the braces. For example, you can turn your dice code into a function by calling:\n\nroll &lt;- function() {\n    die &lt;- 1:6\n    dice &lt;- sample(die, size = 2, replace = TRUE)\n    sum(dice)\n}\n\n\n\n\n\n\n\nIndentation and readability\n\n\n\nNotice each line of code between the braces is indented. This makes the code easier to read but has no impact on how the code runs. R ignores spaces and line breaks and executes one complete expression at a time. Note that in other languages like python, spacing is extremely important and part of the language.\n\n\nJust hit the Enter key between each line after the first brace, {. R will wait for you to type the last brace, }, before it responds.\nDon’t forget to save the output of function to an R object. This object will become your new function. To use it, write the object’s name followed by an open and closed parenthesis:\n\nroll()\n\n[1] 9\n\n\nYou can think of the parentheses as the “trigger” that causes R to run the function. If you type in a function’s name without the parentheses, R will show you the code that is stored inside the function. If you type in the name with the parentheses, R will run that code:\n\nroll\n\nfunction() {\n    die &lt;- 1:6\n    dice &lt;- sample(die, size = 2, replace = TRUE)\n    sum(dice)\n}\n\nroll()\n\n[1] 7\n\n\nThe code that you place inside your function is known as the body of the function. When you run a function in R, R will execute all of the code in the body and then return the result of the last line of code. If the last line of code doesn’t return a value, neither will your function, so you want to ensure that your final line of code returns a value. One way to check this is to think about what would happen if you ran the body of code line by line in the command line. Would R display a result after the last line, or would it not?\nHere’s some code that would display a result:\ndice\n1 + 1\nsqrt(2)\nAnd here’s some code that would not:\ndice &lt;- sample(die, size = 2, replace = TRUE)\ntwo &lt;- 1 + 1\na &lt;- sqrt(2)\nAgain, this is just showing the distinction between expressions and assignments.",
    "crumbs": [
      "Getting started",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Using functions in R</span>"
    ]
  },
  {
    "objectID": "030_r_functions.html#arguments",
    "href": "030_r_functions.html#arguments",
    "title": "\n3  Using functions in R\n",
    "section": "\n3.3 Arguments",
    "text": "3.3 Arguments\nWhat if we removed one line of code from our function and changed the name die to bones (just a name–don’t think of it as important), like this?\n\nroll2 &lt;- function() {\n    dice &lt;- sample(bones, size = 2, replace = TRUE)\n    sum(dice)\n}\n\nNow I’ll get an error when I run the function. The function needs the object bones to do its job, but there is no object named bones to be found (you can check by typing ls() which will show you the names in the environment, or memory).\nroll2()\n## Error in sample(bones, size = 2, replace = TRUE) : \n##   object 'bones' not found\nYou can supply bones when you call roll2 if you make bones an argument of the function. To do this, put the name bones in the parentheses that follow function when you define roll2:\n\nroll2 &lt;- function(bones) {\n    dice &lt;- sample(bones, size = 2, replace = TRUE)\n    sum(dice)\n}\n\nNow roll2 will work as long as you supply bones when you call the function. You can take advantage of this to roll different types of dice each time you call roll2.\nRemember, we’re rolling pairs of dice:\n\nroll2(bones = 1:4)\n\n[1] 5\n\nroll2(bones = 1:6)\n\n[1] 10\n\nroll2(1:20)\n\n[1] 11\n\n\nNotice that roll2 will still give an error if you do not supply a value for the bones argument when you call roll2:\nroll2()\n## Error in sample(bones, size = 2, replace = TRUE) : \n##   argument \"bones\" is missing, with no default\nYou can prevent this error by giving the bones argument a default value. To do this, set bones equal to a value when you define roll2:\n\nroll2 &lt;- function(bones = 1:6) {\n    dice &lt;- sample(bones, size = 2, replace = TRUE)\n    sum(dice)\n}\n\nNow you can supply a new value for bones if you like, and roll2 will use the default if you do not:\n\nroll2()\n\n[1] 3\n\n\nYou can give your functions as many arguments as you like. Just list their names, separated by commas, in the parentheses that follow function. When the function is run, R will replace each argument name in the function body with the value that the user supplies for the argument. If the user does not supply a value, R will replace the argument name with the argument’s default value (if you defined one).\nTo summarize, function helps you construct your own R functions. You create a body of code for your function to run by writing code between the braces that follow function. You create arguments for your function to use by supplying their names in the parentheses that follow function. Finally, you give your function a name by saving its output to an R object, as shown in Figure 3.2.\nOnce you’ve created your function, R will treat it like every other function in R. Think about how useful this is. Have you ever tried to create a new Excel option and add it to Microsoft’s menu bar? Or a new slide animation and add it to Powerpoint’s options? When you work with a programming language, you can do these types of things. As you learn to program in R, you will be able to create new, customized, reproducible tools for yourself whenever you like.\n\n\n\n\n\nFigure 3.2: “Every function in R has the same parts, and you can use function to create these parts. Assign the result to a name, so you can call the function later.”",
    "crumbs": [
      "Getting started",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Using functions in R</span>"
    ]
  },
  {
    "objectID": "050_r_scripts.html",
    "href": "050_r_scripts.html",
    "title": "4  R Scripts",
    "section": "",
    "text": "4.1 What are R Scripts?\nR scripts are text files containing a series of R commands and code that can be executed sequentially. They serve as a way to store, organize, and run R code in a reproducible manner. R scripts typically have a .R file extension and can be created and edited using any text editor or integrated development environment (IDE) like RStudio.",
    "crumbs": [
      "Getting started",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>R Scripts</span>"
    ]
  },
  {
    "objectID": "050_r_scripts.html#why-are-r-scripts-useful",
    "href": "050_r_scripts.html#why-are-r-scripts-useful",
    "title": "4  R Scripts",
    "section": "4.2 Why are R Scripts Useful?",
    "text": "4.2 Why are R Scripts Useful?\nR scripts offer several advantages for data analysis and programming:\n\nReproducibility: Scripts allow you to save and rerun your analysis, ensuring consistent results.\nOrganization: They help structure your work logically, making it easier to understand and maintain.\nEfficiency: You can execute multiple commands at once, saving time on repetitive tasks.\nCollaboration: Scripts can be easily shared with colleagues, promoting teamwork and knowledge transfer.\nVersion Control: They integrate well with version control systems like Git, allowing you to track changes over time.\nDocumentation: You can include comments in your scripts, explaining your thought process and methodology.",
    "crumbs": [
      "Getting started",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>R Scripts</span>"
    ]
  },
  {
    "objectID": "050_r_scripts.html#creating-an-r-script-using-rstudio",
    "href": "050_r_scripts.html#creating-an-r-script-using-rstudio",
    "title": "4  R Scripts",
    "section": "4.3 Creating an R Script Using RStudio",
    "text": "4.3 Creating an R Script Using RStudio\nTo create an R script in RStudio, follow these steps:\n\nOpen RStudio.\nClick on File &gt; New File &gt; R Script (or use the keyboard shortcut Ctrl+Shift+N on Windows/Linux, Cmd+Shift+N on Mac).\nA new untitled script will open in the editor pane.\nStart writing your R code in the script.\nTo save the script, click on File &gt; Save (or use Ctrl+S / Cmd+S) and choose a name and location for your file.\n\nHere’s a simple example of what your R script might look like:\n# This is a comment in R\n# Let's create a script that rolls a die.\ndie_roll &lt;- sample(1:6, 1, replace = TRUE)\nprint(paste(\"You rolled a\", die_roll))\n\n# Let's add our roll2() function to our script\nroll2 &lt;- function(bones = 1:6) {\n    dice &lt;- sample(bones, size = 2, replace = TRUE)\n    sum(dice)\n}\nPaste this code into your R script and save it with a meaningful name, such as roll_die.R. This script defines a die-rolling function roll2() and prints the result of a single die roll.\n\nTip: Use comments (lines starting with #) to explain your code and provide context for others (and your future self).",
    "crumbs": [
      "Getting started",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>R Scripts</span>"
    ]
  },
  {
    "objectID": "050_r_scripts.html#interacting-with",
    "href": "050_r_scripts.html#interacting-with",
    "title": "4  R Scripts",
    "section": "4.4 Interacting with",
    "text": "4.4 Interacting with",
    "crumbs": [
      "Getting started",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>R Scripts</span>"
    ]
  },
  {
    "objectID": "050_r_scripts.html#loading-an-r-script-after-saving",
    "href": "050_r_scripts.html#loading-an-r-script-after-saving",
    "title": "4  R Scripts",
    "section": "4.5 Loading an R Script After Saving",
    "text": "4.5 Loading an R Script After Saving\nOnce you’ve saved an R script, you can load and run it in several ways:\n\nUsing the source() function: This is the most common method to load and execute an R script.\nsource(\"path/to/your/script.R\")\nReplace “path/to/your/script.R” with the actual path to your saved script.\nIn RStudio:\n\nOpen the script file in RStudio.\nClick the “Source” button in the editor pane, or use the keyboard shortcut Ctrl+Shift+S (Windows/Linux) or Cmd+Shift+S (Mac).\n\nFrom the R console: You can also load a script directly from the R console:\nfile.edit(\"path/to/your/script.R\")\nThis will open the script in the editor, allowing you to review and modify it before running.\n\nRemember, when you load a script using source(), all the code in the script will be executed. If you only want to load the functions or objects defined in the script without running all the code, you can use the source() function with the local = TRUE argument:\nenv &lt;- new.env()\nsource(\"path/to/your/script.R\", local = env)\nThis loads the script’s contents into a new environment, allowing you to access its functions and objects without executing the entire script.\nBy mastering R scripts, you’ll be able to create more organized, reproducible, and efficient data analysis workflows in R.",
    "crumbs": [
      "Getting started",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>R Scripts</span>"
    ]
  },
  {
    "objectID": "chatbots.html",
    "href": "chatbots.html",
    "title": "5  Chatbots as Learning Tools",
    "section": "",
    "text": "ChatGPT, developed by OpenAI, and Claude, developed by Anthropic, are advanced language models that leverage deep learning techniques to understand and generate human-like text. At their core, these chatbots operate using a variant of the Transformer architecture, which enable them to process and generate text based on the patterns and structures they learn from vast amounts of training data. These models1 excels in natural language understanding and generation tasks, making them incredibly versatile tools for a wide range of applications beyond simple chat interactions.\n1 Foundation models are a recent development in AI. These models are developed from algorithms designed to optimize for generality and versatility of output. They are based on large-scale neural networks that are often trained on a broad range of data sources and large amounts of data to accomplish a wide range of downstream tasks, including some for which they were not specifically developed and trained.In the context of programming and coding, these chatbots serve as valuable assistants by providing explanations, examples, and guidance related to programming languages like R. Users can interact with a chatbot by posing questions or requesting code snippets, which they generate based on their understanding of the input and their extensive training data. For instance, users can inquire about specific syntax rules, algorithm implementations, or even debugging tips, and chatbots can respond with clear explanations and relevant examples. This capability makes them particularly useful for learners and developers seeking quick insights or clarification on complex programming concepts.\nMoreover, chatbots can facilitate learning and problem-solving by offering personalized responses tailored to the user’s queries. Their ability to generate coherent and contextually relevant text allows them to simulate a dialogue where they guides users through coding challenges or help them understand intricate programming concepts more intuitively. This makes chatbots not only a powerful tool for acquiring programming knowledge but also a supportive companion in the journey of mastering programming languages like R.\nIn this tutorial, we will explore how chatbots like ChatGPT and Claude can be leveraged as learning tools for programming in R. We will discuss their features, capabilities, and potential applications in the context of programming education. By the end of this tutorial, you will have a better understanding of how chatbots can enhance the learning experience and support your programming endeavors.\n\nFeatures of Chatbots\nChatbots like ChatGPT and Claude offer a range of features that make them valuable learning tools for programming in R. Some of the key features include:\n\nNatural Language Understanding: Chatbots can interpret and respond to user queries in natural language, making interactions more intuitive and user-friendly.\nCode Generation: Chatbots can generate code snippets, examples, and explanations based on the user’s input, helping users understand and implement programming concepts.\nPersonalized Responses: Chatbots can provide personalized responses tailored to the user’s queries, enhancing the learning experience and engagement.\nInteractive Learning: Chatbots can engage users in interactive learning experiences, guiding them through coding challenges and providing real-time feedback.\n24/7 Availability: Chatbots are available round the clock, allowing users to seek assistance and guidance at any time, making them convenient learning companions.\nExtensive Knowledge Base: Chatbots have access to vast amounts of training data and information, enabling them to provide accurate and up-to-date responses to user queries.\nScalability: Chatbots can scale to accommodate a large number of users simultaneously, making them suitable for both individual learners and educational institutions.\nFeedback and Evaluation: Chatbots can provide feedback and evaluation on user-generated code, helping users identify and correct errors in their programming assignments.\nMultimodal Capabilities: Chatbots can support multimodal interactions, such as text, voice, and visual inputs, enhancing the user experience and accessibility.\nContinuous Learning: Chatbots can continuously learn and improve their responses based on user interactions and feedback, ensuring that they stay relevant and up-to-date.",
    "crumbs": [
      "Getting started",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Chatbots as Learning Tools</span>"
    ]
  },
  {
    "objectID": "vectors.html",
    "href": "vectors.html",
    "title": "\n6  Vectors\n",
    "section": "",
    "text": "6.1 What is a Vector?\nA vector is the simplest and most basic data structure in R. It is a one-dimensional, ordered collection of elements, where all the elements are of the same data type. Vectors can store various types of data, such as numeric, character, or logical values. Figure 6.1 shows a pictorial representation of three vector examples.\nIn this chapter, we will provide a comprehensive overview of vectors, including how to create, access, and manipulate them. We will also discuss some unique properties and rules associated with vectors, and explore their applications in data analysis tasks.\nIn R, even a single value is a vector with length=1.\nz = 1\nz\n\n[1] 1\n\nlength(z)\n\n[1] 1\nIn the code above, we “assigned” the value 1 to the variable named z. Typing z by itself is an “expression” that returns a result which is, in this case, the value that we just assigned. The length method takes an R object and returns the R length. There are numerous ways of asking R about what an object represents, and length is one of them.\nVectors can contain numbers, strings (character data), or logical values (TRUE and FALSE) or other “atomic” data types Table 6.1. Vectors cannot contain a mix of types! We will introduce another data structure, the R list for situations when we need to store a mix of base R data types.",
    "crumbs": [
      "R data structures",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Vectors</span>"
    ]
  },
  {
    "objectID": "vectors.html#what-is-a-vector",
    "href": "vectors.html#what-is-a-vector",
    "title": "\n6  Vectors\n",
    "section": "",
    "text": "Figure 6.1: “Pictorial representation of three vector examples. The first vector is a numeric vector. The second is a ‘logical’ vector. The third is a character vector. Vectors also have indices and, optionally, names.”\n\n\n\n\n\n\n\n\n\n\n\nData type\nStores\n\n\n\nnumeric\nfloating point numbers\n\n\ninteger\nintegers\n\n\ncomplex\ncomplex numbers\n\n\nfactor\ncategorical data\n\n\ncharacter\nstrings\n\n\nlogical\nTRUE or FALSE\n\n\nNA\nmissing\n\n\nNULL\nempty\n\n\nfunction\nfunction type\n\n\n\n\n\nTable 6.1: Atomic (simplest) data types in R.",
    "crumbs": [
      "R data structures",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Vectors</span>"
    ]
  },
  {
    "objectID": "vectors.html#creating-vectors",
    "href": "vectors.html#creating-vectors",
    "title": "\n6  Vectors\n",
    "section": "\n6.2 Creating vectors",
    "text": "6.2 Creating vectors\nCharacter vectors (also sometimes called “string” vectors) are entered with each value surrounded by single or double quotes; either is acceptable, but they must match. They are always displayed by R with double quotes. Here are some examples of creating vectors:\n\n# examples of vectors\nc('hello','world')\n\n[1] \"hello\" \"world\"\n\nc(1,3,4,5,1,2)\n\n[1] 1 3 4 5 1 2\n\nc(1.12341e7,78234.126)\n\n[1] 11234100.00    78234.13\n\nc(TRUE,FALSE,TRUE,TRUE)\n\n[1]  TRUE FALSE  TRUE  TRUE\n\n# note how in the next case the TRUE is converted to \"TRUE\"\n# with quotes around it.\nc(TRUE,'hello')\n\n[1] \"TRUE\"  \"hello\"\n\n\nWe can also create vectors as “regular sequences” of numbers. For example:\n\n# create a vector of integers from 1 to 10\nx = 1:10\n# and backwards\nx = 10:1\n\nThe seq function can create more flexible regular sequences.\n\n# create a vector of numbers from 1 to 4 skipping by 0.3\ny = seq(1,4,0.3)\n\nAnd creating a new vector by concatenating existing vectors is possible, as well.\n\n# create a sequence by concatenating two other sequences\nz = c(y,x)\nz\n\n [1]  1.0  1.3  1.6  1.9  2.2  2.5  2.8  3.1  3.4  3.7  4.0 10.0  9.0  8.0  7.0\n[16]  6.0  5.0  4.0  3.0  2.0  1.0",
    "crumbs": [
      "R data structures",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Vectors</span>"
    ]
  },
  {
    "objectID": "vectors.html#vector-operations",
    "href": "vectors.html#vector-operations",
    "title": "\n6  Vectors\n",
    "section": "\n6.3 Vector Operations",
    "text": "6.3 Vector Operations\nOperations on a single vector are typically done element-by-element. For example, we can add 2 to a vector, 2 is added to each element of the vector and a new vector of the same length is returned.\n\nx = 1:10\nx + 2\n\n [1]  3  4  5  6  7  8  9 10 11 12\n\n\nIf the operation involves two vectors, the following rules apply. If the vectors are the same length: R simply applies the operation to each pair of elements.\n\nx + x\n\n [1]  2  4  6  8 10 12 14 16 18 20\n\n\nIf the vectors are different lengths, but one length a multiple of the other, R reuses the shorter vector as needed.\n\nx = 1:10\ny = c(1,2)\nx * y\n\n [1]  1  4  3  8  5 12  7 16  9 20\n\n\nIf the vectors are different lengths, but one length not a multiple of the other, R reuses the shorter vector as needed and delivers a warning.\n\nx = 1:10\ny = c(2,3,4)\nx * y\n\nWarning in x * y: longer object length is not a multiple of shorter object\nlength\n\n\n [1]  2  6 12  8 15 24 14 24 36 20\n\n\nTypical operations include multiplication (“*”), addition, subtraction, division, exponentiation (“^”), but many operations in R operate on vectors and are then called “vectorized”.\nBe aware of the recycling rule when working with vectors of different lengths, as it may lead to unexpected results if you’re not careful.",
    "crumbs": [
      "R data structures",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Vectors</span>"
    ]
  },
  {
    "objectID": "vectors.html#logical-vectors",
    "href": "vectors.html#logical-vectors",
    "title": "\n6  Vectors\n",
    "section": "\n6.4 Logical Vectors",
    "text": "6.4 Logical Vectors\nLogical vectors are vectors composed on only the values TRUE and FALSE. Note the all-upper-case and no quotation marks.\n\na = c(TRUE,FALSE,TRUE)\n\n# we can also create a logical vector from a numeric vector\n# 0 = false, everything else is 1\nb = c(1,0,217)\nd = as.logical(b)\nd\n\n[1]  TRUE FALSE  TRUE\n\n# test if a and d are the same at every element\nall.equal(a,d)\n\n[1] TRUE\n\n# We can also convert from logical to numeric\nas.numeric(a)\n\n[1] 1 0 1\n\n\n\n6.4.1 Logical Operators\nSome operators like &lt;, &gt;, ==, &gt;=, &lt;=, != can be used to create logical vectors.\n\n# create a numeric vector\nx = 1:10\n# testing whether x &gt; 5 creates a logical vector\nx &gt; 5\n\n [1] FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE\n\nx &lt;= 5\n\n [1]  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE\n\nx != 5\n\n [1]  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE\n\nx == 5\n\n [1] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE\n\n\nWe can also assign the results to a variable:\n\ny = (x == 5)\ny\n\n [1] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE",
    "crumbs": [
      "R data structures",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Vectors</span>"
    ]
  },
  {
    "objectID": "vectors.html#indexing-vectors",
    "href": "vectors.html#indexing-vectors",
    "title": "\n6  Vectors\n",
    "section": "\n6.5 Indexing Vectors",
    "text": "6.5 Indexing Vectors\nIn R, an index is used to refer to a specific element or set of elements in an vector (or other data structure). [R uses [ and ] to perform indexing, although other approaches to getting subsets of larger data structures are common in R.\n\nx = seq(0,1,0.1)\n# create a new vector from the 4th element of x\nx[4]\n\n[1] 0.3\n\n\nWe can even use other vectors to perform the “indexing”.\n\nx[c(3,5,6)]\n\n[1] 0.2 0.4 0.5\n\ny = 3:6\nx[y]\n\n[1] 0.2 0.3 0.4 0.5\n\n\nCombining the concept of indexing with the concept of logical vectors results in a very power combination.\n\n# use help('rnorm') to figure out what is happening next\nmyvec = rnorm(10)\n\n# create logical vector that is TRUE where myvec is &gt;0.25\ngt1 = (myvec &gt; 0.25)\nsum(gt1)\n\n[1] 3\n\n# and use our logical vector to create a vector of myvec values that are &gt;0.25\nmyvec[gt1]\n\n[1] 0.4006822 1.1104522 0.7408766\n\n# or &lt;=0.25 using the logical \"not\" operator, \"!\"\nmyvec[!gt1]\n\n[1] -0.2151871 -0.4960646  0.1520018 -0.4273520 -0.7806084 -0.1506650 -0.8171658\n\n# shorter, one line approach\nmyvec[myvec &gt; 0.25]\n\n[1] 0.4006822 1.1104522 0.7408766",
    "crumbs": [
      "R data structures",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Vectors</span>"
    ]
  },
  {
    "objectID": "vectors.html#named-vectors",
    "href": "vectors.html#named-vectors",
    "title": "\n6  Vectors\n",
    "section": "\n6.6 Named Vectors",
    "text": "6.6 Named Vectors\nNamed vectors are vectors with labels or names assigned to their elements. These names can be used to access and manipulate the elements in a more meaningful way.\nTo create a named vector, use the names() function:\n\nfruit_prices &lt;- c(0.5, 0.75, 1.25)\nnames(fruit_prices) &lt;- c(\"apple\", \"banana\", \"cherry\")\nprint(fruit_prices)\n\n apple banana cherry \n  0.50   0.75   1.25 \n\n\nYou can also access and modify elements using their names:\n\nbanana_price &lt;- fruit_prices[\"banana\"]\nprint(banana_price)\n\nbanana \n  0.75 \n\nfruit_prices[\"apple\"] &lt;- 0.6\nprint(fruit_prices)\n\n apple banana cherry \n  0.60   0.75   1.25",
    "crumbs": [
      "R data structures",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Vectors</span>"
    ]
  },
  {
    "objectID": "vectors.html#character-vectors-a.k.a.-strings",
    "href": "vectors.html#character-vectors-a.k.a.-strings",
    "title": "\n6  Vectors\n",
    "section": "\n6.7 Character Vectors, A.K.A. Strings",
    "text": "6.7 Character Vectors, A.K.A. Strings\nR uses the paste function to concatenate strings.\n\npaste(\"abc\",\"def\")\n\n[1] \"abc def\"\n\npaste(\"abc\",\"def\",sep=\"THISSEP\")\n\n[1] \"abcTHISSEPdef\"\n\npaste0(\"abc\",\"def\")\n\n[1] \"abcdef\"\n\n## [1] \"abcdef\"\npaste(c(\"X\",\"Y\"),1:10)\n\n [1] \"X 1\"  \"Y 2\"  \"X 3\"  \"Y 4\"  \"X 5\"  \"Y 6\"  \"X 7\"  \"Y 8\"  \"X 9\"  \"Y 10\"\n\npaste(c(\"X\",\"Y\"),1:10,sep=\"_\")\n\n [1] \"X_1\"  \"Y_2\"  \"X_3\"  \"Y_4\"  \"X_5\"  \"Y_6\"  \"X_7\"  \"Y_8\"  \"X_9\"  \"Y_10\"\n\n\nWe can count the number of characters in a string.\n\nnchar('abc')\n\n[1] 3\n\nnchar(c('abc','d',123456))\n\n[1] 3 1 6\n\n\nPulling out parts of strings is also sometimes useful.\n\nsubstr('This is a good sentence.',start=10,stop=15)\n\n[1] \" good \"\n\n\nAnother common operation is to replace something in a string with something (a find-and-replace).\n\nsub('This','That','This is a good sentence.')\n\n[1] \"That is a good sentence.\"\n\n\nWhen we want to find all strings that match some other string, we can use grep, or “grab regular expression”.\n\ngrep('bcd',c('abcdef','abcd','bcde','cdef','defg'))\n\n[1] 1 2 3\n\ngrep('bcd',c('abcdef','abcd','bcde','cdef','defg'),value=TRUE)\n\n[1] \"abcdef\" \"abcd\"   \"bcde\"  \n\n\nRead about the grepl function (?grepl). Use that function to return a logical vector (TRUE/FALSE) for each entry above with an a in it.",
    "crumbs": [
      "R data structures",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Vectors</span>"
    ]
  },
  {
    "objectID": "vectors.html#missing-values-aka-na",
    "href": "vectors.html#missing-values-aka-na",
    "title": "\n6  Vectors\n",
    "section": "\n6.8 Missing Values, AKA “NA”",
    "text": "6.8 Missing Values, AKA “NA”\nR has a special value, “NA”, that represents a “missing” value, or Not Available, in a vector or other data structure. Here, we just create a vector to experiment.\n\nx = 1:5\nx\n\n[1] 1 2 3 4 5\n\nlength(x)\n\n[1] 5\n\n\n\nis.na(x)\n\n[1] FALSE FALSE FALSE FALSE FALSE\n\nx[2] = NA\nx\n\n[1]  1 NA  3  4  5\n\n\nThe length of x is unchanged, but there is one value that is marked as “missing” by virtue of being NA.\n\nlength(x)\n\n[1] 5\n\nis.na(x)\n\n[1] FALSE  TRUE FALSE FALSE FALSE\n\n\nWe can remove NA values by using indexing. In the following, is.na(x) returns a logical vector the length of x. The ! is the logical NOT operator and converts TRUE to FALSE and vice-versa.\n\nx[!is.na(x)]\n\n[1] 1 3 4 5",
    "crumbs": [
      "R data structures",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Vectors</span>"
    ]
  },
  {
    "objectID": "vectors.html#exercises",
    "href": "vectors.html#exercises",
    "title": "\n6  Vectors\n",
    "section": "\n6.9 Exercises",
    "text": "6.9 Exercises\n\n\nCreate a numeric vector called temperatures containing the following values: 72, 75, 78, 81, 76, 73.\n\nShow answertemperatures &lt;- c(72, 75, 78, 81, 76, 73, 93)\n\n\n\n\nCreate a character vector called days containing the following values: “Monday”, “Tuesday”, “Wednesday”, “Thursday”, “Friday”, “Saturday”, “Sunday”.\n\nShow answerdays &lt;- c(\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\")\n\n\n\n\nCalculate the average temperature for the week and store it in a variable called average_temperature.\n\nShow answeraverage_temperature &lt;- mean(temperatures)\n\n\n\n\nCreate a named vector called weekly_temperatures, where the names are the days of the week and the values are the temperatures from the temperatures vector.\n\nShow answerweekly_temperatures &lt;- temperatures\nnames(weekly_temperatures) &lt;- days\n\n\n\n\nCreate a numeric vector called ages containing the following values: 25, 30, 35, 40, 45, 50, 55, 60.\n\nShow answerages &lt;- c(25, 30, 35, 40, 45, 50, 55, 60)\n\n\n\n\nCreate a logical vector called is_adult by checking if the elements in the ages vector are greater than or equal to 18.\n\nShow answeris_adult &lt;- ages &gt;= 18\n\n\n\n\nCalculate the sum and product of the ages vector.\n\nShow answersum_ages &lt;- sum(ages)\nproduct_ages &lt;- prod(ages)\n\n\n\n\nExtract the ages greater than or equal to 40 from the ages vector and store them in a variable called older_ages.\n\nShow answerolder_ages &lt;- ages[ages &gt;= 40]",
    "crumbs": [
      "R data structures",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Vectors</span>"
    ]
  },
  {
    "objectID": "matrices.html",
    "href": "matrices.html",
    "title": "\n7  Matrices\n",
    "section": "",
    "text": "7.1 Creating a matrix\nThere are many ways to create a matrix in R. One of the simplest is to use the matrix() function. In the code below, we’ll create a matrix from a vector from 1:16.\nmat1 &lt;- matrix(1:16,nrow=4)\nmat1\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    5    9   13\n[2,]    2    6   10   14\n[3,]    3    7   11   15\n[4,]    4    8   12   16\nThe same is possible, but specifying that the matrix be “filled” by row.\nmat1 &lt;- matrix(1:16,nrow=4,byrow = TRUE)\nmat1\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    2    3    4\n[2,]    5    6    7    8\n[3,]    9   10   11   12\n[4,]   13   14   15   16\nNotice the subtle difference in the order that the numbers go into the matrix.\nWe can also build a matrix from parts by “binding” vectors together:\nx &lt;- 1:10 \ny &lt;- rnorm(10)\nEach of the vectors above is of length 10 and both are “numeric”, so we can make them into a matrix. Using rbind binds rows (r) into a matrix.\nmat &lt;- rbind(x,y)\nmat\n\n       [,1]      [,2]      [,3]      [,4]       [,5]       [,6]        [,7]\nx  1.000000 2.0000000  3.000000  4.000000  5.0000000  6.0000000  7.00000000\ny -1.242246 0.4212412 -1.384561 -1.089551 -0.5584605 -0.5387635 -0.08298911\n        [,8]     [,9]      [,10]\nx  8.0000000 9.000000 10.0000000\ny -0.2699972 0.158617 -0.7754342\nThe alternative to rbind is cbind that binds columns (c) together.\nmat &lt;- cbind(x,y)\nmat\n\n       x           y\n [1,]  1 -1.24224616\n [2,]  2  0.42124122\n [3,]  3 -1.38456085\n [4,]  4 -1.08955148\n [5,]  5 -0.55846049\n [6,]  6 -0.53876355\n [7,]  7 -0.08298911\n [8,]  8 -0.26999721\n [9,]  9  0.15861701\n[10,] 10 -0.77543420\nInspecting the names associated with rows and columns is often useful, particularly if the names have human meaning.\nrownames(mat)\n\nNULL\n\ncolnames(mat)\n\n[1] \"x\" \"y\"\nWe can also change the names of the matrix by assigning valid names to the columns or rows.\ncolnames(mat) = c('apples','oranges')\ncolnames(mat)\n\n[1] \"apples\"  \"oranges\"\n\nmat\n\n      apples     oranges\n [1,]      1 -1.24224616\n [2,]      2  0.42124122\n [3,]      3 -1.38456085\n [4,]      4 -1.08955148\n [5,]      5 -0.55846049\n [6,]      6 -0.53876355\n [7,]      7 -0.08298911\n [8,]      8 -0.26999721\n [9,]      9  0.15861701\n[10,]     10 -0.77543420\nMatrices have dimensions.\ndim(mat)\n\n[1] 10  2\n\nnrow(mat)\n\n[1] 10\n\nncol(mat)\n\n[1] 2",
    "crumbs": [
      "R data structures",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Matrices</span>"
    ]
  },
  {
    "objectID": "matrices.html#accessing-elements-of-a-matrix",
    "href": "matrices.html#accessing-elements-of-a-matrix",
    "title": "\n7  Matrices\n",
    "section": "\n7.2 Accessing elements of a matrix",
    "text": "7.2 Accessing elements of a matrix\nIndexing for matrices works as for vectors except that we now need to include both the row and column (in that order). We can access elements of a matrix using the square bracket [ indexing method. Elements can be accessed as var[r, c]. Here, r and c are vectors describing the elements of the matrix to select.\n\n\n\n\n\n\nImportant\n\n\n\nThe indices in R start with one, meaning that the first element of a vector or the first row/column of a matrix is indexed as one.\nThis is different from some other programming languages, such as Python, which use zero-based indexing, meaning that the first element of a vector or the first row/column of a matrix is indexed as zero.\nIt is important to be aware of this difference when working with data in R, especially if you are coming from a programming background that uses zero-based indexing. Using the wrong index can lead to unexpected results or errors in your code.\n\n\n\n# The 2nd element of the 1st row of mat\nmat[1,2]\n\n  oranges \n-1.242246 \n\n# The first ROW of mat\nmat[1,]\n\n   apples   oranges \n 1.000000 -1.242246 \n\n# The first COLUMN of mat\nmat[,1]\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n# and all elements of mat that are &gt; 4; note no comma\nmat[mat&gt;4]\n\n[1]  5  6  7  8  9 10\n\n## [1]  5  6  7  8  9 10\n\n\n\n\n\n\n\nCaution\n\n\n\nNote that in the last case, there is no “,”, so R treats the matrix as a long vector (length=20). This is convenient, sometimes, but it can also be a source of error, as some code may “work” but be doing something unexpected.\n\n\nWe can also use indexing to exclude a row or column by prefixing the selection with a - sign.\n\nmat[,-1]       # remove first column\n\n [1] -1.24224616  0.42124122 -1.38456085 -1.08955148 -0.55846049 -0.53876355\n [7] -0.08298911 -0.26999721  0.15861701 -0.77543420\n\nmat[-c(1:5),]  # remove first five rows\n\n     apples     oranges\n[1,]      6 -0.53876355\n[2,]      7 -0.08298911\n[3,]      8 -0.26999721\n[4,]      9  0.15861701\n[5,]     10 -0.77543420",
    "crumbs": [
      "R data structures",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Matrices</span>"
    ]
  },
  {
    "objectID": "matrices.html#changing-values-in-a-matrix",
    "href": "matrices.html#changing-values-in-a-matrix",
    "title": "\n7  Matrices\n",
    "section": "\n7.3 Changing values in a matrix",
    "text": "7.3 Changing values in a matrix\nWe can create a matrix filled with random values drawn from a normal distribution for our work below.\n\nm = matrix(rnorm(20),nrow=10)\nsummary(m)\n\n       V1                V2          \n Min.   :-1.0300   Min.   :-2.15397  \n 1st Qu.:-0.3305   1st Qu.:-0.71562  \n Median : 0.2251   Median :-0.34666  \n Mean   : 0.1531   Mean   :-0.05151  \n 3rd Qu.: 0.7195   3rd Qu.: 0.47642  \n Max.   : 1.0355   Max.   : 1.89979  \n\n\nMultiplication and division works similarly to vectors. When multiplying by a vector, for example, the values of the vector are reused. In the simplest case, let’s multiply the matrix by a constant (vector of length 1).\n\n# multiply all values in the matrix by 20\nm2 = m*20\nsummary(m2)\n\n       V1                V2         \n Min.   :-20.600   Min.   :-43.079  \n 1st Qu.: -6.611   1st Qu.:-14.312  \n Median :  4.502   Median : -6.933  \n Mean   :  3.062   Mean   : -1.030  \n 3rd Qu.: 14.390   3rd Qu.:  9.528  \n Max.   : 20.710   Max.   : 37.996  \n\n\nBy combining subsetting with assignment, we can make changes to just part of a matrix.\n\n# and add 100 to the first column of m\nm2[,1] = m2[,1] + 100\n# summarize m\nsummary(m2)\n\n       V1               V2         \n Min.   : 79.40   Min.   :-43.079  \n 1st Qu.: 93.39   1st Qu.:-14.312  \n Median :104.50   Median : -6.933  \n Mean   :103.06   Mean   : -1.030  \n 3rd Qu.:114.39   3rd Qu.:  9.528  \n Max.   :120.71   Max.   : 37.996  \n\n\nA somewhat common transformation for a matrix is to transpose which changes rows to columns. One might need to do this if an assay output from a lab machine puts samples in rows and genes in columns, for example, while in Bioconductor/R, we often want the samples in columns and the genes in rows.\n\nt(m2)\n\n          [,1]      [,2]      [,3]      [,4]      [,5]      [,6]      [,7]\n[1,] 120.70952 116.08643  90.19520  84.13936 118.80807 109.30108 103.70224\n[2,]  37.99585 -43.07942 -12.60859 -11.79494  10.03705   8.00273 -14.88023\n          [,8]      [,9]      [,10]\n[1,] 102.97087  79.40020 105.302423\n[2,]  33.80008 -15.70405  -2.071414",
    "crumbs": [
      "R data structures",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Matrices</span>"
    ]
  },
  {
    "objectID": "matrices.html#calculations-on-matrix-rows-and-columns",
    "href": "matrices.html#calculations-on-matrix-rows-and-columns",
    "title": "\n7  Matrices\n",
    "section": "\n7.4 Calculations on matrix rows and columns",
    "text": "7.4 Calculations on matrix rows and columns\nAgain, we just need a matrix to play with. We’ll use rnorm again, but with a slight twist.\n\nm3 = matrix(rnorm(100,5,2),ncol=10) # what does the 5 mean here? And the 2?\n\nSince these data are from a normal distribution, we can look at a row (or column) to see what the mean and standard deviation are.\n\nmean(m3[,1])\n\n[1] 5.154723\n\nsd(m3[,1])\n\n[1] 1.653758\n\n# or a row\nmean(m3[1,])\n\n[1] 4.722864\n\nsd(m3[1,])\n\n[1] 2.488896\n\n\nThere are some useful convenience functions for computing means and sums of data in all of the columns and rows of matrices.\n\ncolMeans(m3)\n\n [1] 5.154723 5.085403 4.967522 4.649764 4.201678 4.511681 4.749455 5.827941\n [9] 4.138667 5.060760\n\nrowMeans(m3)\n\n [1] 4.722864 4.250791 4.444017 4.831249 5.175641 4.520627 5.332782 4.783828\n [9] 5.560902 4.724892\n\nrowSums(m3)\n\n [1] 47.22864 42.50791 44.44017 48.31249 51.75641 45.20627 53.32782 47.83828\n [9] 55.60902 47.24892\n\ncolSums(m3)\n\n [1] 51.54723 50.85403 49.67522 46.49764 42.01678 45.11681 47.49455 58.27941\n [9] 41.38667 50.60760\n\n\nWe can look at the distribution of column means:\n\n# save as a variable\ncmeans = colMeans(m3)\nsummary(cmeans)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  4.139   4.546   4.858   4.835   5.079   5.828 \n\n\nNote that this is centered pretty closely around the selected mean of 5 above.\nHow about the standard deviation? There is not a colSd function, but it turns out that we can easily apply functions that take vectors as input, like sd and “apply” them across either the rows (the first dimension) or columns (the second) dimension.\n\ncsds = apply(m3, 2, sd)\nsummary(csds)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  1.010   1.548   1.685   1.676   1.929   2.170 \n\n\nAgain, take a look at the distribution which is centered quite close to the selected standard deviation when we created our matrix.",
    "crumbs": [
      "R data structures",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Matrices</span>"
    ]
  },
  {
    "objectID": "matrices.html#exercises",
    "href": "matrices.html#exercises",
    "title": "\n7  Matrices\n",
    "section": "\n7.5 Exercises",
    "text": "7.5 Exercises\n\n7.5.1 Data preparation\nFor this set of exercises, we are going to rely on a dataset that comes with R. It gives the number of sunspots per month from 1749-1983. The dataset comes as a ts or time series data type which I convert to a matrix using the following code.\nJust run the code as is and focus on the rest of the exercises.\n\ndata(sunspots)\nsunspot_mat &lt;- matrix(as.vector(sunspots),ncol=12,byrow = TRUE)\ncolnames(sunspot_mat) &lt;- as.character(1:12)\nrownames(sunspot_mat) &lt;- as.character(1749:1983)\n\n\n7.5.2 Questions\n\n\nAfter the conversion above, what does sunspot_mat look like? Use functions to find the number of rows, the number of columns, the class, and some basic summary statistics.\n\nShow answerncol(sunspot_mat)\nnrow(sunspot_mat)\ndim(sunspot_mat)\nsummary(sunspot_mat)\nhead(sunspot_mat)\ntail(sunspot_mat)\n\n\n\n\nPractice subsetting the matrix a bit by selecting:\n\nThe first 10 years (rows)\nThe month of July (7th column)\nThe value for July, 1979 using the rowname to do the selection.\n\n\nShow answersunspot_mat[1:10,]\nsunspot_mat[,7]\nsunspot_mat['1979',7]\n\n\n\n\n\n\nThese next few exercises take advantage of the fact that calling a univariate statistical function (one that expects a vector) works for matrices by just making a vector of all the values in the matrix. What is the highest (max) number of sunspots recorded in these data?\n\nShow answermax(sunspot_mat)\n\n\n\n\nAnd the minimum?\n\nShow answermin(sunspot_mat)\n\n\n\n\nAnd the overall mean and median?\n\nShow answermean(sunspot_mat)\nmedian(sunspot_mat)\n\n\n\n\nUse the hist() function to look at the distribution of all the monthly sunspot data.\n\nShow answerhist(sunspot_mat)\n\n\n\n\nRead about the breaks argument to hist() to try to increase the number of breaks in the histogram to increase the resolution slightly. Adjust your hist() and breaks to your liking.\n\nShow answerhist(sunspot_mat, breaks=40)\n\n\n\n\nNow, let’s move on to summarizing the data a bit to learn about the pattern of sunspots varies by month or by year. Examine the dataset again. What do the columns represent? And the rows?\n\nShow answer# just a quick glimpse of the data will give us a sense\nhead(sunspot_mat)\n\n\n\n\nWe’d like to look at the distribution of sunspots by month. How can we do that?\n\nShow answer# the mean of the columns is the mean number of sunspots per month.\ncolMeans(sunspot_mat)\n\n# Another way to write the same thing:\napply(sunspot_mat, 2, mean)\n\n\n\n\nAssign the month summary above to a variable and summarize it to get a sense of the spread over months.\n\nShow answermonthmeans = colMeans(sunspot_mat)\nsummary(monthmeans)\n\n\n\n\nPlay the same game for years to get the per-year mean?\n\nShow answerymeans = rowMeans(sunspot_mat)\nsummary(ymeans)\n\n\n\n\nMake a plot of the yearly means. Do you see a pattern?\n\nShow answerplot(ymeans)\n# or make it clearer\nplot(ymeans, type='l')",
    "crumbs": [
      "R data structures",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Matrices</span>"
    ]
  },
  {
    "objectID": "dataframes_intro.html",
    "href": "dataframes_intro.html",
    "title": "\n8  Data Frames\n",
    "section": "",
    "text": "8.1 Dataset\nThe insurance dataset is described in the book Machine Learning with R by Brett Lantz. The dataset describes medical information and costs billed by health insurance companies for 1338 individuals in 2013, as compiled by the United States Census Bureau.\nVariables include:\nWe will load the data directly from the web, but you can also download the data from the link at github1.\ninsurance_url &lt;- \"https://raw.githubusercontent.com/stedy/Machine-Learning-with-R-datasets/master/insurance.csv\"\ninsurance &lt;- read.csv(insurance_url)\nExplore the dataset a bit to understand its structure and contents. For example, you can use the head() function to view the first few rows of the dataset.\nhead(insurance)\n\n  age    sex    bmi children smoker    region   charges\n1  19 female 27.900        0    yes southwest 16884.924\n2  18   male 33.770        1     no southeast  1725.552\n3  28   male 33.000        3     no southeast  4449.462\n4  33   male 22.705        0     no northwest 21984.471\n5  32   male 28.880        0     no northwest  3866.855\n6  31 female 25.740        0     no southeast  3756.622\nAnd you can examine the dimensions of the dataset using the dim(), which returns the number of rows and columns in the dataset, the ncol() function, which returns the number of columns, and the nrow() function, which returns the number of rows.\ndim(insurance)\n\n[1] 1338    7\n\nncol(insurance)\n\n[1] 7\n\nnrow(insurance)\n\n[1] 1338\nNote that with the dim() function, the number of rows is given first, followed by the number of columns.\nNotice that, while the BMI variable represents a measure of a person’s weight relative to their height, there is no discrete variable for whether a person is obese or not. The World Health Organization (WHO) defines obesity as a BMI greater than or equal to 30. We can create a new variable, obese, that indicates whether a person is obese based on their BMI.\ninsurance$obese &lt;- ifelse(insurance$bmi &gt;= 30, \"obese\", \"not obese\")\nIf we examine the dataset again, we can see that the new variable obese has been added to the dataset.\nhead(insurance)\n\n  age    sex    bmi children smoker    region   charges     obese\n1  19 female 27.900        0    yes southwest 16884.924 not obese\n2  18   male 33.770        1     no southeast  1725.552     obese\n3  28   male 33.000        3     no southeast  4449.462     obese\n4  33   male 22.705        0     no northwest 21984.471 not obese\n5  32   male 28.880        0     no northwest  3866.855 not obese\n6  31 female 25.740        0     no southeast  3756.622 not obese",
    "crumbs": [
      "R data structures",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Data Frames</span>"
    ]
  },
  {
    "objectID": "dataframes_intro.html#dataset",
    "href": "dataframes_intro.html#dataset",
    "title": "\n8  Data Frames\n",
    "section": "",
    "text": "age\n\nage of primary beneficiary\n\n\n\nsex\n\ninsurance contractor gender, female, male\n\n\n\nbmi\n\nBody mass index, providing an understanding of body, weights that are relatively high or low relative to height, objective index of body weight (kg / m ^ 2) using the ratio of height to weight, ideally 18.5 to 24.9\n\n\n\nchildren\n\nNumber of children covered by health insurance / Number of dependents\n\n\n\nsmoker\n\nSmoking status\n\n\n\nregion\n\nthe beneficiary’s residential area in the US, northeast, southeast, southwest, northwest.\n\n\n\ncharges\n\nIndividual medical costs billed by health insurance\n\n\n\n\n1 Insurance data csv file, https://raw.githubusercontent.com/stedy/Machine-Learning-with-R-datasets/master/insurance.csv",
    "crumbs": [
      "R data structures",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Data Frames</span>"
    ]
  },
  {
    "objectID": "dataframes_intro.html#inspecting-data.frames",
    "href": "dataframes_intro.html#inspecting-data.frames",
    "title": "\n8  Data Frames\n",
    "section": "\n8.2 Inspecting data.frames",
    "text": "8.2 Inspecting data.frames\nThere are a few functions that are useful for inspecting the contents of a data.frame:\n\nOverviews of content\n\n\nhead() to show first few rows\n\ntail() to show last few rows\n\n\nSize\n\n\ndim() for dimensions (rows, columns)\nnrow()\nncol()\n\nobject.size() for power users interested in the memory used to store an object\n\n\nData and attribute summaries\n\n\ncolnames() to get the names of the columns\n\nrownames() to get the “names” of the rows–may not be present\n\nsummary() to get per-column summaries of the data in the data.frame.\n\n\n\n\n# Show the first few rows\nhead(insurance)\n\n  age    sex    bmi children smoker    region   charges     obese\n1  19 female 27.900        0    yes southwest 16884.924 not obese\n2  18   male 33.770        1     no southeast  1725.552     obese\n3  28   male 33.000        3     no southeast  4449.462     obese\n4  33   male 22.705        0     no northwest 21984.471 not obese\n5  32   male 28.880        0     no northwest  3866.855 not obese\n6  31 female 25.740        0     no southeast  3756.622 not obese\n\n# Show the last few rows\ntail(insurance)\n\n     age    sex   bmi children smoker    region   charges     obese\n1333  52 female 44.70        3     no southwest 11411.685     obese\n1334  50   male 30.97        3     no northwest 10600.548     obese\n1335  18 female 31.92        0     no northeast  2205.981     obese\n1336  18 female 36.85        0     no southeast  1629.833     obese\n1337  21 female 25.80        0     no southwest  2007.945 not obese\n1338  61 female 29.07        0    yes northwest 29141.360 not obese\n\n# Get the dimensions of the data.frame\ndim(insurance)\n\n[1] 1338    8\n\n# Get the number of rows and columns\nnrow(insurance)\n\n[1] 1338\n\nncol(insurance)\n\n[1] 8\n\n# Get the names of the columns\ncolnames(insurance)\n\n[1] \"age\"      \"sex\"      \"bmi\"      \"children\" \"smoker\"   \"region\"   \"charges\" \n[8] \"obese\"   \n\n# Basic summary of the data\nsummary(insurance)\n\n      age            sex                 bmi           children    \n Min.   :18.00   Length:1338        Min.   :15.96   Min.   :0.000  \n 1st Qu.:27.00   Class :character   1st Qu.:26.30   1st Qu.:0.000  \n Median :39.00   Mode  :character   Median :30.40   Median :1.000  \n Mean   :39.21                      Mean   :30.66   Mean   :1.095  \n 3rd Qu.:51.00                      3rd Qu.:34.69   3rd Qu.:2.000  \n Max.   :64.00                      Max.   :53.13   Max.   :5.000  \n    smoker             region             charges         obese          \n Length:1338        Length:1338        Min.   : 1122   Length:1338       \n Class :character   Class :character   1st Qu.: 4740   Class :character  \n Mode  :character   Mode  :character   Median : 9382   Mode  :character  \n                                       Mean   :13270                     \n                                       3rd Qu.:16640                     \n                                       Max.   :63770                     \n\n\nIn RStudio, there is an additional function, View() (note the capital “V”) that opens the first 1000 rows (default) in the RStudio window, akin to a spreadsheet view.\n\nView(insurance)",
    "crumbs": [
      "R data structures",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Data Frames</span>"
    ]
  },
  {
    "objectID": "dataframes_intro.html#accessing-variables-columns-and-subsetting",
    "href": "dataframes_intro.html#accessing-variables-columns-and-subsetting",
    "title": "\n8  Data Frames\n",
    "section": "\n8.3 Accessing variables (columns) and subsetting",
    "text": "8.3 Accessing variables (columns) and subsetting\nIn R, data.frames can be subset similarly to other two-dimensional data structures. The [ in R is used to denote subsetting of any kind. When working with two-dimensional data, we need two values inside the [ ] to specify the details. The specification is [rows, columns]. For example, to get the first three rows of insurance, use:\n\ninsurance[1:3, ]\n\n  age    sex   bmi children smoker    region   charges     obese\n1  19 female 27.90        0    yes southwest 16884.924 not obese\n2  18   male 33.77        1     no southeast  1725.552     obese\n3  28   male 33.00        3     no southeast  4449.462     obese\n\n\nNote how the second number, the columns, is blank. R takes that to mean “all the columns”. Similarly, we can combine rows and columns specification arbitrarily.\n\ninsurance[1:3, 1:3]\n\n  age    sex   bmi\n1  19 female 27.90\n2  18   male 33.77\n3  28   male 33.00\n\n\nBecause selecting a single variable, or column, is such a common operation, there are two shortcuts for doing so with data.frames. The first, the $ operator works like so:\n\n# Look at the column names, just to refresh memory\ncolnames(insurance)\n\n[1] \"age\"      \"sex\"      \"bmi\"      \"children\" \"smoker\"   \"region\"   \"charges\" \n[8] \"obese\"   \n\n# Note that I am using \"head\" here to limit the output\nhead(insurance$age)\n\n[1] 19 18 28 33 32 31\n\n# What is the actual length of \"symbol\"?\nlength(insurance$age)\n\n[1] 1338\n\n\nThe second is related to the fact that, in R, data.frames are also lists. We subset a list by using [[]] notation. To get the second column of insurance, we can use:\n\nhead(insurance[[2]])\n\n[1] \"female\" \"male\"   \"male\"   \"male\"   \"male\"   \"female\"\n\n\nAlternatively, we can use the column name:\n\nhead(insurance[[\"age\"]])\n\n[1] 19 18 28 33 32 31\n\n\n\n8.3.1 Some data exploration\nThere are a couple of columns that include numeric values. Which columns are numeric?\n\nclass(insurance$age)\n\n[1] \"integer\"\n\nclass(insurance$obese)\n\n[1] \"character\"\n\nclass(insurance$children)\n\n[1] \"integer\"\n\n\n\nlibrary(gridExtra)\nlibrary(grid)\nlibrary(dplyr)\n\n\nAttaching package: 'dplyr'\n\n\nThe following object is masked from 'package:gridExtra':\n\n    combine\n\n\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n\n\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n\n# Original DataFrame\ndf &lt;- data.frame(\n    id = c(1, 2, 3, 4, 5),\n    name = c(\"Alice\", \"Bob\", \"Carol\", \"David\", \"Eve\"),\n    age = c(23, 25, 22, 24, 23),\n    score = c(88, 95, 78, 92, 85),\n    city = c(\"New York\", \"Chicago\", \"Boston\", \"Seattle\", \"Austin\")\n)\n\n# Filter\ndf_filtered &lt;- df %&gt;% filter(age &gt; 23)\n\n# Select\ndf_selected &lt;- df_filtered %&gt;% select(name, score)\n\n# Mutate\ndf_mutated &lt;- df_selected %&gt;% mutate(score_scaled = score / 100)\n\n# Arrange\ndf_arranged &lt;- df_mutated %&gt;% arrange(desc(score))\n\n# Summarize\ndf_grouped &lt;- df %&gt;%\n    group_by(city) %&gt;%\n    summarize(avg_score = mean(score))\n\n# Function to create table grobs\ncreate_table_grob &lt;- function(df, title) {\n    table_grob &lt;- tableGrob(df)\n    title_grob &lt;- textGrob(title, gp = gpar(fontsize = 16, fontface = \"bold\"))\n    padding &lt;- unit(0.5, \"line\")\n    table_grob &lt;- gtable::gtable_add_rows(table_grob, heights = grobHeight(title_grob) + padding, pos = 0)\n    table_grob &lt;- gtable::gtable_add_grob(table_grob, list(title_grob), 1, 1, 1, ncol(table_grob))\n    table_grob\n}\n\n# Creating table grobs\noriginal_grob &lt;- create_table_grob(df, \"Original DataFrame\")\nfiltered_grob &lt;- create_table_grob(df_filtered, \"Filtered (age &gt; 23)\")\nselected_grob &lt;- create_table_grob(df_selected, \"Selected (name, score)\")\nmutated_grob &lt;- create_table_grob(df_mutated, \"Mutated (score_scaled)\")\narranged_grob &lt;- create_table_grob(df_arranged, \"Arranged (by score)\")\nsummarized_grob &lt;- create_table_grob(df_grouped, \"Summarized (avg score by city)\")\n\n# Arrange tables in a grid\ngrid.arrange(\n    original_grob, filtered_grob,\n    selected_grob, mutated_grob,\n    arranged_grob, summarized_grob,\n    nrow = 6\n)",
    "crumbs": [
      "R data structures",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Data Frames</span>"
    ]
  },
  {
    "objectID": "040_stats.html",
    "href": "040_stats.html",
    "title": "\n9  Exploratory data analysis\n",
    "section": "",
    "text": "9.1 Explore each variable (column)\nWhen presented with a dataframe like the insurance data, we may want to interrogate the various columns to figure out what is in them. In this dataset, the columns are of two flavors. We can use the terms column and variable interchangably here since each column represents the measurements of that variable on a person.\nThe sex, smoker, and region variables are all categorical variables, in that they represent categories of “sex”, “smoker”, and “region”. The age, bmi, children, and charge variables represent numbers.",
    "crumbs": [
      "Exploring data",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Exploratory data analysis</span>"
    ]
  },
  {
    "objectID": "040_stats.html#explore-each-variable-column",
    "href": "040_stats.html#explore-each-variable-column",
    "title": "\n9  Exploratory data analysis\n",
    "section": "",
    "text": "9.1.1 Categorical variables\nFor categorial variables, there are some useful functions to help summarize the data. But to do so, we need to be able to pull out the individual columns. Let’s take the “region” column as an example. All of the following will get us the region column.\n\ninsurance$region\ninsurance[[\"region\"]]\ninsurance[, \"region\"]\n\nThe unique() function returns all unique values of a variable. The table() function counts the number of each value. While min() and max() are perhaps not that meaningful, they can sometimes be useful, even for categorical variables.\nLet’s apply these to the region variable/column.\n\nunique(insurance$region)\n\n[1] \"southwest\" \"southeast\" \"northwest\" \"northeast\"\n\ntable(insurance[[\"region\"]])\n\n\nnortheast northwest southeast southwest \n      324       325       364       325 \n\nmin(insurance$region)\n\n[1] \"northeast\"\n\nmax(insurance$region)\n\n[1] \"southwest\"\n\n\nCan you explain what the min() and max() are doing here?\nDo the same exercise with sex, smoker, and obese variables.\n\n9.1.2 Numeric variables\nThe other variables in our insurance dataset are numeric. Note that they are not all continuous numbers, though, with some of them being quite discrete (there are no fractional numbers of children).\nFor numerical variables, we can start to use statistics to summarize the data.\n\n\n\n\n\n\nWhat is a statistic?\n\n\n\nA statistic is a single value that summarizes a dataset. We use them all the time in data analysis. The mean, median, standard deviation, mode, etc. are all univariate statistics. Correlation is an example of a bivariate statistic that summarizes the relationship between two variables. Statistics like the t-statistic summarize the differences in centrality between two samples.\n\n\nThe summary() function gets us a bunch of statistics quickly.\n\nsummary(insurance)\n\n      age            sex                 bmi           children    \n Min.   :18.00   Length:1338        Min.   :15.96   Min.   :0.000  \n 1st Qu.:27.00   Class :character   1st Qu.:26.30   1st Qu.:0.000  \n Median :39.00   Mode  :character   Median :30.40   Median :1.000  \n Mean   :39.21                      Mean   :30.66   Mean   :1.095  \n 3rd Qu.:51.00                      3rd Qu.:34.69   3rd Qu.:2.000  \n Max.   :64.00                      Max.   :53.13   Max.   :5.000  \n    smoker             region             charges         obese          \n Length:1338        Length:1338        Min.   : 1122   Length:1338       \n Class :character   Class :character   1st Qu.: 4740   Class :character  \n Mode  :character   Mode  :character   Median : 9382   Mode  :character  \n                                       Mean   :13270                     \n                                       3rd Qu.:16640                     \n                                       Max.   :63770                     \n\n\nWe can also apply individual statistical measures to a single column.\n\nmean(insurance$age)\n\n[1] 39.20703\n\n\nAnd even though the children variable/column is a numeric column, we may still be interested in the unique values or a table showing the distribution of the number of children per patient.\n\nunique(insurance$children)\n\n[1] 0 1 3 2 5 4\n\ntable(insurance$children)\n\n\n  0   1   2   3   4   5 \n574 324 240 157  25  18 \n\n\nWe may also be interested in seeing the distribution of a numeric variable graphically. The histogram hist() is probably the most common way of examining the distribution of a numeric variable.\n\nhist(insurance$charges)\n\n\n\n\n\n\n\nPlot the historgram of the other numeric variables.\nAnother approach is to use a boxplot.\n\nboxplot(insurance$age)\n\n\n\n\n\n\n\n\n9.1.3 Correlation\n\n9.1.4 Hypothesis testing",
    "crumbs": [
      "Exploring data",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Exploratory data analysis</span>"
    ]
  },
  {
    "objectID": "ggplot.html",
    "href": "ggplot.html",
    "title": "\n10  Plotting with ggplot2\n",
    "section": "",
    "text": "10.1 Data\nThe first step in creating a ggplot2 plot is to specify the data to be visualized. The data should be in a tidy format (Wickham (2014)), with each row representing an observation and each column representing a variable. The insurance dataset is described in the book Machine Learning with R by Brett Lantz. The dataset describes medical information and costs billed by health insurance companies for 1338 individuals in 2013, as compiled by the United States Census Bureau.\nVariables include:\nWe will load the data directly from the web, but you can also download the data from the link at github1.\ninsurance_url &lt;- \"https://raw.githubusercontent.com/stedy/Machine-Learning-with-R-datasets/master/insurance.csv\"\ninsurance &lt;- read.csv(insurance_url)\nExplore the dataset a bit to understand its structure and contents. For example, you can use the head() function to view the first few rows of the dataset.\nhead(insurance)\n\n  age    sex    bmi children smoker    region   charges\n1  19 female 27.900        0    yes southwest 16884.924\n2  18   male 33.770        1     no southeast  1725.552\n3  28   male 33.000        3     no southeast  4449.462\n4  33   male 22.705        0     no northwest 21984.471\n5  32   male 28.880        0     no northwest  3866.855\n6  31 female 25.740        0     no southeast  3756.622\nAnd you can examine the dimensions of the dataset using the dim(), which returns the number of rows and columns in the dataset, the ncol() function, which returns the number of columns, and the nrow() function, which returns the number of rows.\ndim(insurance)\n\n[1] 1338    7\n\nncol(insurance)\n\n[1] 7\n\nnrow(insurance)\n\n[1] 1338\nNote that with the dim() function, the number of rows is given first, followed by the number of columns.\nNotice that, while the BMI variable represents a measure of a person’s weight relative to their height, there is no discrete variable for whether a person is obese or not. The World Health Organization (WHO) defines obesity as a BMI greater than or equal to 30. We can create a new variable, obese, that indicates whether a person is obese based on their BMI.\ninsurance$obese &lt;- ifelse(insurance$bmi &gt;= 30, \"obese\", \"not obese\")\nIf we examine the dataset again, we can see that the new variable obese has been added to the dataset.\nhead(insurance)\n\n  age    sex    bmi children smoker    region   charges     obese\n1  19 female 27.900        0    yes southwest 16884.924 not obese\n2  18   male 33.770        1     no southeast  1725.552     obese\n3  28   male 33.000        3     no southeast  4449.462     obese\n4  33   male 22.705        0     no northwest 21984.471 not obese\n5  32   male 28.880        0     no northwest  3866.855 not obese\n6  31 female 25.740        0     no southeast  3756.622 not obese",
    "crumbs": [
      "Exploring data",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Plotting with ggplot2</span>"
    ]
  },
  {
    "objectID": "ggplot.html#data",
    "href": "ggplot.html#data",
    "title": "\n10  Plotting with ggplot2\n",
    "section": "",
    "text": "age\n\nage of primary beneficiary\n\n\n\nsex\n\ninsurance contractor gender, female, male\n\n\n\nbmi\n\nBody mass index, providing an understanding of body, weights that are relatively high or low relative to height, objective index of body weight (kg / m ^ 2) using the ratio of height to weight, ideally 18.5 to 24.9\n\n\n\nchildren\n\nNumber of children covered by health insurance / Number of dependents\n\n\n\nsmoker\n\nSmoking status\n\n\n\nregion\n\nthe beneficiary’s residential area in the US, northeast, southeast, southwest, northwest.\n\n\n\ncharges\n\nIndividual medical costs billed by health insurance\n\n\n\n\n1 Insurance data csv file, https://raw.githubusercontent.com/stedy/Machine-Learning-with-R-datasets/master/insurance.csv",
    "crumbs": [
      "Exploring data",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Plotting with ggplot2</span>"
    ]
  },
  {
    "objectID": "ggplot.html#aesthetics",
    "href": "ggplot.html#aesthetics",
    "title": "\n10  Plotting with ggplot2\n",
    "section": "\n10.2 Aesthetics",
    "text": "10.2 Aesthetics\nThe next step in creating a ggplot2 plot is to specify the aesthetics of the plot. Aesthetics are visual properties of the plot that map data to visual elements.\n\n# specify dataset and mapping\nlibrary(ggplot2)\nggplot(\n    data = insurance,\n    mapping = aes(x = age, y = charges)\n)\n\n\n\n\n\n\nFigure 10.2: A plot with age on the x-axis and charges on the y-axis.\n\n\n\n\nIn the code above, the data are the data to be visualized, and the mapping specifies how the data should be mapped to the plot. In this case, the x aesthetic is mapped to the age variable, and the y aesthetic is mapped to the charges variable. Note that there are no data displayed in Figure 10.2 yet; we have only specified the data and aesthetics. However, you can see the structure of the plot in the output, which shows the data and aesthetics that have been specified with age on the x-axis and charges on the y-axis.",
    "crumbs": [
      "Exploring data",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Plotting with ggplot2</span>"
    ]
  },
  {
    "objectID": "ggplot.html#geometries",
    "href": "ggplot.html#geometries",
    "title": "\n10  Plotting with ggplot2\n",
    "section": "\n10.3 Geometries",
    "text": "10.3 Geometries\nThe next step is to add a geometry to the plot. Geometries are the visual representations of the data, such as points, lines, or bars. Since this is a scatter plot, we will use the geom_point() function to add points to the plot.\n\n# add points to the plot\nggplot(\n    data = insurance,\n    mapping = aes(x = age, y = charges)\n) +\n    geom_point()\n\n\n\n\n\n\nFigure 10.3: A scatter plot with age on the x-axis and charges on the y-axis results from adding geom_point() to the plot.\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nWhen using ggplot2, the + operator is used to add layers to the plot. The ggplot() function specifies the data and aesthetics, and the geom_point() function adds points to the plot. Using the + operator is a common practice in ggplot2 to add layers to a plot, but the + operator does not work for other types of plots in R.\n\n\nUsing other geometries, you can create different types of plots. For example, you can use geom_line() to create a line plot, geom_bar() to create a bar plot, or geom_boxplot() to create a box plot. Before doing so here, ask yourself if those geometries would be appropriate for the data you are working with.\nA number of parameters (options) can be specified in a geom_ function. Options for the geom_point() function include color, size, and alpha. These control the point color, size, and transparency, respectively. Transparency ranges from 0 (completely transparent) to 1 (completely opaque). Adding a degree of transparency can help visualize overlapping points such as in Figure 10.4.\n\n# add points to the plot\nggplot(\n    data = insurance,\n    mapping = aes(x = age, y = charges)\n) +\n    geom_point(\n        color = \"blue\",\n        size = 3,\n        alpha = 0.3\n    )\n\n\n\n\n\n\nFigure 10.4: A scatter plot with age on the x-axis and charges on the y-axis with colored points, larger size, and transparency.\n\n\n\n\nWe can add a best fit line to the scatter plot using the geom_smooth() function. The method parameter specifies the method used to fit the line. In this case, we will use the default method, which is linear regression, specified by method = \"lm\". The lm method fits a linear model to the data, which in this case is simple linear regression 2 of the dependent variable charges as a function of the independent variable age. The result is shown in Figure 10.5.\n2 The linear regression model is of the form \\(charges = \\alpha +  \\beta * age + \\epsilon\\) where \\(\\alpha\\) is the intercept, \\(\\beta\\) is the slope, and \\(\\epsilon\\) is the “error”.\n# add points and a best fit line to the plot\nggplot(\n    data = insurance,\n    mapping = aes(x = age, y = charges)\n) +\n    geom_point(\n        color = \"blue\",\n        alpha = 0.3\n    ) +\n    geom_smooth(method = \"lm\")\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\nFigure 10.5: A scatter plot with age on the x-axis and charges on the y-axis with a best fit line.\n\n\n\n\nWhat do you observe in Figure 10.5 with the best fit line? How well does the line fit the data? Do you think a linear model is appropriate for this data?",
    "crumbs": [
      "Exploring data",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Plotting with ggplot2</span>"
    ]
  },
  {
    "objectID": "ggplot.html#grouping",
    "href": "ggplot.html#grouping",
    "title": "\n10  Plotting with ggplot2\n",
    "section": "\n10.4 Grouping",
    "text": "10.4 Grouping\nIn addition to mapping variables to the x and y axes [i.e., aes(x = ..., y=...)], variables can be mapped to the color, shape, size, transparency, and other visual characteristics of geometric objects. This allows groups of observations to be superimposed in a single graph.\nFor example, we can map the smoker variable to the color of the points in the scatter plot. The result is shown in Figure 10.6.\n\n# add points to the plot, colored by the smoker variable\nggplot(\n    data = insurance,\n    mapping = aes(x = age, y = charges, color = smoker)\n) +\n    geom_point()\n\n\n\n\n\n\nFigure 10.6: A scatter plot with age on the x-axis and charges on the y-axis with points colored by the smoker variable.\n\n\n\n\nIn Figure 10.6, the points are colored based on the smoker variable, with smokers in orange and non-smokers in blue. This allows us to visually compare the charges of smokers and non-smokers as a function of age.\nIf we add back in the best fit line, we can see how the relationship between age and charges differs between smokers and non-smokers. The result is shown in Figure 10.7.\n\n# add points to the plot, colored by the smoker variable, and a best fit line\nggplot(\n    data = insurance,\n    mapping = aes(x = age, y = charges, color = smoker)\n) +\n    geom_point() +\n    geom_smooth(method = \"lm\")\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\nFigure 10.7: A scatter plot with age on the x-axis and charges on the y-axis with points colored by the smoker variable and a best fit line.\n\n\n\n\nHow well does the best fit line fit the data for smokers and non-smokers? Do you see any differences in the relationship between age and charges for smokers and non-smokers?",
    "crumbs": [
      "Exploring data",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Plotting with ggplot2</span>"
    ]
  },
  {
    "objectID": "ggplot.html#facets",
    "href": "ggplot.html#facets",
    "title": "\n10  Plotting with ggplot2\n",
    "section": "\n10.5 Facets",
    "text": "10.5 Facets\nFacets are a way to create multiple plots based on the levels of a categorical variable. In other words, facets allow you to create a grid of plots, with each plot showing a different subset of the data based on the levels of a categorical variable.\nIn Figure 10.7, we noticed that there are still two groups of points, even when looking at just smokers. We can further separate the data by the obese variable, creating a grid of plots with one plot for each combination of smoker and obese status.\n\n# add points to the plot, colored by the smoker variable, and faceted by the obese variable\nggplot(\n    data = insurance,\n    mapping = aes(x = age, y = charges, color = smoker)\n) +\n    geom_point() +\n    geom_smooth(method = \"lm\") +\n    facet_wrap(~obese)\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\nFigure 10.8: A grid of scatter plots with age on the x-axis and charges on the y-axis, colored by the smoker variable, and faceted by the obese variable.\n\n\n\n\nThe way that we interpret the facet_wrap(~ obese) command is that we want to create a grid of plots, with each plot showing a different subset of the data based on the levels of the obese variable. In this case, we have two levels of the obese variable: obese and not obese, so we get two plots in the grid.",
    "crumbs": [
      "Exploring data",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Plotting with ggplot2</span>"
    ]
  },
  {
    "objectID": "ggplot.html#labels",
    "href": "ggplot.html#labels",
    "title": "\n10  Plotting with ggplot2\n",
    "section": "\n10.6 Labels",
    "text": "10.6 Labels\nLabels are an important part of any plot. They help the viewer understand what the plot is showing and what the axes represent. While our plot already has labels for the x and y axes, we can add a title to the plot and change the labels for the x and y axes to make them more descriptive.\n\n# add points to the plot, colored by the smoker variable, faceted by the obese variable, and add labels\nggplot(\n    data = insurance,\n    mapping = aes(x = age, y = charges, color = smoker)\n) +\n    geom_point() +\n    geom_smooth(method = \"lm\") +\n    facet_wrap(~obese) +\n    labs(\n        title = \"Medical Charges as a function of patient characteristics\",\n        subtitle = \"US Census Bureau 2013 data\",\n        caption = \"Source: https://github.com/stedy/Machine-Learning-with-R-datasets\",\n        x = \"Age\",\n        y = \"Annual Medical Charges\",\n        color = \"Smoker?\"\n    )\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\nFigure 10.9: A scatter plot with age on the x-axis and charges on the y-axis, colored by the smoker variable, and faceted by the obese variable, with labels.",
    "crumbs": [
      "Exploring data",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Plotting with ggplot2</span>"
    ]
  },
  {
    "objectID": "ggplot.html#themes",
    "href": "ggplot.html#themes",
    "title": "\n10  Plotting with ggplot2\n",
    "section": "\n10.7 Themes",
    "text": "10.7 Themes\nThemes are a way to control the non-data ink in a plot, such as the background color, grid lines, and text size. Rather than specifying each element individually, you can use a pre-defined theme to quickly style your plot. For a nice overview of themes in ggplot2, see the the ggplot2 themes gallery.\nTo create a more visually appealing plot, we can apply the theme_minimal() theme to our plot. This theme removes the background grid lines and adds a light gray background to the plot.\n\n# add points to the plot, colored by the smoker variable, faceted by the obese variable, add labels, and apply a minimal theme\nggplot(\n    data = insurance,\n    mapping = aes(x = age, y = charges, color = smoker)\n) +\n    geom_point() +\n    geom_smooth(method = \"lm\") +\n    facet_wrap(~obese) +\n    labs(\n        title = \"Medical Charges as a function of patient characteristics\",\n        subtitle = \"US Census Bureau 2013 data\",\n        caption = \"Source: https://github.com/stedy/Machine-Learning-with-R-datasets\",\n        x = \"Age\",\n        y = \"Annual Medical Charges\",\n        color = \"Smoker?\"\n    ) +\n    theme_minimal()\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\nFigure 10.10: A scatter plot with age on the x-axis and charges on the y-axis, colored by the smoker variable, faceted by the obese variable, with labels and a minimal theme.",
    "crumbs": [
      "Exploring data",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Plotting with ggplot2</span>"
    ]
  },
  {
    "objectID": "ggplot.html#saving-a-plot",
    "href": "ggplot.html#saving-a-plot",
    "title": "\n10  Plotting with ggplot2\n",
    "section": "\n10.8 Saving a Plot",
    "text": "10.8 Saving a Plot\nOnce you have created a plot that you are happy with, you may want to save it to a file for use in a report or presentation. The ggsave() function in ggplot2 allows you to save a plot to a file in a variety of formats, including PNG, PDF, and SVG. Take a look at the help for ggsave() to see the available options. In particular, you can specify the file name, width, height, and resolution of the saved plot.\n\n# save the plot to a file\nggsave(\"insurance_plot.png\")\n\nSaving 7 x 5 in image\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\nNote\n\n\n\nThe ggsave() function saves the last plot that you created with ggplot2. ggsave() will save the plot to the working directory by default, but you can specify a different directory by providing the full path to the file name.",
    "crumbs": [
      "Exploring data",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Plotting with ggplot2</span>"
    ]
  },
  {
    "objectID": "ggplot.html#references",
    "href": "ggplot.html#references",
    "title": "\n10  Plotting with ggplot2\n",
    "section": "References",
    "text": "References\n\n\nCaron, Stéphane. 2018. “The Grammar of Graphics.” https://dotlayer.org/en/grammar-of-graphics/.\n\n\nCenter, Pew Research. 2016. “Lifelong Learning and\nTechnology.” Pew Research Center: Internet,\nScience & Tech. https://www.pewresearch.org/internet/2016/03/22/lifelong-learning-and-technology/.\n\n\nKnowles, Malcolm S., Elwood F. Holton, and Richard A. Swanson. 2005.\nThe Adult Learner: The Definitive Classic in Adult Education and\nHuman Resource Development. 6th ed. Amsterdam ; Boston: Elsevier.\n\n\nWickham, Hadley. 2014. “Tidy Data.” Journal of\nStatistical Software, Articles 59 (10): 1–23. https://doi.org/10.18637/jss.v059.i10.",
    "crumbs": [
      "Exploring data",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Plotting with ggplot2</span>"
    ]
  },
  {
    "objectID": "310_microbiome.html",
    "href": "310_microbiome.html",
    "title": "\n11  Microbiome analysis\n",
    "section": "",
    "text": "11.1 Loading the data\nBefore we can start analyzing the microbiome data, we need to load the data into R. The data is typically stored in a tabular format after quantification of microbial abundances in different samples. In this case, we will use a dataset built into the mia package. The mia package provides a collection of microbiome datasets for educational purposes and includes functions for processing and analyzing microbiome data.\nTo load the data, we first need to install and load the mia package. If you haven’t installed the mia package yet, you can do so using the following command:\n# Install the mia package\nBiocManager::install(\"microbiome/mia\")\nOnce the mia package is installed, you can load it into your R session using the following command:\n# Load the mia package\nlibrary(mia)\nNow that the mia package is loaded, we can load the microbiome dataset that we will be working with.\nWe will be using the curatedMetagenomicData package to load the FengQ_2015 dataset. This dataset contains microbiome data from a study by Feng et al. (2015). The curatedMetagenomicData package provides a convenient interface for accessing microbiome datasets that have been pre-processed and curated for analysis.\nIgnore the details of the code for now, but suffice it to say that what the code will do for us is to load a dataset for downstream analysis.\n# Load the FengQ_2015 dataset\nlibrary(curatedMetagenomicData)\ntse &lt;- curatedMetagenomicData(\"FengQ_2015.relative_abundance\", dryrun = FALSE, rownames = \"short\")[[1]]\n\n\n$`2021-03-31.FengQ_2015.relative_abundance`\ndropping rows without rowTree matches:\n  k__Bacteria|p__Actinobacteria|c__Coriobacteriia|o__Coriobacteriales|f__Atopobiaceae|g__Olsenella|s__Olsenella_profusa\n  k__Bacteria|p__Actinobacteria|c__Coriobacteriia|o__Coriobacteriales|f__Coriobacteriaceae|g__Collinsella|s__Collinsella_stercoris\n  k__Bacteria|p__Actinobacteria|c__Coriobacteriia|o__Coriobacteriales|f__Coriobacteriaceae|g__Enorma|s__[Collinsella]_massiliensis\n  k__Bacteria|p__Firmicutes|c__Bacilli|o__Bacillales|f__Bacillales_unclassified|g__Gemella|s__Gemella_bergeri\n  k__Bacteria|p__Firmicutes|c__Bacilli|o__Lactobacillales|f__Carnobacteriaceae|g__Granulicatella|s__Granulicatella_elegans\n  k__Bacteria|p__Firmicutes|c__Clostridia|o__Clostridiales|f__Ruminococcaceae|g__Ruminococcus|s__Ruminococcus_champanellensis\n  k__Bacteria|p__Firmicutes|c__Erysipelotrichia|o__Erysipelotrichales|f__Erysipelotrichaceae|g__Bulleidia|s__Bulleidia_extructa\n  k__Bacteria|p__Proteobacteria|c__Betaproteobacteria|o__Burkholderiales|f__Sutterellaceae|g__Sutterella|s__Sutterella_parvirubra\n  k__Bacteria|p__Synergistetes|c__Synergistia|o__Synergistales|f__Synergistaceae|g__Cloacibacillus|s__Cloacibacillus_evryensis",
    "crumbs": [
      "Applications",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Microbiome analysis</span>"
    ]
  },
  {
    "objectID": "310_microbiome.html#loading-the-data",
    "href": "310_microbiome.html#loading-the-data",
    "title": "\n11  Microbiome analysis\n",
    "section": "",
    "text": "Note\n\n\n\nNote: The mia package is part of the Bioconductor project, but in this case, we are installing it directly from GitHub using the microbiome/mia repository. This is a common practice when working with development versions of packages or with packages that are not yet available on Bioconductor.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nIf you are working with your own microbiome data, you will often need to load it into R using functions like read.csv() or read.table() to read tabular data files. Make sure your data is properly formatted and cleaned before loading it into R for analysis.",
    "crumbs": [
      "Applications",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Microbiome analysis</span>"
    ]
  },
  {
    "objectID": "310_microbiome.html#exploring-the-data",
    "href": "310_microbiome.html#exploring-the-data",
    "title": "\n11  Microbiome analysis\n",
    "section": "\n11.2 Exploring the data",
    "text": "11.2 Exploring the data\nOnce the data is loaded into R, we can start exploring the data to understand its structure and contents. The tse object is a TreeSummarizedExperiment object, which is a specialized data structure for storing microbiome data in R. We can use various functions to explore the data stored in the tse object.\nTo get an overview of the data, we can simply type the name of the object in the R console:\n\n# Print the object\ntse\n\nclass: TreeSummarizedExperiment \ndim: 601 154 \nmetadata(1): agglomerated_by_rank\nassays(1): relative_abundance\nrownames(601): [Bacteroides] pectinophilus [Butyribacterium]\n  methylotrophicum ... Weissella cibaria Weissella viridescens\nrowData names(7): superkingdom phylum ... genus species\ncolnames(154): SID31004 SID31009 ... SID532832 SID532915\ncolData names(28): study_name subject_id ... ldl hba1c\nreducedDimNames(0):\nmainExpName: NULL\naltExpNames(0):\nrowLinks: a LinkDataFrame (601 rows)\nrowTree: 1 phylo tree(s) (10430 leaves)\ncolLinks: NULL\ncolTree: NULL\n\n\nNote that the output of the tse object will show you the dimensions of the data, the metadata associated with the samples and features, etc. However, the data themselves are not printed to the console due to the large size of the dataset. The TreeSummarizedExperiment object is a complex data structure that contains multiple components, including the abundance data, sample information, feature information, and other metadata.\nThe sample information is stored in the colData slot of the Tito2024QMP object. You can access the sample information using the colData() function:\n\n# Access the sample information\ncolData(tse)\n\nDataFrame with 154 rows and 28 columns\n           study_name  subject_id   body_site antibiotics_current_use\n          &lt;character&gt; &lt;character&gt; &lt;character&gt;             &lt;character&gt;\nSID31004   FengQ_2015    SID31004       stool                      no\nSID31009   FengQ_2015    SID31009       stool                      no\nSID31021   FengQ_2015    SID31021       stool                      no\nSID31030   FengQ_2015    SID31030       stool                      no\nSID31071   FengQ_2015    SID31071       stool                      no\n...               ...         ...         ...                     ...\nSID532796  FengQ_2015   SID532796       stool                      no\nSID532802  FengQ_2015   SID532802       stool                      no\nSID532826  FengQ_2015   SID532826       stool                      no\nSID532832  FengQ_2015   SID532832       stool                      no\nSID532915  FengQ_2015   SID532915       stool                      no\n          study_condition                disease       age age_category\n              &lt;character&gt;            &lt;character&gt; &lt;integer&gt;  &lt;character&gt;\nSID31004              CRC CRC;fatty_liver;hype..        64        adult\nSID31009          control fatty_liver;hyperten..        68       senior\nSID31021          control                healthy        60        adult\nSID31030          adenoma adenoma;fatty_liver;..        70       senior\nSID31071          control            fatty_liver        68       senior\n...                   ...                    ...       ...          ...\nSID532796         control fatty_liver;hyperten..        73       senior\nSID532802         control                healthy        68       senior\nSID532826         control T2D;fatty_liver;hype..        78       senior\nSID532832         adenoma adenoma;fatty_liver;..        68       senior\nSID532915         control                healthy        43        adult\n               gender     country non_westernized sequencing_platform\n          &lt;character&gt; &lt;character&gt;     &lt;character&gt;         &lt;character&gt;\nSID31004         male         AUT              no       IlluminaHiSeq\nSID31009         male         AUT              no       IlluminaHiSeq\nSID31021       female         AUT              no       IlluminaHiSeq\nSID31030         male         AUT              no       IlluminaHiSeq\nSID31071         male         AUT              no       IlluminaHiSeq\n...               ...         ...             ...                 ...\nSID532796      female         AUT              no       IlluminaHiSeq\nSID532802        male         AUT              no       IlluminaHiSeq\nSID532826        male         AUT              no       IlluminaHiSeq\nSID532832      female         AUT              no       IlluminaHiSeq\nSID532915      female         AUT              no       IlluminaHiSeq\n          DNA_extraction_kit        PMID number_reads number_bases\n                 &lt;character&gt; &lt;character&gt;    &lt;integer&gt;    &lt;numeric&gt;\nSID31004               MoBio    25758642     40898340   3649611221\nSID31009               MoBio    25758642     66107961   6196998053\nSID31021               MoBio    25758642     60789126   5708593447\nSID31030               MoBio    25758642     50300253   4741158330\nSID31071               MoBio    25758642     51945426   4913627034\n...                      ...         ...          ...          ...\nSID532796              MoBio    25758642     50845712   4754848864\nSID532802              MoBio    25758642     41480415   3868696049\nSID532826              MoBio    25758642     35346002   3348368467\nSID532832              MoBio    25758642     42184599   3951224696\nSID532915              MoBio    25758642     51594677   4886998833\n          minimum_read_length median_read_length      NCBI_accession\n                    &lt;integer&gt;          &lt;integer&gt;         &lt;character&gt;\nSID31004                   30                 93 ERR688505;ERR688358\nSID31009                   30                 96 ERR688506;ERR688359\nSID31021                   30                 96 ERR688507;ERR688360\nSID31030                   30                 96 ERR688508;ERR688361\nSID31071                   30                 97 ERR688509;ERR688362\n...                       ...                ...                 ...\nSID532796                  30                 95 ERR710428;ERR710419\nSID532802                  30                 96 ERR710429;ERR710420\nSID532826                  30                 97 ERR710430;ERR710421\nSID532832                  30                 96 ERR710431;ERR710422\nSID532915                  30                 96 ERR710432;ERR710423\n                         curator       BMI        diet disease_subtype\n                     &lt;character&gt; &lt;numeric&gt; &lt;character&gt;     &lt;character&gt;\nSID31004  Paolo_Manghi;Marisa_..     29.35  vegetarian       carcinoma\nSID31009  Paolo_Manghi;Marisa_..     32.00    omnivore              NA\nSID31021  Paolo_Manghi;Marisa_..     22.10    omnivore              NA\nSID31030  Paolo_Manghi;Marisa_..     34.11    omnivore advancedadenoma\nSID31071  Paolo_Manghi;Marisa_..     23.45    omnivore              NA\n...                          ...       ...         ...             ...\nSID532796 Paolo_Manghi;Marisa_..     26.56    omnivore              NA\nSID532802 Paolo_Manghi;Marisa_..     23.53    omnivore              NA\nSID532826 Paolo_Manghi;Marisa_..     31.22    omnivore              NA\nSID532832 Paolo_Manghi;Marisa_..     27.55    omnivore advancedadenoma\nSID532915 Paolo_Manghi;Marisa_..     22.65    omnivore              NA\n                  tnm triglycerides       hdl       ldl     hba1c\n          &lt;character&gt;     &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt;\nSID31004       t1n0m0           172        28        92       5.2\nSID31009           NA           101        50       157        NA\nSID31021           NA            53        60       122        NA\nSID31030           NA            89        74       146        NA\nSID31071           NA           258        40       231        NA\n...               ...           ...       ...       ...       ...\nSID532796          NA           100        61       114       5.4\nSID532802          NA            80        67       158       5.8\nSID532826          NA           212        32        90       6.9\nSID532832          NA           141        51       184       5.6\nSID532915          NA            51        80       132       5.1\n\n\nAs you can see, there is a lot of information stored in the colData slot, including sample IDs, study conditions, and other metadata associated with the samples. This information is essential for understanding the context of the microbiome data and for performing downstream analyses.",
    "crumbs": [
      "Applications",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Microbiome analysis</span>"
    ]
  },
  {
    "objectID": "310_microbiome.html#community-indices",
    "href": "310_microbiome.html#community-indices",
    "title": "\n11  Microbiome analysis\n",
    "section": "\n11.3 Community indices",
    "text": "11.3 Community indices\nIn the field of microbiome ecology several indices to describe samples and community of samples are available. In this vignette we just want to give a very brief introduction.\nFunctions for calculating alpha and beta diversity indices are available. Using addAlpha multiple diversity indices are calculated by default and results are stored automatically in colData. Selected indices can be calculated individually by setting index = \"shannon\" for example.\n\ntse &lt;- addAlpha(tse, index = \"shannon\", assay.type = \"relative_abundance\")\ncolnames(colData(tse))\n\n [1] \"study_name\"              \"subject_id\"             \n [3] \"body_site\"               \"antibiotics_current_use\"\n [5] \"study_condition\"         \"disease\"                \n [7] \"age\"                     \"age_category\"           \n [9] \"gender\"                  \"country\"                \n[11] \"non_westernized\"         \"sequencing_platform\"    \n[13] \"DNA_extraction_kit\"      \"PMID\"                   \n[15] \"number_reads\"            \"number_bases\"           \n[17] \"minimum_read_length\"     \"median_read_length\"     \n[19] \"NCBI_accession\"          \"curator\"                \n[21] \"BMI\"                     \"diet\"                   \n[23] \"disease_subtype\"         \"tnm\"                    \n[25] \"triglycerides\"           \"hdl\"                    \n[27] \"ldl\"                     \"hba1c\"                  \n[29] \"shannon\"                \n\n\nAnd we can look at the resulting colData() which now contains the calculated alpha diversity indices.\n\ncolData(tse)\n\nDataFrame with 154 rows and 29 columns\n           study_name  subject_id   body_site antibiotics_current_use\n          &lt;character&gt; &lt;character&gt; &lt;character&gt;             &lt;character&gt;\nSID31004   FengQ_2015    SID31004       stool                      no\nSID31009   FengQ_2015    SID31009       stool                      no\nSID31021   FengQ_2015    SID31021       stool                      no\nSID31030   FengQ_2015    SID31030       stool                      no\nSID31071   FengQ_2015    SID31071       stool                      no\n...               ...         ...         ...                     ...\nSID532796  FengQ_2015   SID532796       stool                      no\nSID532802  FengQ_2015   SID532802       stool                      no\nSID532826  FengQ_2015   SID532826       stool                      no\nSID532832  FengQ_2015   SID532832       stool                      no\nSID532915  FengQ_2015   SID532915       stool                      no\n          study_condition                disease       age age_category\n              &lt;character&gt;            &lt;character&gt; &lt;integer&gt;  &lt;character&gt;\nSID31004              CRC CRC;fatty_liver;hype..        64        adult\nSID31009          control fatty_liver;hyperten..        68       senior\nSID31021          control                healthy        60        adult\nSID31030          adenoma adenoma;fatty_liver;..        70       senior\nSID31071          control            fatty_liver        68       senior\n...                   ...                    ...       ...          ...\nSID532796         control fatty_liver;hyperten..        73       senior\nSID532802         control                healthy        68       senior\nSID532826         control T2D;fatty_liver;hype..        78       senior\nSID532832         adenoma adenoma;fatty_liver;..        68       senior\nSID532915         control                healthy        43        adult\n               gender     country non_westernized sequencing_platform\n          &lt;character&gt; &lt;character&gt;     &lt;character&gt;         &lt;character&gt;\nSID31004         male         AUT              no       IlluminaHiSeq\nSID31009         male         AUT              no       IlluminaHiSeq\nSID31021       female         AUT              no       IlluminaHiSeq\nSID31030         male         AUT              no       IlluminaHiSeq\nSID31071         male         AUT              no       IlluminaHiSeq\n...               ...         ...             ...                 ...\nSID532796      female         AUT              no       IlluminaHiSeq\nSID532802        male         AUT              no       IlluminaHiSeq\nSID532826        male         AUT              no       IlluminaHiSeq\nSID532832      female         AUT              no       IlluminaHiSeq\nSID532915      female         AUT              no       IlluminaHiSeq\n          DNA_extraction_kit        PMID number_reads number_bases\n                 &lt;character&gt; &lt;character&gt;    &lt;integer&gt;    &lt;numeric&gt;\nSID31004               MoBio    25758642     40898340   3649611221\nSID31009               MoBio    25758642     66107961   6196998053\nSID31021               MoBio    25758642     60789126   5708593447\nSID31030               MoBio    25758642     50300253   4741158330\nSID31071               MoBio    25758642     51945426   4913627034\n...                      ...         ...          ...          ...\nSID532796              MoBio    25758642     50845712   4754848864\nSID532802              MoBio    25758642     41480415   3868696049\nSID532826              MoBio    25758642     35346002   3348368467\nSID532832              MoBio    25758642     42184599   3951224696\nSID532915              MoBio    25758642     51594677   4886998833\n          minimum_read_length median_read_length      NCBI_accession\n                    &lt;integer&gt;          &lt;integer&gt;         &lt;character&gt;\nSID31004                   30                 93 ERR688505;ERR688358\nSID31009                   30                 96 ERR688506;ERR688359\nSID31021                   30                 96 ERR688507;ERR688360\nSID31030                   30                 96 ERR688508;ERR688361\nSID31071                   30                 97 ERR688509;ERR688362\n...                       ...                ...                 ...\nSID532796                  30                 95 ERR710428;ERR710419\nSID532802                  30                 96 ERR710429;ERR710420\nSID532826                  30                 97 ERR710430;ERR710421\nSID532832                  30                 96 ERR710431;ERR710422\nSID532915                  30                 96 ERR710432;ERR710423\n                         curator       BMI        diet disease_subtype\n                     &lt;character&gt; &lt;numeric&gt; &lt;character&gt;     &lt;character&gt;\nSID31004  Paolo_Manghi;Marisa_..     29.35  vegetarian       carcinoma\nSID31009  Paolo_Manghi;Marisa_..     32.00    omnivore              NA\nSID31021  Paolo_Manghi;Marisa_..     22.10    omnivore              NA\nSID31030  Paolo_Manghi;Marisa_..     34.11    omnivore advancedadenoma\nSID31071  Paolo_Manghi;Marisa_..     23.45    omnivore              NA\n...                          ...       ...         ...             ...\nSID532796 Paolo_Manghi;Marisa_..     26.56    omnivore              NA\nSID532802 Paolo_Manghi;Marisa_..     23.53    omnivore              NA\nSID532826 Paolo_Manghi;Marisa_..     31.22    omnivore              NA\nSID532832 Paolo_Manghi;Marisa_..     27.55    omnivore advancedadenoma\nSID532915 Paolo_Manghi;Marisa_..     22.65    omnivore              NA\n                  tnm triglycerides       hdl       ldl     hba1c   shannon\n          &lt;character&gt;     &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt;\nSID31004       t1n0m0           172        28        92       5.2   3.28881\nSID31009           NA           101        50       157        NA   3.10400\nSID31021           NA            53        60       122        NA   3.37028\nSID31030           NA            89        74       146        NA   2.59465\nSID31071           NA           258        40       231        NA   3.14486\n...               ...           ...       ...       ...       ...       ...\nSID532796          NA           100        61       114       5.4   3.65802\nSID532802          NA            80        67       158       5.8   3.19414\nSID532826          NA           212        32        90       6.9   3.15717\nSID532832          NA           141        51       184       5.6   3.21046\nSID532915          NA            51        80       132       5.1   3.48644\n\n\ncolData(tse) is a DataFrame object, which is a subclass of data.frame.\n\n\n\n\n\n\nClasses and subclasses in R\n\n\n\nWhen we say that an object in R (or other languages) is a subclass of another object, we mean that it inherits properties and methods from the parent object. In this case, a DataFrame object inherits properties and methods from the data.frame object, but it may have additional features specific to the DataFrame class.\nIn practice, this means that you can use DataFrame objects in the same way you would use data.frame objects, but you may also have access to additional functionality specific to the DataFrame class.\n\n\nRemember that the alpha diversity indices are calculated for each sample. We can visualize the distribution of the Shannon index across different sample groups using a histogram or a density plot as shown in Figure 11.1\n\n# Load the ggplot2 package for visualization\nlibrary(ggplot2)\nggplot(colData(tse), aes(x = shannon)) +\n    geom_density()\n\n\n\n\n\n\nFigure 11.1: Alpha diversity (Shannon index) distribution across all samples\n\n\n\n\nWe can also compare the alpha diversity indices between different sample groups. For example, we can compare the Shannon index between samples from different diagnosis groups (e.g., colorectal cancer, colon adenoma, and healthy controls) as shown in Figure 11.2.\n\nggplot(colData(tse), aes(x = shannon, color = study_condition)) +\n    geom_density()\n\n\n\n\n\n\nFigure 11.2: Alpha diversity (Shannon index) by study condition\n\n\n\n\nExercise: Visualize the alpha diversity index for another sample group such as age_category or gender. As a hint, what would you change in the aes() function to plot the data by a different variable?\nExercise: Examine the relationship between age and alpha diversity. You can use a scatter plot to visualize the relationship between age and the Shannon index. What will you need to change in the aes() function to plot this relationship? And what geom_ function would you use to create the scatter plot?\nBeta diversity indices are used to describe inter-sample connections. Technically they are calculated as dist object and reduced dimensions can be extracted using cmdscale. This is wrapped up in the runMDS function of the scater package, but can be easily used to calculated beta diversity indices using the established functions from the vegan package or any other package using comparable inputs.\n\nlibrary(scater)\n\nLoading required package: scuttle\n\naltExp(tse, \"Genus\") &lt;- runMDS(tse,\n    FUN = vegan::vegdist,\n    method = \"bray\",\n    name = \"BrayCurtis\",\n    ncomponents = 5,\n    assay.type = \"relative_abundance\",\n    keep_dist = TRUE\n)\n\nJSD and UniFrac are implemented in mia as well. calculateJSD can be used as a drop-in replacement in the example above (omit the method argument as well) to calculate the JSD. For calculating the UniFrac distance via calculateUniFrac either a TreeSummarizedExperiment must be used or a tree supplied via the tree argument. For more details see ?calculateJSD, ?calculateUnifrac or ?getDPCoA.\nrunMDS performs the decomposition. Alternatively addNMDS can also be used.",
    "crumbs": [
      "Applications",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Microbiome analysis</span>"
    ]
  },
  {
    "objectID": "310_microbiome.html#other-indices",
    "href": "310_microbiome.html#other-indices",
    "title": "\n11  Microbiome analysis\n",
    "section": "\n11.4 Other indices",
    "text": "11.4 Other indices\nestimateDominance and estimateEvenness implement other sample-wise indices. The function behave equivalently to estimateDiversity. For more information see the corresponding man pages.",
    "crumbs": [
      "Applications",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Microbiome analysis</span>"
    ]
  },
  {
    "objectID": "data_structures_overview.html",
    "href": "data_structures_overview.html",
    "title": "R data structures",
    "section": "",
    "text": "Chapter overview\nAs you progress through these chapters, practice the examples and exercises provided, engage in discussion, and collaborate with your peers to deepen your understanding of R data structures. This solid foundation will serve as the basis for more advanced data manipulation, analysis, and visualization techniques in R.",
    "crumbs": [
      "R data structures"
    ]
  },
  {
    "objectID": "data_structures_overview.html#chapter-overview",
    "href": "data_structures_overview.html#chapter-overview",
    "title": "R data structures",
    "section": "",
    "text": "Vectors : In this chapter, we will introduce you to the simplest data structure in R, the vector. We will cover how to create, access, and manipulate vectors, as well as discuss their unique properties and limitations.\n\nMatrices\n\nNext, we will explore matrices, which are two-dimensional data structures that extend vectors. You will learn how to create, access, and manipulate matrices, and understand their usefulness in mathematical operations and data organization.\n\n\n\nLists\n\nThe third chapter will focus on lists, a versatile data structure that can store elements of different types and sizes. We will discuss how to create, access, and modify lists, and demonstrate their flexibility in handling complex data structures.\n\n\n\nData.frames\n\nFinally, we will examine data.frames, a widely-used data structure for organizing and manipulating tabular data. You will learn how to create, access, and manipulate data.frames, and understand their advantages over other data structures for data analysis tasks.\n\n\n\nArrays\n\nWhile we will not focus directly on the array data type, which are multidimensional data structures that extend matrices, they are very similar to matrices, but with a third dimension.",
    "crumbs": [
      "R data structures"
    ]
  }
]